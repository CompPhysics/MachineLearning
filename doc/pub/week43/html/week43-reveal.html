<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week43-reveal.html week43-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title></title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<p>ATITLE: Week 43: Deep Learning: Convolutional Neural Networks and Recurrent Neural Networks

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics, University of Oslo</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and National Superconducting Cyclotron Laboratory, Michigan State University</b>
</center>
<br>
<center>
<h4>Oct 26, 2022</h4>
</center> <!-- date -->
<br>
</p>


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2022, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>

<section>
<h2 id="plans-for-week-43">Plans for week 43 </h2>

<ul>
<p><li> Thursday: Convolutional Neural Networks (CNN)</li>
<p><li> Friday: Recurrent Neural Networks (RNN)</li>
</ul>
<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Excellent lectures on CNNs and RNNs</b>
<p>
<ul>
<p><li> <a href="https://www.youtube.com/watch?v=iaSUYvmCekI&ab_channel=AlexanderAmini" target="_blank">Video  on Convolutional Neural Networks from MIT</a></li>
<p><li> <a href="https://www.youtube.com/watch?v=SEnXr6v2ifU&ab_channel=AlexanderAmini" target="_blank">Video  on Recurrent Neural Networks from MIT</a></li>
<p><li> <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi" target="_blank">Video on Deep Learning</a></li>
</ul>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>More resources</b>
<p>
<ul>
<p><li> <a href="https://www.uio.no/studier/emner/matnat/ifi/IN5400/v20/material/week10/in5400_2020_week10_recurrent_neural_network.pdf" target="_blank">IN5400 at UiO Lecture</a></li>
<p><li> <a href="https://www.youtube.com/watch?v=6niqTuYFZLQ&list=PLzUTmXVwsnXod6WNdg57Yc3zFx_f-RYsq&index=10&ab_channel=StanfordUniversitySchoolofEngineering" target="_blank">CS231 at Stanford Lecture</a></li>
</ul>
</div>
</section>

<section>
<h2 id="reading-recommendations">Reading Recommendations </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>CNN readings</b>
<p>
<ol>
<p><li> <a href="https://www.deeplearningbook.org/contents/convnets.html" target="_blank">Goodfellow, Bengio, Courville, chapter 9</a></li>
<p><li> <a href="http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture5.pdf" target="_blank">Lectures from CS231 at Stanford</a></li>
<p><li> <a href="http://neuralnetworksanddeeplearning.com/chap6.html" target="_blank">Michael Nielsen's book is a must read, in particular chapter 6 which deals with CNNs</a>.</li>
</ol>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>RNN readings</b>
<p>
<ol>
<p><li> <a href="https://www.deeplearningbook.org/contents/rnn.html" target="_blank">Goodfellow et al</a>, chapter 10 on Recurrent NNs, chapters 11 and 12 on various practicalities around deep learning are also recommended.</li>
<p><li> <a href="http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture10.pdf" target="_blank">Lectures from CS231 at Stanford</a></li>
<p><li> Aurelien Geron, chapter 14 on RNNs.</li>
</ol>
</div>
</section>

<section>
<h2 id="convolutional-neural-networks-recognizing-images">Convolutional Neural Networks (recognizing images) </h2>

<p>Convolutional neural networks (CNNs) were developed during the last
decade of the previous century, with a focus on character recognition
tasks. Nowadays, CNNs are a central element in the spectacular success
of deep learning methods. The success in for example image
classifications have made them a central tool for most machine
learning practitioners.
</p>

<p>CNNs are very similar to ordinary Neural Networks.
They are made up of neurons that have learnable weights and
biases. Each neuron receives some inputs, performs a dot product and
optionally follows it with a non-linearity. The whole network still
expresses a single differentiable score function: from the raw image
pixels on one end to class scores at the other. And they still have a
loss function (for example Softmax) on the last (fully-connected) layer
and all the tips/tricks we developed for learning regular Neural
Networks still apply (back propagation, gradient descent etc etc).
</p>
</section>

<section>
<h2 id="what-is-the-difference">What is the Difference </h2>

<p><b>CNN architectures make the explicit assumption that
the inputs are images, which allows us to encode certain properties
into the architecture. These then make the forward function more
efficient to implement and vastly reduce the amount of parameters in
the network.</b>
</p>

<p>Here we provide only a superficial overview, for the more interested, we recommend highly the course
<a href="https://www.uio.no/studier/emner/matnat/ifi/IN5400/index-eng.html" target="_blank">IN5400 &#8211; Machine Learning for Image Analysis</a>
and the slides of <a href="http://cs231n.github.io/convolutional-networks/" target="_blank">CS231</a>.
</p>

<p>Another good read is the article here <a href="https://arxiv.org/pdf/1603.07285.pdf" target="_blank"><tt>https://arxiv.org/pdf/1603.07285.pdf</tt></a>. </p>
</section>

<section>
<h2 id="neural-networks-vs-cnns">Neural Networks vs CNNs </h2>

<p>Neural networks are defined as <b>affine transformations</b>, that is 
a vector is received as input and is multiplied with a matrix of so-called weights (our unknown paramters) to produce an
output (to which a bias vector is usually added before passing the result
through a nonlinear activation function). This is applicable to any type of input, be it an
image, a sound clip or an unordered collection of features: whatever their
dimensionality, their representation can always be flattened into a vector
before the transformation.
</p>
</section>

<section>
<h2 id="why-cnns-for-images-sound-files-medical-images-from-ct-scans-etc">Why CNNS for images, sound files, medical images from CT scans etc? </h2>

<p>However, when we consider images, sound clips and many other similar kinds of data, these data  have an intrinsic
structure. More formally, they share these important properties:
</p>
<ul>
<p><li> They are stored as multi-dimensional arrays (think of the pixels of a figure) .</li>
<p><li> They feature one or more axes for which ordering matters (e.g., width and height axes for an image, time axis for a sound clip).</li>
<p><li> One axis, called the channel axis, is used to access different views of the data (e.g., the red, green and blue channels of a color image, or the left and right channels of a stereo audio track).</li>
</ul>
<p>
<p>These properties are not exploited when an affine transformation is applied; in
fact, all the axes are treated in the same way and the topological information
is not taken into account. Still, taking advantage of the implicit structure of
the data may prove very handy in solving some tasks, like computer vision and
speech recognition, and in these cases it would be best to preserve it. This is
where discrete convolutions come into play.
</p>

<p>A discrete convolution is a linear transformation that preserves this notion of
ordering. It is sparse (only a few input units contribute to a given output
unit) and reuses parameters (the same weights are applied to multiple locations
in the input).
</p>
</section>

<section>
<h2 id="regular-nns-don-t-scale-well-to-full-images">Regular NNs don&#8217;t scale well to full images </h2>

<p>As an example, consider
an image of size \( 32\times 32\times 3 \) (32 wide, 32 high, 3 color channels), so a
single fully-connected neuron in a first hidden layer of a regular
Neural Network would have \( 32\times 32\times 3 = 3072 \) weights. This amount still
seems manageable, but clearly this fully-connected structure does not
scale to larger images. For example, an image of more respectable
size, say \( 200\times 200\times 3 \), would lead to neurons that have 
\( 200\times 200\times 3 = 120,000 \) weights. 
</p>

<p>We could have
several such neurons, and the parameters would add up quickly! Clearly,
this full connectivity is wasteful and the huge number of parameters
would quickly lead to possible overfitting.
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 1:  A regular 3-layer Neural Network. </p>
</center>
<p><img src="figslides/nn.jpeg" width="500" align="bottom"></p>
</center>
</section>

<section>
<h2 id="3d-volumes-of-neurons">3D volumes of neurons </h2>

<p>Convolutional Neural Networks take advantage of the fact that the
input consists of images and they constrain the architecture in a more
sensible way. 
</p>

<p>In particular, unlike a regular Neural Network, the
layers of a CNN have neurons arranged in 3 dimensions: width,
height, depth. (Note that the word depth here refers to the third
dimension of an activation volume, not to the depth of a full Neural
Network, which can refer to the total number of layers in a network.)
</p>

<p>To understand it better, the above example of an image 
with an input volume of
activations has dimensions \( 32\times 32\times 3 \) (width, height,
depth respectively). 
</p>

<p>The neurons in a layer will
only be connected to a small region of the layer before it, instead of
all of the neurons in a fully-connected manner. Moreover, the final
output layer could  for this specific image have dimensions \( 1\times 1 \times 10 \), 
because by the
end of the CNN architecture we will reduce the full image into a
single vector of class scores, arranged along the depth
dimension. 
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 2:  A CNN arranges its neurons in three dimensions (width, height, depth), as visualized in one of the layers. Every layer of a CNN transforms the 3D input volume to a 3D output volume of neuron activations. In this example, the red input layer holds the image, so its width and height would be the dimensions of the image, and the depth would be 3 (Red, Green, Blue channels). </p>
</center>
<p><img src="figslides/cnn.jpeg" width="500" align="bottom"></p>
</center>
</section>

<section>
<h2 id="layers-used-to-build-cnns">Layers used to build CNNs </h2>

<p>A simple CNN is a sequence of layers, and every layer of a CNN
transforms one volume of activations to another through a
differentiable function. We use three main types of layers to build
CNN architectures: Convolutional Layer, Pooling Layer, and
Fully-Connected Layer (exactly as seen in regular Neural Networks). We
will stack these layers to form a full CNN architecture.
</p>

<p>A simple CNN for image classification could have the architecture:</p>

<ul>
<p><li> <b>INPUT</b> (\( 32\times 32 \times 3 \)) will hold the raw pixel values of the image, in this case an image of width 32, height 32, and with three color channels R,G,B.</li>
<p><li> <b>CONV</b> (convolutional )layer will compute the output of neurons that are connected to local regions in the input, each computing a dot product between their weights and a small region they are connected to in the input volume. This may result in volume such as \( [32\times 32\times 12] \) if we decided to use 12 filters.</li>
<p><li> <b>RELU</b> layer will apply an elementwise activation function, such as the \( max(0,x) \) thresholding at zero. This leaves the size of the volume unchanged (\( [32\times 32\times 12] \)).</li>
<p><li> <b>POOL</b> (pooling) layer will perform a downsampling operation along the spatial dimensions (width, height), resulting in volume such as \( [16\times 16\times 12] \).</li>
<p><li> <b>FC</b> (i.e. fully-connected) layer will compute the class scores, resulting in volume of size \( [1\times 1\times 10] \), where each of the 10 numbers correspond to a class score, such as among the 10 categories of the MNIST images we considered above . As with ordinary Neural Networks and as the name implies, each neuron in this layer will be connected to all the numbers in the previous volume.</li>
</ul>
</section>

<section>
<h2 id="transforming-images">Transforming images </h2>

<p>CNNs transform the original image layer by layer from the original
pixel values to the final class scores. 
</p>

<p>Observe that some layers contain
parameters and other don&#8217;t. In particular, the CNN layers perform
transformations that are a function of not only the activations in the
input volume, but also of the parameters (the weights and biases of
the neurons). On the other hand, the RELU/POOL layers will implement a
fixed function. The parameters in the CONV/FC layers will be trained
with gradient descent so that the class scores that the CNN computes
are consistent with the labels in the training set for each image.
</p>
</section>

<section>
<h2 id="cnns-in-brief">CNNs in brief </h2>

<p>In summary:</p>

<ul>
<p><li> A CNN architecture is in the simplest case a list of Layers that transform the image volume into an output volume (e.g. holding the class scores)</li>
<p><li> There are a few distinct types of Layers (e.g. CONV/FC/RELU/POOL are by far the most popular)</li>
<p><li> Each Layer accepts an input 3D volume and transforms it to an output 3D volume through a differentiable function</li>
<p><li> Each Layer may or may not have parameters (e.g. CONV/FC do, RELU/POOL don&#8217;t)</li>
<p><li> Each Layer may or may not have additional hyperparameters (e.g. CONV/FC/POOL do, RELU doesn&#8217;t)</li>
</ul>
<p>
<p>For more material on convolutional networks, we strongly recommend
the course
<a href="https://www.uio.no/studier/emner/matnat/ifi/IN5400/index-eng.html" target="_blank">IN5400 &#8211; Machine Learning for Image Analysis</a>
and the slides of <a href="http://cs231n.github.io/convolutional-networks/" target="_blank">CS231</a> which is taught at Stanford University (consistently ranked as one of the top computer science programs in the world). <a href="http://neuralnetworksanddeeplearning.com/chap6.html" target="_blank">Michael Nielsen's book is a must read, in particular chapter 6 which deals with CNNs</a>.
</p>

<p>The textbook by Goodfellow et al, see chapter 9 contains an in depth discussion as well.</p>
</section>

<section>
<h2 id="key-idea">Key Idea </h2>

<p>A dense neural network is representd by an affine operation (like matrix-matrix multiplication) where all parameters are included.</p>

<p>The key idea in CNNs for say imaging is that in images neighbor pixels tend to be related! So we connect
only neighboring neurons in the input instead of connecting all with the first hidden layer.
</p>

<p>We say we perform a filtering (convolution is the mathematical operation). </p>
</section>

<section>
<h2 id="mathematics-of-cnns">Mathematics of CNNs </h2>

<p>The mathematics of CNNs is based on the mathematical operation of
<b>convolution</b>.  In mathematics (in particular in functional analysis),
convolution is represented by mathematical operation (integration,
summation etc) on two function in order to produce a third function
that expresses how the shape of one gets modified by the other.
Convolution has a plethora of applications in a variety of disciplines, spanning from statistics to signal processing, computer vision, solutions of differential equations,linear algebra, engineering,  and yes, machine learning.
</p>

<p>Mathematically, convolution is defined as follows (one-dimensional example):
Let us define a continuous function \( y(t) \) given by
</p>
<p>&nbsp;<br>
$$
y(t) = \int x(a) w(t-a) da,
$$
<p>&nbsp;<br>

<p>where \( x(a) \) represents a so-called input and \( w(t-a) \) is normally called the weight function or kernel.</p>

<p>The above integral is written in  a more compact form as</p>
<p>&nbsp;<br>
$$
y(t) = \left(x * w\right)(t).
$$
<p>&nbsp;<br>

<p>The discretized version reads</p>
<p>&nbsp;<br>
$$
y(t) = \sum_{a=-\infty}^{a=\infty}x(a)w(t-a).
$$
<p>&nbsp;<br>

<p>Computing the inverse of the above convolution operations is known as deconvolution.</p>

<p>How can we use this? And what does it mean? Let us study some familiar examples first.</p>
</section>

<section>
<h2 id="convolution-examples-polynomial-multiplication">Convolution Examples: Polynomial multiplication </h2>

<p>We have already met such an example in project 1 when we tried to set
up the design matrix for a two-dimensional function. This was an
example of polynomial multiplication.  Let us recast such a problem in terms of the convolution operation.
Let us look a the following polynomials to second and third order, respectively:
</p>
<p>&nbsp;<br>
$$
p(t) = \alpha_0+\alpha_1 t+\alpha_2 t^2,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
s(t) = \beta_0+\beta_1 t+\beta_2 t^2+\beta_3 t^3.
$$
<p>&nbsp;<br>

<p>The polynomial multiplication gives us a new polynomial of degree \( 5 \)</p>
<p>&nbsp;<br>
$$
z(t) = \delta_0+\delta_1 t+\delta_2 t^2+\delta_3 t^3+\delta_4 t^4+\delta_5 t^5.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="efficient-polynomial-multiplication">Efficient Polynomial Multiplication </h2>

<p>Computing polynomial products can be implemented efficiently if we rewrite the more brute force multiplications using convolution.
We note first that the new coefficients are given as
</p>

<p>&nbsp;<br>
$$
\begin{split}
\delta_0=&\alpha_0\beta_0\\
\delta_1=&\alpha_1\beta_0+\alpha_1\beta_0\\
\delta_2=&\alpha_0\beta_2+\alpha_1\beta_1+\alpha_2\beta_0\\
\delta_3=&\alpha_1\beta_2+\alpha_2\beta_1+\alpha_0\beta_3\\
\delta_4=&\alpha_2\beta_2+\alpha_1\beta_3\\
\delta_5=&\alpha_2\beta_3.\\
\end{split}
$$
<p>&nbsp;<br>

<p>We note that \( \alpha_i=0 \) except for \( i\in \left\{0,1,2\right\} \) and \( \beta_i=0 \) except for \( i\in\left\{0,1,2,3\right\} \).</p>

<p>We can then rewrite the coefficients \( \delta_j \) using a discrete convolution as</p>
<p>&nbsp;<br>
$$
\delta_j = \sum_{i=-\infty}^{i=\infty}\alpha_i\beta_{j-i}=(\alpha * \beta)_j,
$$
<p>&nbsp;<br>

<p>or as a double sum with restriction \( l=i+j \)</p>
<p>&nbsp;<br>
$$
\delta_l = \sum_{ij}\alpha_i\beta_{j}.
$$
<p>&nbsp;<br>

<p>Do you see a potential drawback with these equations?</p>
</section>

<section>
<h2 id="a-more-efficient-way-of-coding-the-above-convolution">A more efficient way of coding the above Convolution </h2>

<p>Since we only have a finite number of \( \alpha \) and \( \beta \) values
which are non-zero, we can rewrite the above convolution expressions
as a matrix-vector multiplication
</p>

<p>&nbsp;<br>
$$
\boldsymbol{\delta}=\begin{bmatrix}\alpha_0 & 0 & 0 & 0 \\
                            \alpha_1 & \alpha_0 & 0 & 0 \\
			    \alpha_2 & \alpha_1 & \alpha_0 & 0 \\
			    0 & \alpha_2 & \alpha_1 & \alpha_0 \\
			    0 & 0 & \alpha_2 & \alpha_1 \\
			    0 & 0 & 0 & \alpha_2
			    \end{bmatrix}\begin{bmatrix} \beta_0 \\ \beta_1 \\ \beta_2 \\ \beta_3\end{bmatrix}.
$$
<p>&nbsp;<br>

<p>The process is commutative and we can easily see that we can rewrite the multiplication in terms of  a matrix holding \( \beta \) and a vector holding \( \alpha \).
In this case we have
</p>
<p>&nbsp;<br>
$$
\boldsymbol{\delta}=\begin{bmatrix}\beta_0 & 0 & 0  \\
                            \beta_1 & \beta_0 & 0  \\
			    \beta_2 & \beta_1 & \beta_0  \\
			    \beta_3 & \beta_2 & \beta_1 \\
			    0 & \beta_3 & \beta_2 \\
			    0 & 0 & \beta_3
			    \end{bmatrix}\begin{bmatrix} \alpha_0 \\ \alpha_1 \\ \alpha_2\end{bmatrix}.
$$
<p>&nbsp;<br>

<p>Note that the use of these  matrices is for mathematical purposes only  and not implementation purposes.
When implementing the above equation we do not encode (and allocate memory) the matrices explicitely.
We rather code the convolutions in the minimal memory footprint that they require.
</p>

<p>Does the number of floating point operations change here when we use the commutative property?</p>
</section>

<section>
<h2 id="convolution-examples-principle-of-superposition-and-periodic-forces-fourier-transforms">Convolution Examples: Principle of Superposition and Periodic Forces (Fourier Transforms) </h2>

<p>For problems with so-called harmonic oscillations, given by for example the following differential equation</p>
<p>&nbsp;<br>
$$
m\frac{d^2x}{dt^2}+\eta\frac{dx}{dt}+x(t)=F(t),
$$
<p>&nbsp;<br>

<p>where \( F(t) \) is an applied external force acting on the system (often called a driving force), one can use the theory of Fourier transformations to find the solutions of this type of equations.</p>

<p>If one has several driving forces, \( F(t)=\sum_n F_n(t) \), one can find
the particular solution to each \( F_n \), \( x_{pn}(t) \), and the particular
solution for the entire driving force is then given by a series like
</p>

<p>&nbsp;<br>
$$
\begin{equation}
x_p(t)=\sum_nx_{pn}(t).
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="principle-of-superposition">Principle of Superposition </h2>

<p>This is known as the principle of superposition. It only applies when
the homogenous equation is linear. If there were an anharmonic term
such as \( x^3 \) in the homogenous equation, then when one summed various
solutions, \( x=(\sum_n x_n)^2 \), one would get cross
terms. Superposition is especially useful when \( F(t) \) can be written
as a sum of sinusoidal terms, because the solutions for each
sinusoidal (sine or cosine)  term is analytic. 
</p>

<p>Driving forces are often periodic, even when they are not
sinusoidal. Periodicity implies that for some time \( \tau \)
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
F(t+\tau)=F(t). 
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>One example of a non-sinusoidal periodic force is a square wave. Many
components in electric circuits are non-linear, e.g. diodes, which
makes many wave forms non-sinusoidal even when the circuits are being
driven by purely sinusoidal sources.
</p>
</section>

<section>
<h2 id="simple-code-example">Simple Code Example </h2>

<p>The code here shows a typical example of such a square wave generated using the functionality included in the <b>scipy</b> Python package. We have used a period of \( \tau=0.2 \).</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy</span> <span style="color: #8B008B; font-weight: bold">import</span> signal
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #228B22"># number of points                                                                                       </span>
n = <span style="color: #B452CD">500</span>
<span style="color: #228B22"># start and final times                                                                                  </span>
t0 = <span style="color: #B452CD">0.0</span>
tn = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Period                                                                                                 </span>
t = np.linspace(t0, tn, n, endpoint=<span style="color: #8B008B; font-weight: bold">False</span>)
SqrSignal = np.zeros(n)
SqrSignal = <span style="color: #B452CD">1.0</span>+signal.square(<span style="color: #B452CD">2</span>*np.pi*<span style="color: #B452CD">5</span>*t)
plt.plot(t, SqrSignal)
plt.ylim(-<span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">2.5</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>For the sinusoidal example the
period is \( \tau=2\pi/\omega \). However, higher harmonics can also
satisfy the periodicity requirement. In general, any force that
satisfies the periodicity requirement can be expressed as a sum over
harmonics,
</p>

<p>&nbsp;<br>
$$
\begin{equation}
F(t)=\frac{f_0}{2}+\sum_{n>0} f_n\cos(2n\pi t/\tau)+g_n\sin(2n\pi t/\tau).
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="wrapping-up-fourier-transforms">Wrapping up Fourier transforms </h2>

<p>We can write down the answer for
\( x_{pn}(t) \), by substituting \( f_n/m \) or \( g_n/m \) for \( F_0/m \). By
writing each factor \( 2n\pi t/\tau \) as \( n\omega t \), with \( \omega\equiv
2\pi/\tau \),
</p>

<p>&nbsp;<br>
$$
\begin{equation}
\tag{3}
F(t)=\frac{f_0}{2}+\sum_{n>0}f_n\cos(n\omega t)+g_n\sin(n\omega t).
\end{equation}
$$
<p>&nbsp;<br>

<p>The solutions for \( x(t) \) then come from replacing \( \omega \) with
\( n\omega \) for each term in the particular solution,
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
x_p(t)&=&\frac{f_0}{2k}+\sum_{n>0} \alpha_n\cos(n\omega t-\delta_n)+\beta_n\sin(n\omega t-\delta_n),\\
\nonumber
\alpha_n&=&\frac{f_n/m}{\sqrt{((n\omega)^2-\omega_0^2)+4\beta^2n^2\omega^2}},\\
\nonumber
\beta_n&=&\frac{g_n/m}{\sqrt{((n\omega)^2-\omega_0^2)+4\beta^2n^2\omega^2}},\\
\nonumber
\delta_n&=&\tan^{-1}\left(\frac{2\beta n\omega}{\omega_0^2-n^2\omega^2}\right).
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="finding-the-coefficients">Finding the Coefficients </h2>

<p>Because the forces have been applied for a long time, any non-zero
damping eliminates the homogenous parts of the solution, so one need
only consider the particular solution for each \( n \).
</p>

<p>The problem is considered solved if one can find expressions for the
coefficients \( f_n \) and \( g_n \), even though the solutions are expressed
as an infinite sum. The coefficients can be extracted from the
function \( F(t) \) by
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{4}
f_n&=&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~F(t)\cos(2n\pi t/\tau),\\
\nonumber
g_n&=&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~F(t)\sin(2n\pi t/\tau).
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>To check the consistency of these expressions and to verify
Eq. <a href="#mjx-eqn-4">(4)</a>, one can insert the expansion of \( F(t) \) in
Eq. <a href="#mjx-eqn-3">(3)</a> into the expression for the coefficients in
Eq. <a href="#mjx-eqn-4">(4)</a> and see whether
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
f_n&=?&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~\left\{
\frac{f_0}{2}+\sum_{m>0}f_m\cos(m\omega t)+g_m\sin(m\omega t)
\right\}\cos(n\omega t).
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>Immediately, one can throw away all the terms with \( g_m \) because they
convolute an even and an odd function. The term with \( f_0/2 \)
disappears because \( \cos(n\omega t) \) is equally positive and negative
over the interval and will integrate to zero. For all the terms
\( f_m\cos(m\omega t) \) appearing in the sum, one can use angle addition
formulas to see that \( \cos(m\omega t)\cos(n\omega
t)=(1/2)(\cos[(m+n)\omega t]+\cos[(m-n)\omega t] \). This will integrate
to zero unless \( m=n \). In that case the \( m=n \) term gives
</p>

<p>&nbsp;<br>
$$
\begin{equation}
\int_{-\tau/2}^{\tau/2}dt~\cos^2(m\omega t)=\frac{\tau}{2},
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>

<p>and</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
f_n&=?&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~f_n/2\\
\nonumber
&=&f_n~\checkmark.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>The same method can be used to check for the consistency of \( g_n \).</p>
</section>

<section>
<h2 id="final-words-on-fourier-transforms">Final words on Fourier Transforms </h2>

<p>The code here uses the Fourier series applied to a 
square wave signal. The code here
visualizes the various approximations given by Fourier series compared
with a square wave with period \( T=0.2 \) (dimensionless time), width \( 0.1 \) and max value of the force \( F=2 \). We
see that when we increase the number of components in the Fourier
series, the Fourier series approximation gets closer and closer to the
square wave signal.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy</span> <span style="color: #8B008B; font-weight: bold">import</span> signal
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #228B22"># number of points                                                                                       </span>
n = <span style="color: #B452CD">500</span>
<span style="color: #228B22"># start and final times                                                                                  </span>
t0 = <span style="color: #B452CD">0.0</span>
tn = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Period                                                                                                 </span>
T =<span style="color: #B452CD">0.2</span>
<span style="color: #228B22"># Max value of square signal                                                                             </span>
Fmax= <span style="color: #B452CD">2.0</span>
<span style="color: #228B22"># Width of signal   </span>
Width = <span style="color: #B452CD">0.1</span>
t = np.linspace(t0, tn, n, endpoint=<span style="color: #8B008B; font-weight: bold">False</span>)
SqrSignal = np.zeros(n)
FourierSeriesSignal = np.zeros(n)
SqrSignal = <span style="color: #B452CD">1.0</span>+signal.square(<span style="color: #B452CD">2</span>*np.pi*<span style="color: #B452CD">5</span>*t+np.pi*Width/T)
a0 = Fmax*Width/T
FourierSeriesSignal = a0
Factor = <span style="color: #B452CD">2.0</span>*Fmax/np.pi
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,<span style="color: #B452CD">500</span>):
    FourierSeriesSignal += Factor/(i)*np.sin(np.pi*i*Width/T)*np.cos(i*t*<span style="color: #B452CD">2</span>*np.pi/T)
plt.plot(t, SqrSignal)
plt.plot(t, FourierSeriesSignal)
plt.ylim(-<span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">2.5</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="two-dimensional-objects">Two-dimensional Objects </h2>

<p>We often use convolutions over more than one dimension at a time. If
we have a two-dimensional image \( I \) as input, we can have a <b>filter</b>
defined by a two-dimensional <b>kernel</b> \( K \). This leads to an output \( S \)
</p>

<p>&nbsp;<br>
$$
S_(i,j)=(I * K)(i,j) = \sum_m\sum_n I(m,n)K(i-m,j-n).
$$
<p>&nbsp;<br>

<p>Convolution is a commutatitave process, which means we can rewrite this equation as</p>
<p>&nbsp;<br>
$$
S_(i,j)=(I * K)(i,j) = \sum_m\sum_n I(i-m,j-n)K(m,n).
$$
<p>&nbsp;<br>

<p>Normally the latter is more straightforward to implement in  a machine elarning library since there is less variation in the range of values of \( m \) and \( n \).</p>
</section>

<section>
<h2 id="cross-correlation">Cross-Correlation </h2>

<p>Many deep learning libraries implement cross-correlation instead of convolution</p>
<p>&nbsp;<br>
$$
S_(i,j)=(I * K)(i,j) = \sum_m\sum_n I(i+m,j-+)K(m,n).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="more-on-dimensionalities">More on Dimensionalities </h2>

<p>In feilds like signal processing (and imaging as well), one designs
so-called filters. These filters are defined by the convolutions and
are often hand-crafted. One may specify filters for smoothing, edge
detection, frequency reshaping, and similar operations. However with
neural networks the idea is to automatically learn the filters and use
many of them in conjunction with non-linear operations (activation
functions).
</p>

<p>As an example consider a neural network operating on sound sequence
data.  Assume that we an input vector \( \boldsymbol{x} \) of length \( d=10^6 \).  We
construct then a neural network with onle hidden layer only with
\( 10^4 \) nodes. This means that we will have a weight matrix with
\( 10^4\times 10^6=10^{10} \) weights to be determined, together with \( 10^4 \) biases.
</p>

<p>Assume furthermore that we have an output layer which is meant to train whether the sound sequence represents a human voice (true) or something else (false).
It means that we have only one output node. But since this output node connects to \( 10^4 \) nodes in the hidden layer, there are in total \( 10^4 \) weights to be determined for the output layer, plus one bias. In total we have
</p>

<p>&nbsp;<br>
$$
\mathrm{NumberParameters}=10^{10}+10^4+10^4+1 \approx 10^{10},
$$
<p>&nbsp;<br>

<p>that is ten billion parameters to determine. </p>
</section>

<section>
<h2 id="further-dimensionality-remarks">Further Dimensionality Remarks </h2>

<p>In today&#8217;s architecture one can train such neural networks, however
this is a huge number of parameters for the task at hand. In general,
it is a very wasteful and inefficient use of dense matrices as
parameters. Just as importantly, such trained network parameters are
very specific for the type of input data on which they were trained
and the network is not likely to generalize easily to variations in
the input.
</p>

<p>The main principles that justify convolutions is locality of
information and repetion of patterns within the signal. Sound samples
of the input in adjacent spots are much more likely to affect each
other than those that are very far away. Similarly, sounds are
repeated in multiple times in the signal. While slightly simplistic,
reasoning about such a sound example demonstrates this. The same
principles then apply to images and other similar data.
</p>
</section>

<section>
<h2 id="cnns-in-more-detail-lecture-from-in5400">CNNs in more detail, Lecture from IN5400 </h2>

<ul>
<p><li> <a href="https://www.uio.no/studier/emner/matnat/ifi/IN5400/v19/material/week5/in5400_2019_week5_convolutional_nerual_networks.pdf" target="_blank">Lectures from IN5400 spring 2019</a></li>
</ul>
</section>

<section>
<h2 id="cnns-in-more-detail-building-convolutional-neural-networks-in-tensorflow-and-keras">CNNs in more detail, building convolutional neural networks in Tensorflow and Keras </h2>

<p>As discussed above, CNNs are neural networks built from the assumption that the inputs
to the network are 2D images. This is important because the number of features or pixels in images
grows very fast with the image size, and an enormous number of weights and biases are needed in order to build an accurate network.  
</p>

<p>As before, we still have our input, a hidden layer and an output. What's novel about convolutional networks
are the <b>convolutional</b> and <b>pooling</b> layers stacked in pairs between the input and the hidden layer.
In addition, the data is no longer represented as a 2D feature matrix, instead each input is a number of 2D
matrices, typically 1 for each color dimension (Red, Green, Blue). 
</p>
</section>

<section>
<h2 id="setting-it-up">Setting it up </h2>

<p>It means that to represent the entire
dataset of images, we require a 4D matrix or <b>tensor</b>. This tensor has the dimensions:  
</p>
<p>&nbsp;<br>
$$  
(n_{inputs},\, n_{pixels, width},\, n_{pixels, height},\, depth) .
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="the-mnist-dataset-again">The MNIST dataset again </h2>

<p>The MNIST dataset consists of grayscale images with a pixel size of
\( 28\times 28 \), meaning we require \( 28 \times 28 = 724 \) weights to each
neuron in the first hidden layer.
</p>

<p>If we were to analyze images of size \( 128\times 128 \) we would require
\( 128 \times 128 = 16384 \) weights to each neuron. Even worse if we were
dealing with color images, as most images are, we have an image matrix
of size \( 128\times 128 \) for each color dimension (Red, Green, Blue),
meaning 3 times the number of weights \( = 49152 \) are required for every
single neuron in the first hidden layer.
</p>
</section>

<section>
<h2 id="strong-correlations">Strong correlations </h2>

<p>Images typically have strong local correlations, meaning that a small
part of the image varies little from its neighboring regions. If for
example we have an image of a blue car, we can roughly assume that a
small blue part of the image is surrounded by other blue regions.
</p>

<p>Therefore, instead of connecting every single pixel to a neuron in the
first hidden layer, as we have previously done with deep neural
networks, we can instead connect each neuron to a small part of the
image (in all 3 RGB depth dimensions).  The size of each small area is
fixed, and known as a <a href="https://en.wikipedia.org/wiki/Receptive_field" target="_blank">receptive</a>.
</p>
</section>

<section>
<h2 id="layers-of-a-cnn">Layers of a CNN </h2>
<p>The layers of a convolutional neural network arrange neurons in 3D: width, height and depth.  
The input image is typically a square matrix of depth 3. 
</p>

<p>A <b>convolution</b> is performed on the image which outputs
a 3D volume of neurons. The weights to the input are arranged in a number of 2D matrices, known as <b>filters</b>.
</p>

<p>Each filter slides along the input image, taking the dot product
between each small part of the image and the filter, in all depth
dimensions. This is then passed through a non-linear function,
typically the <b>Rectified Linear (ReLu)</b> function, which serves as the
activation of the neurons in the first convolutional layer. This is
further passed through a <b>pooling layer</b>, which reduces the size of the
convolutional layer, e.g. by taking the maximum or average across some
small regions, and this serves as input to the next convolutional
layer.
</p>
</section>

<section>
<h2 id="systematic-reduction">Systematic reduction </h2>

<p>By systematically reducing the size of the input volume, through
convolution and pooling, the network should create representations of
small parts of the input, and then from them assemble representations
of larger areas.  The final pooling layer is flattened to serve as
input to a hidden layer, such that each neuron in the final pooling
layer is connected to every single neuron in the hidden layer. This
then serves as input to the output layer, e.g. a softmax output for
classification.
</p>
</section>

<section>
<h2 id="prerequisites-collect-and-pre-process-data">Prerequisites: Collect and pre-process data </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># import necessary packages</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn</span> <span style="color: #8B008B; font-weight: bold">import</span> datasets


<span style="color: #228B22"># ensure the same random numbers appear every time</span>
np.random.seed(<span style="color: #B452CD">0</span>)

<span style="color: #228B22"># display images in notebook</span>
%matplotlib inline
plt.rcParams[<span style="color: #CD5555">&#39;figure.figsize&#39;</span>] = (<span style="color: #B452CD">12</span>,<span style="color: #B452CD">12</span>)


<span style="color: #228B22"># download MNIST dataset</span>
digits = datasets.load_digits()

<span style="color: #228B22"># define inputs and labels</span>
inputs = digits.images
labels = digits.target

<span style="color: #228B22"># RGB images have a depth of 3</span>
<span style="color: #228B22"># our images are grayscale so they should have a depth of 1</span>
inputs = inputs[:,:,:,np.newaxis]

<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;inputs = (n_inputs, pixel_width, pixel_height, depth) = &quot;</span> + <span style="color: #658b00">str</span>(inputs.shape))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;labels = (n_inputs) = &quot;</span> + <span style="color: #658b00">str</span>(labels.shape))


<span style="color: #228B22"># choose some random images to display</span>
n_inputs = <span style="color: #658b00">len</span>(inputs)
indices = np.arange(n_inputs)
random_indices = np.random.choice(indices, size=<span style="color: #B452CD">5</span>)

<span style="color: #8B008B; font-weight: bold">for</span> i, image <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(digits.images[random_indices]):
    plt.subplot(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">5</span>, i+<span style="color: #B452CD">1</span>)
    plt.axis(<span style="color: #CD5555">&#39;off&#39;</span>)
    plt.imshow(image, cmap=plt.cm.gray_r, interpolation=<span style="color: #CD5555">&#39;nearest&#39;</span>)
    plt.title(<span style="color: #CD5555">&quot;Label: %d&quot;</span> % digits.target[random_indices[i]])
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="importing-keras-and-tensorflow">Importing Keras and Tensorflow </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> datasets, layers, models
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.layers</span> <span style="color: #8B008B; font-weight: bold">import</span> Input
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.models</span> <span style="color: #8B008B; font-weight: bold">import</span> Sequential      <span style="color: #228B22">#This allows appending layers to existing models</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.layers</span> <span style="color: #8B008B; font-weight: bold">import</span> Dense           <span style="color: #228B22">#This allows defining the characteristics of a particular layer</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> optimizers             <span style="color: #228B22">#This allows using whichever optimiser we want (sgd,adam,RMSprop)</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> regularizers           <span style="color: #228B22">#This allows using whichever regularizer we want (l1,l2,l1_l2)</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> to_categorical   <span style="color: #228B22">#This allows using categorical cross entropy as the cost function</span>
<span style="color: #228B22">#from tensorflow.keras import Conv2D</span>
<span style="color: #228B22">#from tensorflow.keras import MaxPooling2D</span>
<span style="color: #228B22">#from tensorflow.keras import Flatten</span>

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split

<span style="color: #228B22"># representation of labels</span>
labels = to_categorical(labels)

<span style="color: #228B22"># split into train and test data</span>
<span style="color: #228B22"># one-liner from scikit-learn library</span>
train_size = <span style="color: #B452CD">0.8</span>
test_size = <span style="color: #B452CD">1</span> - train_size
X_train, X_test, Y_train, Y_test = train_test_split(inputs, labels, train_size=train_size,
                                                    test_size=test_size)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="running-with-keras">Running with Keras </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">create_convolutional_neural_network_keras</span>(input_shape, receptive_field,
                                              n_filters, n_neurons_connected, n_categories,
                                              eta, lmbd):
    model = Sequential()
    model.add(layers.Conv2D(n_filters, (receptive_field, receptive_field), input_shape=input_shape, padding=<span style="color: #CD5555">&#39;same&#39;</span>,
              activation=<span style="color: #CD5555">&#39;relu&#39;</span>, kernel_regularizer=regularizers.l2(lmbd)))
    model.add(layers.MaxPooling2D(pool_size=(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>)))
    model.add(layers.Flatten())
    model.add(layers.Dense(n_neurons_connected, activation=<span style="color: #CD5555">&#39;relu&#39;</span>, kernel_regularizer=regularizers.l2(lmbd)))
    model.add(layers.Dense(n_categories, activation=<span style="color: #CD5555">&#39;softmax&#39;</span>, kernel_regularizer=regularizers.l2(lmbd)))
    
    sgd = optimizers.SGD(lr=eta)
    model.compile(loss=<span style="color: #CD5555">&#39;categorical_crossentropy&#39;</span>, optimizer=sgd, metrics=[<span style="color: #CD5555">&#39;accuracy&#39;</span>])
    
    <span style="color: #8B008B; font-weight: bold">return</span> model

epochs = <span style="color: #B452CD">100</span>
batch_size = <span style="color: #B452CD">100</span>
input_shape = X_train.shape[<span style="color: #B452CD">1</span>:<span style="color: #B452CD">4</span>]
receptive_field = <span style="color: #B452CD">3</span>
n_filters = <span style="color: #B452CD">10</span>
n_neurons_connected = <span style="color: #B452CD">50</span>
n_categories = <span style="color: #B452CD">10</span>

eta_vals = np.logspace(-<span style="color: #B452CD">5</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">7</span>)
lmbd_vals = np.logspace(-<span style="color: #B452CD">5</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">7</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="final-part">Final part </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">CNN_keras = np.zeros((<span style="color: #658b00">len</span>(eta_vals), <span style="color: #658b00">len</span>(lmbd_vals)), dtype=<span style="color: #658b00">object</span>)
        
<span style="color: #8B008B; font-weight: bold">for</span> i, eta <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(eta_vals):
    <span style="color: #8B008B; font-weight: bold">for</span> j, lmbd <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(lmbd_vals):
        CNN = create_convolutional_neural_network_keras(input_shape, receptive_field,
                                              n_filters, n_neurons_connected, n_categories,
                                              eta, lmbd)
        CNN.fit(X_train, Y_train, epochs=epochs, batch_size=batch_size, verbose=<span style="color: #B452CD">0</span>)
        scores = CNN.evaluate(X_test, Y_test)
        
        CNN_keras[i][j] = CNN
        
        <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Learning rate = &quot;</span>, eta)
        <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Lambda = &quot;</span>, lmbd)
        <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Test accuracy: %.3f&quot;</span> % scores[<span style="color: #B452CD">1</span>])
        <span style="color: #658b00">print</span>()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="final-visualization">Final visualization </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># visual representation of grid search</span>
<span style="color: #228B22"># uses seaborn heatmap, could probably do this in matplotlib</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">seaborn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sns</span>

sns.set()

train_accuracy = np.zeros((<span style="color: #658b00">len</span>(eta_vals), <span style="color: #658b00">len</span>(lmbd_vals)))
test_accuracy = np.zeros((<span style="color: #658b00">len</span>(eta_vals), <span style="color: #658b00">len</span>(lmbd_vals)))

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(eta_vals)):
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(lmbd_vals)):
        CNN = CNN_keras[i][j]

        train_accuracy[i][j] = CNN.evaluate(X_train, Y_train)[<span style="color: #B452CD">1</span>]
        test_accuracy[i][j] = CNN.evaluate(X_test, Y_test)[<span style="color: #B452CD">1</span>]

        
fig, ax = plt.subplots(figsize = (<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))
sns.heatmap(train_accuracy, annot=<span style="color: #8B008B; font-weight: bold">True</span>, ax=ax, cmap=<span style="color: #CD5555">&quot;viridis&quot;</span>)
ax.set_title(<span style="color: #CD5555">&quot;Training Accuracy&quot;</span>)
ax.set_ylabel(<span style="color: #CD5555">&quot;$\eta$&quot;</span>)
ax.set_xlabel(<span style="color: #CD5555">&quot;$\lambda$&quot;</span>)
plt.show()

fig, ax = plt.subplots(figsize = (<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))
sns.heatmap(test_accuracy, annot=<span style="color: #8B008B; font-weight: bold">True</span>, ax=ax, cmap=<span style="color: #CD5555">&quot;viridis&quot;</span>)
ax.set_title(<span style="color: #CD5555">&quot;Test Accuracy&quot;</span>)
ax.set_ylabel(<span style="color: #CD5555">&quot;$\eta$&quot;</span>)
ax.set_xlabel(<span style="color: #CD5555">&quot;$\lambda$&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="the-cifar01-data-set">The CIFAR01 data set </h2>

<p>The CIFAR10 dataset contains 60,000 color images in 10 classes, with
6,000 images in each class. The dataset is divided into 50,000
training images and 10,000 testing images. The classes are mutually
exclusive and there is no overlap between them.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">tensorflow</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">tf</span>

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> datasets, layers, models
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #228B22"># We import the data set</span>
(train_images, train_labels), (test_images, test_labels) = datasets.cifar10.load_data()

<span style="color: #228B22"># Normalize pixel values to be between 0 and 1 by dividing by 255. </span>
train_images, test_images = train_images / <span style="color: #B452CD">255.0</span>, test_images / <span style="color: #B452CD">255.0</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="verifying-the-data-set">Verifying the data set </h2>

<p>To verify that the dataset looks correct, let's plot the first 25 images from the training set and display the class name below each image.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">class_names = [<span style="color: #CD5555">&#39;airplane&#39;</span>, <span style="color: #CD5555">&#39;automobile&#39;</span>, <span style="color: #CD5555">&#39;bird&#39;</span>, <span style="color: #CD5555">&#39;cat&#39;</span>, <span style="color: #CD5555">&#39;deer&#39;</span>,
               <span style="color: #CD5555">&#39;dog&#39;</span>, <span style="color: #CD5555">&#39;frog&#39;</span>, <span style="color: #CD5555">&#39;horse&#39;</span>, <span style="color: #CD5555">&#39;ship&#39;</span>, <span style="color: #CD5555">&#39;truck&#39;</span>]
<span style="color: #a61717; background-color: #e3d2d2"></span>
plt.figure(figsize=(<span style="color: #B452CD">10</span>,<span style="color: #B452CD">10</span>))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">25</span>):
    plt.subplot(<span style="color: #B452CD">5</span>,<span style="color: #B452CD">5</span>,i+<span style="color: #B452CD">1</span>)
    plt.xticks([])
    plt.yticks([])
    plt.grid(<span style="color: #8B008B; font-weight: bold">False</span>)
    plt.imshow(train_images[i], cmap=plt.cm.binary)
    <span style="color: #228B22"># The CIFAR labels happen to be arrays, </span>
    <span style="color: #228B22"># which is why you need the extra index</span>
    plt.xlabel(class_names[train_labels[i][<span style="color: #B452CD">0</span>]])
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="set-up-the-model">Set up  the model </h2>

<p>The 6 lines of code below define the convolutional base using a common pattern: a stack of Conv2D and MaxPooling2D layers.</p>

<p>As input, a CNN takes tensors of shape (image_height, image_width, color_channels), ignoring the batch size. If you are new to these dimensions, color_channels refers to (R,G,B). In this example, you will configure our CNN to process inputs of shape (32, 32, 3), which is the format of CIFAR images. You can do this by passing the argument input_shape to our first layer.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">model = models.Sequential()
model.add(layers.Conv2D(<span style="color: #B452CD">32</span>, (<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>), activation=<span style="color: #CD5555">&#39;relu&#39;</span>, input_shape=(<span style="color: #B452CD">32</span>, <span style="color: #B452CD">32</span>, <span style="color: #B452CD">3</span>)))
model.add(layers.MaxPooling2D((<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>)))
model.add(layers.Conv2D(<span style="color: #B452CD">64</span>, (<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>), activation=<span style="color: #CD5555">&#39;relu&#39;</span>))
model.add(layers.MaxPooling2D((<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>)))
model.add(layers.Conv2D(<span style="color: #B452CD">64</span>, (<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>), activation=<span style="color: #CD5555">&#39;relu&#39;</span>))

<span style="color: #228B22"># Let&#39;s display the architecture of our model so far.</span>

model.summary()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>You can see that the output of every Conv2D and MaxPooling2D layer is a 3D tensor of shape (height, width, channels). The width and height dimensions tend to shrink as you go deeper in the network. The number of output channels for each Conv2D layer is controlled by the first argument (e.g., 32 or 64). Typically, as the width and height shrink, you can afford (computationally) to add more output channels in each Conv2D layer.</p>
</section>

<section>
<h2 id="add-dense-layers-on-top">Add Dense layers on top </h2>

<p>To complete our model, you will feed the last output tensor from the
convolutional base (of shape (4, 4, 64)) into one or more Dense layers
to perform classification. Dense layers take vectors as input (which
are 1D), while the current output is a 3D tensor. First, you will
flatten (or unroll) the 3D output to 1D, then add one or more Dense
layers on top. CIFAR has 10 output classes, so you use a final Dense
layer with 10 outputs and a softmax activation.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">model.add(layers.Flatten())
model.add(layers.Dense(<span style="color: #B452CD">64</span>, activation=<span style="color: #CD5555">&#39;relu&#39;</span>))
model.add(layers.Dense(<span style="color: #B452CD">10</span>))
Here<span style="color: #CD5555">&#39;s the complete architecture of our model.</span>

model.summary()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>As you can see, our (4, 4, 64) outputs were flattened into vectors of shape (1024) before going through two Dense layers.</p>
</section>

<section>
<h2 id="compile-and-train-the-model">Compile and train the model </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">model.compile(optimizer=<span style="color: #CD5555">&#39;adam&#39;</span>,
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span style="color: #8B008B; font-weight: bold">True</span>),
              metrics=[<span style="color: #CD5555">&#39;accuracy&#39;</span>])
<span style="color: #a61717; background-color: #e3d2d2"></span>
history = model.fit(train_images, train_labels, epochs=<span style="color: #B452CD">10</span>, 
                    validation_data=(test_images, test_labels))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="finally-evaluate-the-model">Finally, evaluate the model </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">plt.plot(history.history[<span style="color: #CD5555">&#39;accuracy&#39;</span>], label=<span style="color: #CD5555">&#39;accuracy&#39;</span>)
plt.plot(history.history[<span style="color: #CD5555">&#39;val_accuracy&#39;</span>], label = <span style="color: #CD5555">&#39;val_accuracy&#39;</span>)
plt.xlabel(<span style="color: #CD5555">&#39;Epoch&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;Accuracy&#39;</span>)
plt.ylim([<span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>])
plt.legend(loc=<span style="color: #CD5555">&#39;lower right&#39;</span>)

test_loss, test_acc = model.evaluate(test_images,  test_labels, verbose=<span style="color: #B452CD">2</span>)

<span style="color: #658b00">print</span>(test_acc)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="recurrent-neural-networks-overarching-view">Recurrent neural networks: Overarching view </h2>

<p>Till now our focus has been, including convolutional neural networks
as well, on feedforward neural networks. The output or the activations
flow only in one direction, from the input layer to the output layer.
</p>

<p>A recurrent neural network (RNN) looks very much like a feedforward
neural network, except that it also has connections pointing
backward. 
</p>

<p>RNNs are used to analyze time series data such as stock prices, and
tell you when to buy or sell. In autonomous driving systems, they can
anticipate car trajectories and help avoid accidents. More generally,
they can work on sequences of arbitrary lengths, rather than on
fixed-sized inputs like all the nets we have discussed so far. For
example, they can take sentences, documents, or audio samples as
input, making them extremely useful for natural language processing
systems such as automatic translation and speech-to-text.
</p>
</section>

<section>
<h2 id="set-up-of-an-rnn">Set up of an RNN </h2>

<p>See handwritten notes for week 43 and <a href="http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture10.pdf" target="_blank">Lectures from CS231 at Stanford</a></p>
</section>

<section>
<h2 id="a-simple-example">A simple example </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Start importing packages</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">tensorflow</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">tf</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> datasets, layers, models
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.layers</span> <span style="color: #8B008B; font-weight: bold">import</span> Input
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.models</span> <span style="color: #8B008B; font-weight: bold">import</span> Model, Sequential 
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.layers</span> <span style="color: #8B008B; font-weight: bold">import</span> Dense, SimpleRNN, LSTM, GRU
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> optimizers     
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> regularizers           
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> to_categorical 



<span style="color: #228B22"># convert into dataset matrix</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">convertToMatrix</span>(data, step):
 X, Y =[], []
 <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(data)-step):
  d=i+step  
  X.append(data[i:d,])
  Y.append(data[d,])
 <span style="color: #8B008B; font-weight: bold">return</span> np.array(X), np.array(Y)

step = <span style="color: #B452CD">4</span>
N = <span style="color: #B452CD">1000</span>    
Tp = <span style="color: #B452CD">800</span>    

t=np.arange(<span style="color: #B452CD">0</span>,N)
x=np.sin(<span style="color: #B452CD">0.02</span>*t)+<span style="color: #B452CD">2</span>*np.random.rand(N)
df = pd.DataFrame(x)
df.head()

plt.plot(df)
plt.show()

values=df.values
train,test = values[<span style="color: #B452CD">0</span>:Tp,:], values[Tp:N,:]

<span style="color: #228B22"># add step elements into train and test</span>
test = np.append(test,np.repeat(test[-<span style="color: #B452CD">1</span>,],step))
train = np.append(train,np.repeat(train[-<span style="color: #B452CD">1</span>,],step))
 
trainX,trainY =convertToMatrix(train,step)
testX,testY =convertToMatrix(test,step)
trainX = np.reshape(trainX, (trainX.shape[<span style="color: #B452CD">0</span>], <span style="color: #B452CD">1</span>, trainX.shape[<span style="color: #B452CD">1</span>]))
testX = np.reshape(testX, (testX.shape[<span style="color: #B452CD">0</span>], <span style="color: #B452CD">1</span>, testX.shape[<span style="color: #B452CD">1</span>]))

model = Sequential()
model.add(SimpleRNN(units=<span style="color: #B452CD">32</span>, input_shape=(<span style="color: #B452CD">1</span>,step), activation=<span style="color: #CD5555">&quot;relu&quot;</span>))
model.add(Dense(<span style="color: #B452CD">8</span>, activation=<span style="color: #CD5555">&quot;relu&quot;</span>)) 
model.add(Dense(<span style="color: #B452CD">1</span>))
model.compile(loss=<span style="color: #CD5555">&#39;mean_squared_error&#39;</span>, optimizer=<span style="color: #CD5555">&#39;rmsprop&#39;</span>)
model.summary()

model.fit(trainX,trainY, epochs=<span style="color: #B452CD">100</span>, batch_size=<span style="color: #B452CD">16</span>, verbose=<span style="color: #B452CD">2</span>)
trainPredict = model.predict(trainX)
testPredict= model.predict(testX)
predicted=np.concatenate((trainPredict,testPredict),axis=<span style="color: #B452CD">0</span>)

trainScore = model.evaluate(trainX, trainY, verbose=<span style="color: #B452CD">0</span>)
<span style="color: #658b00">print</span>(trainScore)

index = df.index.values
plt.plot(index,df)
plt.plot(index,predicted)
plt.axvline(df.index[Tp], c=<span style="color: #CD5555">&quot;r&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="an-extrapolation-example">An extrapolation example </h2>

<p>The following code provides an example of how recurrent neural
networks can be used to extrapolate to unknown values of physics data
sets.  Specifically, the data sets used in this program come from
a quantum mechanical many-body calculation of energies as functions of the number of particles.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># For matrices and calculations</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #228B22"># For machine learning (backend for keras)</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">tensorflow</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">tf</span>
<span style="color: #228B22"># User-friendly machine learning library</span>
<span style="color: #228B22"># Front end for TensorFlow</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span>
<span style="color: #228B22"># Different methods from Keras needed to create an RNN</span>
<span style="color: #228B22"># This is not necessary but it shortened function calls </span>
<span style="color: #228B22"># that need to be used in the code.</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> datasets, layers, models
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.layers</span> <span style="color: #8B008B; font-weight: bold">import</span> Input
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> regularizers
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.models</span> <span style="color: #8B008B; font-weight: bold">import</span> Model, Sequential
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.layers</span> <span style="color: #8B008B; font-weight: bold">import</span> Dense, SimpleRNN, LSTM, GRU
<span style="color: #228B22"># For timing the code</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">timeit</span> <span style="color: #8B008B; font-weight: bold">import</span> default_timer <span style="color: #8B008B; font-weight: bold">as</span> timer
<span style="color: #228B22"># For plotting</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>


<span style="color: #228B22"># The data set</span>
datatype=<span style="color: #CD5555">&#39;VaryDimension&#39;</span>
X_tot = np.arange(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">42</span>, <span style="color: #B452CD">2</span>)
y_tot = np.array([-<span style="color: #B452CD">0.03077640549</span>, -<span style="color: #B452CD">0.08336233266</span>, -<span style="color: #B452CD">0.1446729567</span>, -<span style="color: #B452CD">0.2116753732</span>, -<span style="color: #B452CD">0.2830637392</span>, -<span style="color: #B452CD">0.3581341341</span>, -<span style="color: #B452CD">0.436462435</span>, -<span style="color: #B452CD">0.5177783846</span>,
	-<span style="color: #B452CD">0.6019067271</span>, -<span style="color: #B452CD">0.6887363571</span>, -<span style="color: #B452CD">0.7782028952</span>, -<span style="color: #B452CD">0.8702784034</span>, -<span style="color: #B452CD">0.9649652536</span>, -<span style="color: #B452CD">1.062292565</span>, -<span style="color: #B452CD">1.16231451</span>, 
	-<span style="color: #B452CD">1.265109911</span>, -<span style="color: #B452CD">1.370782966</span>, -<span style="color: #B452CD">1.479465113</span>, -<span style="color: #B452CD">1.591317992</span>, -<span style="color: #B452CD">1.70653767</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="formatting-the-data">Formatting the Data </h2>

<p>The way the recurrent neural networks are trained in this program
differs from how machine learning algorithms are usually trained.
Typically a machine learning algorithm is trained by learning the
relationship between the x data and the y data.  In this program, the
recurrent neural network will be trained to recognize the relationship
in a sequence of y values.  This is type of data formatting is
typically used time series forcasting, but it can also be used in any
extrapolation (time series forecasting is just a specific type of
extrapolation along the time axis).  This method of data formatting
does not use the x data and assumes that the y data are evenly spaced.
</p>

<p>For a standard machine learning algorithm, the training data has the
form of (x,y) so the machine learning algorithm learns to assiciate a
y value with a given x value.  This is useful when the test data has x
values within the same range as the training data.  However, for this
application, the x values of the test data are outside of the x values
of the training data and the traditional method of training a machine
learning algorithm does not work as well.  For this reason, the
recurrent neural network is trained on sequences of y values of the
form ((y1, y2), y3), so that the network is concerned with learning
the pattern of the y data and not the relation between the x and y
data.  As long as the pattern of y data outside of the training region
stays relatively stable compared to what was inside the training
region, this method of training can produce accurate extrapolations to
y values far removed from the training data set.
</p>

<!--  -->
<!-- The idea behind formatting the data in this way comes from [this resource](https://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras/) and [this one](https://fairyonice.github.io/Understand-Keras%27s-RNN-behind-the-scenes-with-a-sin-wave-example.html). -->
<!--  -->
<!-- The following method takes in a y data set and formats it so the "x data" are of the form (y1, y2) and the "y data" are of the form y3, with extra brackets added in to make the resulting arrays compatable with both Keras and Tensorflow. -->
<!--  -->
<!-- Note: Using a sequence length of two is not required for time series forecasting so any lenght of sequence could be used (for example instead of ((y1, y2) y3) you could change the length of sequence to be 4 and the resulting data points would have the form ((y1, y2, y3, y4), y5)).  While the following method can be used to create a data set of any sequence length, the remainder of the code expects the length of sequence to be 2.  This is because the data sets are very small and the higher the lenght of the sequence the less resulting data points. -->


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># FORMAT_DATA</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">format_data</span>(data, length_of_sequence = <span style="color: #B452CD">2</span>):  
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Inputs:</span>
<span style="color: #CD5555">            data(a numpy array): the data that will be the inputs to the recurrent neural</span>
<span style="color: #CD5555">                network</span>
<span style="color: #CD5555">            length_of_sequence (an int): the number of elements in one iteration of the</span>
<span style="color: #CD5555">                sequence patter.  For a function approximator use length_of_sequence = 2.</span>
<span style="color: #CD5555">        Returns:</span>
<span style="color: #CD5555">            rnn_input (a 3D numpy array): the input data for the recurrent neural network.  Its</span>
<span style="color: #CD5555">                dimensions are length of data - length of sequence, length of sequence, </span>
<span style="color: #CD5555">                dimnsion of data</span>
<span style="color: #CD5555">            rnn_output (a numpy array): the training data for the neural network</span>
<span style="color: #CD5555">        Formats data to be used in a recurrent neural network.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>

    X, Y = [], []
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(data)-length_of_sequence):
        <span style="color: #228B22"># Get the next length_of_sequence elements</span>
        a = data[i:i+length_of_sequence]
        <span style="color: #228B22"># Get the element that immediately follows that</span>
        b = data[i+length_of_sequence]
        <span style="color: #228B22"># Reshape so that each data point is contained in its own array</span>
        a = np.reshape (a, (<span style="color: #658b00">len</span>(a), <span style="color: #B452CD">1</span>))
        X.append(a)
        Y.append(b)
    rnn_input = np.array(X)
    rnn_output = np.array(Y)

    <span style="color: #8B008B; font-weight: bold">return</span> rnn_input, rnn_output


<span style="color: #228B22"># ## Defining the Recurrent Neural Network Using Keras</span>
<span style="color: #228B22"># </span>
<span style="color: #228B22"># The following method defines a simple recurrent neural network in keras consisting of one input layer, one hidden layer, and one output layer.</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">rnn</span>(length_of_sequences, batch_size = <span style="color: #8B008B; font-weight: bold">None</span>, stateful = <span style="color: #8B008B; font-weight: bold">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Inputs:</span>
<span style="color: #CD5555">            length_of_sequences (an int): the number of y values in &quot;x data&quot;.  This is determined</span>
<span style="color: #CD5555">                when the data is formatted</span>
<span style="color: #CD5555">            batch_size (an int): Default value is None.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">            stateful (a boolean): Default value is False.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">        Returns:</span>
<span style="color: #CD5555">            model (a Keras model): The recurrent neural network that is built and compiled by this</span>
<span style="color: #CD5555">                method</span>
<span style="color: #CD5555">        Builds and compiles a recurrent neural network with one hidden layer and returns the model.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Number of neurons in the input and output layers</span>
    in_out_neurons = <span style="color: #B452CD">1</span>
    <span style="color: #228B22"># Number of neurons in the hidden layer</span>
    hidden_neurons = <span style="color: #B452CD">200</span>
    <span style="color: #228B22"># Define the input layer</span>
    inp = Input(batch_shape=(batch_size, 
                length_of_sequences, 
                in_out_neurons))  
    <span style="color: #228B22"># Define the hidden layer as a simple RNN layer with a set number of neurons and add it to </span>
    <span style="color: #228B22"># the network immediately after the input layer</span>
    rnn = SimpleRNN(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">False</span>,
                    stateful = stateful,
                    name=<span style="color: #CD5555">&quot;RNN&quot;</span>)(inp)
    <span style="color: #228B22"># Define the output layer as a dense neural network layer (standard neural network layer)</span>
    <span style="color: #228B22">#and add it to the network immediately after the hidden layer.</span>
    dens = Dense(in_out_neurons,name=<span style="color: #CD5555">&quot;dense&quot;</span>)(rnn)
    <span style="color: #228B22"># Create the machine learning model starting with the input layer and ending with the </span>
    <span style="color: #228B22"># output layer</span>
    model = Model(inputs=[inp],outputs=[dens])
    <span style="color: #228B22"># Compile the machine learning model using the mean squared error function as the loss </span>
    <span style="color: #228B22"># function and an Adams optimizer.</span>
    model.compile(loss=<span style="color: #CD5555">&quot;mean_squared_error&quot;</span>, optimizer=<span style="color: #CD5555">&quot;adam&quot;</span>)  
    <span style="color: #8B008B; font-weight: bold">return</span> model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="predicting-new-points-with-a-trained-recurrent-neural-network">Predicting New Points With A Trained Recurrent Neural Network </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_rnn</span> (x1, y_test, plot_min, plot_max):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Inputs:</span>
<span style="color: #CD5555">            x1 (a list or numpy array): The complete x component of the data set</span>
<span style="color: #CD5555">            y_test (a list or numpy array): The complete y component of the data set</span>
<span style="color: #CD5555">            plot_min (an int or float): the smallest x value used in the training data</span>
<span style="color: #CD5555">            plot_max (an int or float): the largest x valye used in the training data</span>
<span style="color: #CD5555">        Returns:</span>
<span style="color: #CD5555">            None.</span>
<span style="color: #CD5555">        Uses a trained recurrent neural network model to predict future points in the </span>
<span style="color: #CD5555">        series.  Computes the MSE of the predicted data set from the true data set, saves</span>
<span style="color: #CD5555">        the predicted data set to a csv file, and plots the predicted and true data sets w</span>
<span style="color: #CD5555">        while also displaying the data range used for training.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Add the training data as the first dim points in the predicted data array as these</span>
    <span style="color: #228B22"># are known values.</span>
    y_pred = y_test[:dim].tolist()
    <span style="color: #228B22"># Generate the first input to the trained recurrent neural network using the last two </span>
    <span style="color: #228B22"># points of the training data.  Based on how the network was trained this means that it</span>
    <span style="color: #228B22"># will predict the first point in the data set after the training data.  All of the </span>
    <span style="color: #228B22"># brackets are necessary for Tensorflow.</span>
    next_input = np.array([[[y_test[dim-<span style="color: #B452CD">2</span>]], [y_test[dim-<span style="color: #B452CD">1</span>]]]])
    <span style="color: #228B22"># Save the very last point in the training data set.  This will be used later.</span>
    last = [y_test[dim-<span style="color: #B452CD">1</span>]]

    <span style="color: #228B22"># Iterate until the complete data set is created.</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span> (dim, <span style="color: #658b00">len</span>(y_test)):
        <span style="color: #228B22"># Predict the next point in the data set using the previous two points.</span>
        <span style="color: #658b00">next</span> = model.predict(next_input)
        <span style="color: #228B22"># Append just the number of the predicted data set</span>
        y_pred.append(<span style="color: #658b00">next</span>[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">0</span>])
        <span style="color: #228B22"># Create the input that will be used to predict the next data point in the data set.</span>
        next_input = np.array([[last, <span style="color: #658b00">next</span>[<span style="color: #B452CD">0</span>]]], dtype=np.float64)
        last = <span style="color: #658b00">next</span>

    <span style="color: #228B22"># Print the mean squared error between the known data set and the predicted data set.</span>
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;MSE: &#39;</span>, np.square(np.subtract(y_test, y_pred)).mean())
    <span style="color: #228B22"># Save the predicted data set as a csv file for later use</span>
    name = datatype + <span style="color: #CD5555">&#39;Predicted&#39;</span>+<span style="color: #658b00">str</span>(dim)+<span style="color: #CD5555">&#39;.csv&#39;</span>
    np.savetxt(name, y_pred, delimiter=<span style="color: #CD5555">&#39;,&#39;</span>)
    <span style="color: #228B22"># Plot the known data set and the predicted data set.  The red box represents the region that was used</span>
    <span style="color: #228B22"># for the training data.</span>
    fig, ax = plt.subplots()
    ax.plot(x1, y_test, label=<span style="color: #CD5555">&quot;true&quot;</span>, linewidth=<span style="color: #B452CD">3</span>)
    ax.plot(x1, y_pred, <span style="color: #CD5555">&#39;g-.&#39;</span>,label=<span style="color: #CD5555">&quot;predicted&quot;</span>, linewidth=<span style="color: #B452CD">4</span>)
    ax.legend()
    <span style="color: #228B22"># Created a red region to represent the points used in the training data.</span>
    ax.axvspan(plot_min, plot_max, alpha=<span style="color: #B452CD">0.25</span>, color=<span style="color: #CD5555">&#39;red&#39;</span>)
    plt.show()

<span style="color: #228B22"># Check to make sure the data set is complete</span>
<span style="color: #8B008B; font-weight: bold">assert</span> <span style="color: #658b00">len</span>(X_tot) == <span style="color: #658b00">len</span>(y_tot)

<span style="color: #228B22"># This is the number of points that will be used in as the training data</span>
dim=<span style="color: #B452CD">12</span>

<span style="color: #228B22"># Separate the training data from the whole data set</span>
X_train = X_tot[:dim]
y_train = y_tot[:dim]


<span style="color: #228B22"># Generate the training data for the RNN, using a sequence of 2</span>
rnn_input, rnn_training = format_data(y_train, <span style="color: #B452CD">2</span>)


<span style="color: #228B22"># Create a recurrent neural network in Keras and produce a summary of the </span>
<span style="color: #228B22"># machine learning model</span>
model = rnn(length_of_sequences = rnn_input.shape[<span style="color: #B452CD">1</span>])
model.summary()

<span style="color: #228B22"># Start the timer.  Want to time training+testing</span>
start = timer()
<span style="color: #228B22"># Fit the model using the training data genenerated above using 150 training iterations and a 5%</span>
<span style="color: #228B22"># validation split.  Setting verbose to True prints information about each training iteration.</span>
hist = model.fit(rnn_input, rnn_training, batch_size=<span style="color: #8B008B; font-weight: bold">None</span>, epochs=<span style="color: #B452CD">150</span>, 
                 verbose=<span style="color: #8B008B; font-weight: bold">True</span>,validation_split=<span style="color: #B452CD">0.05</span>)

<span style="color: #8B008B; font-weight: bold">for</span> label <span style="color: #8B008B">in</span> [<span style="color: #CD5555">&quot;loss&quot;</span>,<span style="color: #CD5555">&quot;val_loss&quot;</span>]:
    plt.plot(hist.history[label],label=label)

plt.ylabel(<span style="color: #CD5555">&quot;loss&quot;</span>)
plt.xlabel(<span style="color: #CD5555">&quot;epoch&quot;</span>)
plt.title(<span style="color: #CD5555">&quot;The final validation loss: {}&quot;</span>.format(hist.history[<span style="color: #CD5555">&quot;val_loss&quot;</span>][-<span style="color: #B452CD">1</span>]))
plt.legend()
plt.show()

<span style="color: #228B22"># Use the trained neural network to predict more points of the data set</span>
test_rnn(X_tot, y_tot, X_tot[<span style="color: #B452CD">0</span>], X_tot[dim-<span style="color: #B452CD">1</span>])
<span style="color: #228B22"># Stop the timer and calculate the total time needed.</span>
end = timer()
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Time: &#39;</span>, end-start)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="other-things-to-try">Other Things to Try </h2>

<p>Changing the size of the recurrent neural network and its parameters
can drastically change the results you get from the model.  The below
code takes the simple recurrent neural network from above and adds a
second hidden layer, changes the number of neurons in the hidden
layer, and explicitly declares the activation function of the hidden
layers to be a sigmoid function.  The loss function and optimizer can
also be changed but are kept the same as the above network.  These
parameters can be tuned to provide the optimal result from the
network.  For some ideas on how to improve the performance of a
<a href="https://danijar.com/tips-for-training-recurrent-neural-networks" target="_blank">recurrent neural network</a>.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">rnn_2layers</span>(length_of_sequences, batch_size = <span style="color: #8B008B; font-weight: bold">None</span>, stateful = <span style="color: #8B008B; font-weight: bold">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Inputs:</span>
<span style="color: #CD5555">            length_of_sequences (an int): the number of y values in &quot;x data&quot;.  This is determined</span>
<span style="color: #CD5555">                when the data is formatted</span>
<span style="color: #CD5555">            batch_size (an int): Default value is None.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">            stateful (a boolean): Default value is False.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">        Returns:</span>
<span style="color: #CD5555">            model (a Keras model): The recurrent neural network that is built and compiled by this</span>
<span style="color: #CD5555">                method</span>
<span style="color: #CD5555">        Builds and compiles a recurrent neural network with two hidden layers and returns the model.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Number of neurons in the input and output layers</span>
    in_out_neurons = <span style="color: #B452CD">1</span>
    <span style="color: #228B22"># Number of neurons in the hidden layer, increased from the first network</span>
    hidden_neurons = <span style="color: #B452CD">500</span>
    <span style="color: #228B22"># Define the input layer</span>
    inp = Input(batch_shape=(batch_size, 
                length_of_sequences, 
                in_out_neurons))  
    <span style="color: #228B22"># Create two hidden layers instead of one hidden layer.  Explicitly set the activation</span>
    <span style="color: #228B22"># function to be the sigmoid function (the default value is hyperbolic tangent)</span>
    rnn1 = SimpleRNN(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">True</span>,  <span style="color: #228B22"># This needs to be True if another hidden layer is to follow</span>
                    stateful = stateful, activation = <span style="color: #CD5555">&#39;sigmoid&#39;</span>,
                    name=<span style="color: #CD5555">&quot;RNN1&quot;</span>)(inp)
    rnn2 = SimpleRNN(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">False</span>, activation = <span style="color: #CD5555">&#39;sigmoid&#39;</span>,
                    stateful = stateful,
                    name=<span style="color: #CD5555">&quot;RNN2&quot;</span>)(rnn1)
    <span style="color: #228B22"># Define the output layer as a dense neural network layer (standard neural network layer)</span>
    <span style="color: #228B22">#and add it to the network immediately after the hidden layer.</span>
    dens = Dense(in_out_neurons,name=<span style="color: #CD5555">&quot;dense&quot;</span>)(rnn2)
    <span style="color: #228B22"># Create the machine learning model starting with the input layer and ending with the </span>
    <span style="color: #228B22"># output layer</span>
    model = Model(inputs=[inp],outputs=[dens])
    <span style="color: #228B22"># Compile the machine learning model using the mean squared error function as the loss </span>
    <span style="color: #228B22"># function and an Adams optimizer.</span>
    model.compile(loss=<span style="color: #CD5555">&quot;mean_squared_error&quot;</span>, optimizer=<span style="color: #CD5555">&quot;adam&quot;</span>)  
    <span style="color: #8B008B; font-weight: bold">return</span> model

<span style="color: #228B22"># Check to make sure the data set is complete</span>
<span style="color: #8B008B; font-weight: bold">assert</span> <span style="color: #658b00">len</span>(X_tot) == <span style="color: #658b00">len</span>(y_tot)

<span style="color: #228B22"># This is the number of points that will be used in as the training data</span>
dim=<span style="color: #B452CD">12</span>

<span style="color: #228B22"># Separate the training data from the whole data set</span>
X_train = X_tot[:dim]
y_train = y_tot[:dim]


<span style="color: #228B22"># Generate the training data for the RNN, using a sequence of 2</span>
rnn_input, rnn_training = format_data(y_train, <span style="color: #B452CD">2</span>)


<span style="color: #228B22"># Create a recurrent neural network in Keras and produce a summary of the </span>
<span style="color: #228B22"># machine learning model</span>
model = rnn_2layers(length_of_sequences = <span style="color: #B452CD">2</span>)
model.summary()

<span style="color: #228B22"># Start the timer.  Want to time training+testing</span>
start = timer()
<span style="color: #228B22"># Fit the model using the training data genenerated above using 150 training iterations and a 5%</span>
<span style="color: #228B22"># validation split.  Setting verbose to True prints information about each training iteration.</span>
hist = model.fit(rnn_input, rnn_training, batch_size=<span style="color: #8B008B; font-weight: bold">None</span>, epochs=<span style="color: #B452CD">150</span>, 
                 verbose=<span style="color: #8B008B; font-weight: bold">True</span>,validation_split=<span style="color: #B452CD">0.05</span>)


<span style="color: #228B22"># This section plots the training loss and the validation loss as a function of training iteration.</span>
<span style="color: #228B22"># This is not required for analyzing the couple cluster data but can help determine if the network is</span>
<span style="color: #228B22"># being overtrained.</span>
<span style="color: #8B008B; font-weight: bold">for</span> label <span style="color: #8B008B">in</span> [<span style="color: #CD5555">&quot;loss&quot;</span>,<span style="color: #CD5555">&quot;val_loss&quot;</span>]:
    plt.plot(hist.history[label],label=label)

plt.ylabel(<span style="color: #CD5555">&quot;loss&quot;</span>)
plt.xlabel(<span style="color: #CD5555">&quot;epoch&quot;</span>)
plt.title(<span style="color: #CD5555">&quot;The final validation loss: {}&quot;</span>.format(hist.history[<span style="color: #CD5555">&quot;val_loss&quot;</span>][-<span style="color: #B452CD">1</span>]))
plt.legend()
plt.show()

<span style="color: #228B22"># Use the trained neural network to predict more points of the data set</span>
test_rnn(X_tot, y_tot, X_tot[<span style="color: #B452CD">0</span>], X_tot[dim-<span style="color: #B452CD">1</span>])
<span style="color: #228B22"># Stop the timer and calculate the total time needed.</span>
end = timer()
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Time: &#39;</span>, end-start)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="other-types-of-recurrent-neural-networks">Other Types of Recurrent Neural Networks </h2>

<p>Besides a simple recurrent neural network layer, there are two other
commonly used types of recurrent neural network layers: Long Short
Term Memory (LSTM) and Gated Recurrent Unit (GRU).  For a short
introduction to these layers see <a href="https://medium.com/mindboard/lstm-vs-gru-experimental-comparison-955820c21e8b" target="_blank"><tt>https://medium.com/mindboard/lstm-vs-gru-experimental-comparison-955820c21e8b</tt></a>
and <a href="https://medium.com/mindboard/lstm-vs-gru-experimental-comparison-955820c21e8b" target="_blank"><tt>https://medium.com/mindboard/lstm-vs-gru-experimental-comparison-955820c21e8b</tt></a>.
</p>

<p>The first network created below is similar to the previous network,
but it replaces the SimpleRNN layers with LSTM layers.  The second
network below has two hidden layers made up of GRUs, which are
preceeded by two dense (feeddorward) neural network layers.  These
dense layers "preprocess" the data before it reaches the recurrent
layers.  This architecture has been shown to improve the performance
of recurrent neural networks (see the link above and also
<a href="https://arxiv.org/pdf/1807.02857.pdf" target="_blank"><tt>https://arxiv.org/pdf/1807.02857.pdf</tt></a>.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">lstm_2layers</span>(length_of_sequences, batch_size = <span style="color: #8B008B; font-weight: bold">None</span>, stateful = <span style="color: #8B008B; font-weight: bold">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Inputs:</span>
<span style="color: #CD5555">            length_of_sequences (an int): the number of y values in &quot;x data&quot;.  This is determined</span>
<span style="color: #CD5555">                when the data is formatted</span>
<span style="color: #CD5555">            batch_size (an int): Default value is None.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">            stateful (a boolean): Default value is False.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">        Returns:</span>
<span style="color: #CD5555">            model (a Keras model): The recurrent neural network that is built and compiled by this</span>
<span style="color: #CD5555">                method</span>
<span style="color: #CD5555">        Builds and compiles a recurrent neural network with two LSTM hidden layers and returns the model.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Number of neurons on the input/output layer and the number of neurons in the hidden layer</span>
    in_out_neurons = <span style="color: #B452CD">1</span>
    hidden_neurons = <span style="color: #B452CD">250</span>
    <span style="color: #228B22"># Input Layer</span>
    inp = Input(batch_shape=(batch_size, 
                length_of_sequences, 
                in_out_neurons)) 
    <span style="color: #228B22"># Hidden layers (in this case they are LSTM layers instead if SimpleRNN layers)</span>
    rnn= LSTM(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">True</span>,
                    stateful = stateful,
                    name=<span style="color: #CD5555">&quot;RNN&quot;</span>, use_bias=<span style="color: #8B008B; font-weight: bold">True</span>, activation=<span style="color: #CD5555">&#39;tanh&#39;</span>)(inp)
    rnn1 = LSTM(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">False</span>,
                    stateful = stateful,
                    name=<span style="color: #CD5555">&quot;RNN1&quot;</span>, use_bias=<span style="color: #8B008B; font-weight: bold">True</span>, activation=<span style="color: #CD5555">&#39;tanh&#39;</span>)(rnn)
    <span style="color: #228B22"># Output layer</span>
    dens = Dense(in_out_neurons,name=<span style="color: #CD5555">&quot;dense&quot;</span>)(rnn1)
    <span style="color: #228B22"># Define the midel</span>
    model = Model(inputs=[inp],outputs=[dens])
    <span style="color: #228B22"># Compile the model</span>
    model.compile(loss=<span style="color: #CD5555">&#39;mean_squared_error&#39;</span>, optimizer=<span style="color: #CD5555">&#39;adam&#39;</span>)  
    <span style="color: #228B22"># Return the model</span>
    <span style="color: #8B008B; font-weight: bold">return</span> model

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dnn2_gru2</span>(length_of_sequences, batch_size = <span style="color: #8B008B; font-weight: bold">None</span>, stateful = <span style="color: #8B008B; font-weight: bold">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Inputs:</span>
<span style="color: #CD5555">            length_of_sequences (an int): the number of y values in &quot;x data&quot;.  This is determined</span>
<span style="color: #CD5555">                when the data is formatted</span>
<span style="color: #CD5555">            batch_size (an int): Default value is None.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">            stateful (a boolean): Default value is False.  See Keras documentation of SimpleRNN.</span>
<span style="color: #CD5555">        Returns:</span>
<span style="color: #CD5555">            model (a Keras model): The recurrent neural network that is built and compiled by this</span>
<span style="color: #CD5555">                method</span>
<span style="color: #CD5555">        Builds and compiles a recurrent neural network with four hidden layers (two dense followed by</span>
<span style="color: #CD5555">        two GRU layers) and returns the model.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>    
    <span style="color: #228B22"># Number of neurons on the input/output layers and hidden layers</span>
    in_out_neurons = <span style="color: #B452CD">1</span>
    hidden_neurons = <span style="color: #B452CD">250</span>
    <span style="color: #228B22"># Input layer</span>
    inp = Input(batch_shape=(batch_size, 
                length_of_sequences, 
                in_out_neurons)) 
    <span style="color: #228B22"># Hidden Dense (feedforward) layers</span>
    dnn = Dense(hidden_neurons/<span style="color: #B452CD">2</span>, activation=<span style="color: #CD5555">&#39;relu&#39;</span>, name=<span style="color: #CD5555">&#39;dnn&#39;</span>)(inp)
    dnn1 = Dense(hidden_neurons/<span style="color: #B452CD">2</span>, activation=<span style="color: #CD5555">&#39;relu&#39;</span>, name=<span style="color: #CD5555">&#39;dnn1&#39;</span>)(dnn)
    <span style="color: #228B22"># Hidden GRU layers</span>
    rnn1 = GRU(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">True</span>,
                    stateful = stateful,
                    name=<span style="color: #CD5555">&quot;RNN1&quot;</span>, use_bias=<span style="color: #8B008B; font-weight: bold">True</span>)(dnn1)
    rnn = GRU(hidden_neurons, 
                    return_sequences=<span style="color: #8B008B; font-weight: bold">False</span>,
                    stateful = stateful,
                    name=<span style="color: #CD5555">&quot;RNN&quot;</span>, use_bias=<span style="color: #8B008B; font-weight: bold">True</span>)(rnn1)
    <span style="color: #228B22"># Output layer</span>
    dens = Dense(in_out_neurons,name=<span style="color: #CD5555">&quot;dense&quot;</span>)(rnn)
    <span style="color: #228B22"># Define the model</span>
    model = Model(inputs=[inp],outputs=[dens])
    <span style="color: #228B22"># Compile the mdoel</span>
    model.compile(loss=<span style="color: #CD5555">&#39;mean_squared_error&#39;</span>, optimizer=<span style="color: #CD5555">&#39;adam&#39;</span>)  
    <span style="color: #228B22"># Return the model</span>
    <span style="color: #8B008B; font-weight: bold">return</span> model

<span style="color: #228B22"># Check to make sure the data set is complete</span>
<span style="color: #8B008B; font-weight: bold">assert</span> <span style="color: #658b00">len</span>(X_tot) == <span style="color: #658b00">len</span>(y_tot)

<span style="color: #228B22"># This is the number of points that will be used in as the training data</span>
dim=<span style="color: #B452CD">12</span>

<span style="color: #228B22"># Separate the training data from the whole data set</span>
X_train = X_tot[:dim]
y_train = y_tot[:dim]


<span style="color: #228B22"># Generate the training data for the RNN, using a sequence of 2</span>
rnn_input, rnn_training = format_data(y_train, <span style="color: #B452CD">2</span>)


<span style="color: #228B22"># Create a recurrent neural network in Keras and produce a summary of the </span>
<span style="color: #228B22"># machine learning model</span>
<span style="color: #228B22"># Change the method name to reflect which network you want to use</span>
model = dnn2_gru2(length_of_sequences = <span style="color: #B452CD">2</span>)
model.summary()

<span style="color: #228B22"># Start the timer.  Want to time training+testing</span>
start = timer()
<span style="color: #228B22"># Fit the model using the training data genenerated above using 150 training iterations and a 5%</span>
<span style="color: #228B22"># validation split.  Setting verbose to True prints information about each training iteration.</span>
hist = model.fit(rnn_input, rnn_training, batch_size=<span style="color: #8B008B; font-weight: bold">None</span>, epochs=<span style="color: #B452CD">150</span>, 
                 verbose=<span style="color: #8B008B; font-weight: bold">True</span>,validation_split=<span style="color: #B452CD">0.05</span>)


<span style="color: #228B22"># This section plots the training loss and the validation loss as a function of training iteration.</span>
<span style="color: #228B22"># This is not required for analyzing the couple cluster data but can help determine if the network is</span>
<span style="color: #228B22"># being overtrained.</span>
<span style="color: #8B008B; font-weight: bold">for</span> label <span style="color: #8B008B">in</span> [<span style="color: #CD5555">&quot;loss&quot;</span>,<span style="color: #CD5555">&quot;val_loss&quot;</span>]:
    plt.plot(hist.history[label],label=label)

plt.ylabel(<span style="color: #CD5555">&quot;loss&quot;</span>)
plt.xlabel(<span style="color: #CD5555">&quot;epoch&quot;</span>)
plt.title(<span style="color: #CD5555">&quot;The final validation loss: {}&quot;</span>.format(hist.history[<span style="color: #CD5555">&quot;val_loss&quot;</span>][-<span style="color: #B452CD">1</span>]))
plt.legend()
plt.show()

<span style="color: #228B22"># Use the trained neural network to predict more points of the data set</span>
test_rnn(X_tot, y_tot, X_tot[<span style="color: #B452CD">0</span>], X_tot[dim-<span style="color: #B452CD">1</span>])
<span style="color: #228B22"># Stop the timer and calculate the total time needed.</span>
end = timer()
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Time: &#39;</span>, end-start)


<span style="color: #228B22"># ### Training Recurrent Neural Networks in the Standard Way (i.e. learning the relationship between the X and Y data)</span>
<span style="color: #228B22"># </span>
<span style="color: #228B22"># Finally, comparing the performace of a recurrent neural network using the standard data formatting to the performance of the network with time sequence data formatting shows the benefit of this type of data formatting with extrapolation.</span>

<span style="color: #228B22"># Check to make sure the data set is complete</span>
<span style="color: #8B008B; font-weight: bold">assert</span> <span style="color: #658b00">len</span>(X_tot) == <span style="color: #658b00">len</span>(y_tot)

<span style="color: #228B22"># This is the number of points that will be used in as the training data</span>
dim=<span style="color: #B452CD">12</span>

<span style="color: #228B22"># Separate the training data from the whole data set</span>
X_train = X_tot[:dim]
y_train = y_tot[:dim]

<span style="color: #228B22"># Reshape the data for Keras specifications</span>
X_train = X_train.reshape((dim, <span style="color: #B452CD">1</span>))
y_train = y_train.reshape((dim, <span style="color: #B452CD">1</span>))


<span style="color: #228B22"># Create a recurrent neural network in Keras and produce a summary of the </span>
<span style="color: #228B22"># machine learning model</span>
<span style="color: #228B22"># Set the sequence length to 1 for regular data formatting </span>
model = rnn(length_of_sequences = <span style="color: #B452CD">1</span>)
model.summary()

<span style="color: #228B22"># Start the timer.  Want to time training+testing</span>
start = timer()
<span style="color: #228B22"># Fit the model using the training data genenerated above using 150 training iterations and a 5%</span>
<span style="color: #228B22"># validation split.  Setting verbose to True prints information about each training iteration.</span>
hist = model.fit(X_train, y_train, batch_size=<span style="color: #8B008B; font-weight: bold">None</span>, epochs=<span style="color: #B452CD">150</span>, 
                 verbose=<span style="color: #8B008B; font-weight: bold">True</span>,validation_split=<span style="color: #B452CD">0.05</span>)


<span style="color: #228B22"># This section plots the training loss and the validation loss as a function of training iteration.</span>
<span style="color: #228B22"># This is not required for analyzing the couple cluster data but can help determine if the network is</span>
<span style="color: #228B22"># being overtrained.</span>
<span style="color: #8B008B; font-weight: bold">for</span> label <span style="color: #8B008B">in</span> [<span style="color: #CD5555">&quot;loss&quot;</span>,<span style="color: #CD5555">&quot;val_loss&quot;</span>]:
    plt.plot(hist.history[label],label=label)

plt.ylabel(<span style="color: #CD5555">&quot;loss&quot;</span>)
plt.xlabel(<span style="color: #CD5555">&quot;epoch&quot;</span>)
plt.title(<span style="color: #CD5555">&quot;The final validation loss: {}&quot;</span>.format(hist.history[<span style="color: #CD5555">&quot;val_loss&quot;</span>][-<span style="color: #B452CD">1</span>]))
plt.legend()
plt.show()

<span style="color: #228B22"># Use the trained neural network to predict the remaining data points</span>
X_pred = X_tot[dim:]
X_pred = X_pred.reshape((<span style="color: #658b00">len</span>(X_pred), <span style="color: #B452CD">1</span>))
y_model = model.predict(X_pred)
y_pred = np.concatenate((y_tot[:dim], y_model.flatten()))

<span style="color: #228B22"># Plot the known data set and the predicted data set.  The red box represents the region that was used</span>
<span style="color: #228B22"># for the training data.</span>
fig, ax = plt.subplots()
ax.plot(X_tot, y_tot, label=<span style="color: #CD5555">&quot;true&quot;</span>, linewidth=<span style="color: #B452CD">3</span>)
ax.plot(X_tot, y_pred, <span style="color: #CD5555">&#39;g-.&#39;</span>,label=<span style="color: #CD5555">&quot;predicted&quot;</span>, linewidth=<span style="color: #B452CD">4</span>)
ax.legend()
<span style="color: #228B22"># Created a red region to represent the points used in the training data.</span>
ax.axvspan(X_tot[<span style="color: #B452CD">0</span>], X_tot[dim], alpha=<span style="color: #B452CD">0.25</span>, color=<span style="color: #CD5555">&#39;red&#39;</span>)
plt.show()

<span style="color: #228B22"># Stop the timer and calculate the total time needed.</span>
end = timer()
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Time: &#39;</span>, end-start)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="generative-models">Generative Models </h2>

<p><b>Generative models</b> describe a class of statistical models that are a contrast
to <b>discriminative models</b>. Informally we say that generative models can
generate new data instances while discriminative models discriminate between
different kinds of data instances. A generative model could generate new photos
of animals that look like 'real' animals while a discriminative model could tell
a dog from a cat. More formally, given a data set \( x \) and a set of labels /
targets \( y \). Generative models capture the joint probability \( p(x, y) \), or
just \( p(x) \) if there are no labels, while discriminative models capture the
conditional probability \( p(y | x) \). Discriminative models generally try to draw
boundaries in the data space (often high dimensional), while generative models
try to model how data is placed throughout the space.
</p>

<p><b>Note</b>: this material is thanks to Linus Ekstr&#248;m. </p>
</section>

<section>
<h2 id="generative-adversarial-networks">Generative Adversarial Networks </h2>

<p><b>Generative Adversarial Networks</b> are a type of unsupervised machine learning
algorithm proposed by <a href="https://arxiv.org/pdf/1406.2661.pdf" target="_blank">Goodfellow et. al</a>
in 2014 (short and good article).
</p>

<p>The simplest formulation of
the model is based on a game theoretic approach, <em>zero sum game</em>, where we pit
two neural networks against one another. We define two rival networks, one
generator \( g \), and one discriminator \( d \). The generator directly produces
samples
</p>
<p>&nbsp;<br>
$$
\begin{equation}
    x = g(z; \theta^{(g)})
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="discriminator">Discriminator </h2>
<p>The discriminator attempts to distinguish between samples drawn from the
training data and samples drawn from the generator. In other words, it tries to
tell the difference between the fake data produced by \( g \) and the actual data
samples we want to do prediction on. The discriminator outputs a probability
value given by
</p>

<p>&nbsp;<br>
$$
\begin{equation}
    d(x; \theta^{(d)})
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>

<p>indicating the probability that \( x \) is a real training example rather than a
fake sample the generator has generated. The simplest way to formulate the
learning process in a generative adversarial network is a zero-sum game, in
which a function
</p>

<p>&nbsp;<br>
$$
\begin{equation}
    v(\theta^{(g)}, \theta^{(d)})
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

<p>determines the reward for the discriminator, while the generator gets the
conjugate reward
</p>

<p>&nbsp;<br>
$$
\begin{equation}
    -v(\theta^{(g)}, \theta^{(d)})
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="learning-process">Learning Process </h2>

<p>During learning both of the networks maximize their own reward function, so that
the generator gets better and better at tricking the discriminator, while the
discriminator gets better and better at telling the difference between the fake
and real data. The generator and discriminator alternate on which one trains at
one time (i.e. for one epoch). In other words, we keep the generator constant
and train the discriminator, then we keep the discriminator constant to train
the generator and repeat. It is this back and forth dynamic which lets GANs
tackle otherwise intractable generative problems. As the generator improves with
 training, the discriminator's performance gets worse because it cannot easily
 tell the difference between real and fake. If the generator ends up succeeding
 perfectly, the the discriminator will do no better than random guessing i.e.
 50\%. This progression in the training poses a problem for the convergence
 criteria for GANs. The discriminator feedback gets less meaningful over time,
 if we continue training after this point then the generator is effectively
 training on junk data which can undo the learning up to that point. Therefore,
 we stop training when the discriminator starts outputting \( 1/2 \) everywhere.
</p>
</section>

<section>
<h2 id="more-about-the-learning-process">More about the Learning Process </h2>

<p>At convergence we have</p>

<p>&nbsp;<br>
$$
\begin{equation}
    g^* = \underset{g}{\mathrm{argmin}}\hspace{2pt}
          \underset{d}{\mathrm{max}}v(\theta^{(g)}, \theta^{(d)})
\tag{10}
\end{equation}
$$
<p>&nbsp;<br>

<p>The default choice for \( v \) is</p>
<p>&nbsp;<br>
$$
\begin{equation}
    v(\theta^{(g)}, \theta^{(d)}) = \mathbb{E}_{x\sim p_\mathrm{data}}\log d(x)
                                  + \mathbb{E}_{x\sim p_\mathrm{model}}
                                  \log (1 - d(x))
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

<p>The main motivation for the design of GANs is that the learning process requires
neither approximate inference (variational autoencoders for example) nor
approximation of a partition function. In the case where
</p>
<p>&nbsp;<br>
$$
\begin{equation}
    \underset{d}{\mathrm{max}}v(\theta^{(g)}, \theta^{(d)})
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>

<p>is convex in $\theta^{(g)} then the procedure is guaranteed to converge and is
asymptotically consistent
( <a href="https://arxiv.org/pdf/1804.09139.pdf" target="_blank">Seth Lloyd on QuGANs</a>  ).
</p>
</section>

<section>
<h2 id="additional-references">Additional References </h2>
<p>This is in
general not the case and it is possible to get situations where the training
process never converges because the generator and discriminator chase one
another around in the parameter space indefinitely. A much deeper discussion on
the currently open research problem of GAN convergence is available
<a href="https://www.deeplearningbook.org/contents/generative_models.html" target="_blank">here</a>. To
anyone interested in learning more about GANs it is a highly recommended read.
Direct quote: "In this best-performing formulation, the generator aims to
increase the log probability that the discriminator makes a mistake, rather than
aiming to decrease the log probability that the discriminator makes the correct
prediction." <a href="https://arxiv.org/abs/1701.00160" target="_blank">Another interesting read</a>
</p>
</section>

<section>
<h2 id="writing-our-first-generative-adversarial-network">Writing Our First Generative Adversarial Network </h2>
<p>Let us now move on to actually implementing a GAN in tensorflow. We will study
the performance of our GAN on the MNIST dataset. This code is based on and
adapted from the
<a href="https://www.tensorflow.org/tutorials/generative/dcgan" target="_blank">google tutorial</a>
</p>

<p>First we import our libraries</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">tensorflow</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">tf</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras</span> <span style="color: #8B008B; font-weight: bold">import</span> layers
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow.keras.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> plot_model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we define our hyperparameters and import our data the usual way</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">BUFFER_SIZE = <span style="color: #B452CD">60000</span>
BATCH_SIZE = <span style="color: #B452CD">256</span>
EPOCHS = <span style="color: #B452CD">30</span>

data = tf.keras.datasets.mnist.load_data()
(train_images, train_labels), (test_images, test_labels) = data
train_images = np.reshape(train_images, (train_images.shape[<span style="color: #B452CD">0</span>],
                                         <span style="color: #B452CD">28</span>,
                                         <span style="color: #B452CD">28</span>,
                                         <span style="color: #B452CD">1</span>)).astype(<span style="color: #CD5555">&#39;float32&#39;</span>)

<span style="color: #228B22"># we normalize between -1 and 1</span>
train_images = (train_images - <span style="color: #B452CD">127.5</span>) / <span style="color: #B452CD">127.5</span>
training_dataset = tf.data.Dataset.from_tensor_slices(
                      train_images).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="mnist-and-gans">MNIST and GANs </h2>

<p>Let's have a quick look</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">plt.imshow(train_images[<span style="color: #B452CD">0</span>], cmap=<span style="color: #CD5555">&#39;Greys&#39;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now we define our two models. This is where the 'magic' happens. There are a
huge amount of possible formulations for both models. A lot of engineering and
trial and error can be done here to try to produce better performing models. For
more advanced GANs this is by far the step where you can 'make or break' a
model.
</p>

<p>We start with the generator. As stated in the introductory text the generator
\( g \) upsamples from a random sample to the shape of what we want to predict. In
our case we are trying to predict MNIST images (\( 28\times 28 \) pixels).
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generator_model</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    The generator uses upsampling layers tf.keras.layers.Conv2DTranspose() to</span>
<span style="color: #CD5555">    produce an image from a random seed. We start with a Dense layer taking this</span>
<span style="color: #CD5555">    random sample as an input and subsequently upsample through multiple</span>
<span style="color: #CD5555">    convolutional layers.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>

    <span style="color: #228B22"># we define our model</span>
    model = tf.keras.Sequential()


    <span style="color: #228B22"># adding our input layer. Dense means that every neuron is connected and</span>
    <span style="color: #228B22"># the input shape is the shape of our random noise. The units need to match</span>
    <span style="color: #228B22"># in some sense the upsampling strides to reach our desired output shape.</span>
    <span style="color: #228B22"># we are using 100 random numbers as our seed</span>
    model.add(layers.Dense(units=<span style="color: #B452CD">7</span>*<span style="color: #B452CD">7</span>*BATCH_SIZE,
                           use_bias=<span style="color: #8B008B; font-weight: bold">False</span>,
                           input_shape=(<span style="color: #B452CD">100</span>, )))
    <span style="color: #228B22"># we normalize the output form the Dense layer</span>
    model.add(layers.BatchNormalization())
    <span style="color: #228B22"># and add an activation function to our &#39;layer&#39;. LeakyReLU avoids vanishing</span>
    <span style="color: #228B22"># gradient problem</span>
    model.add(layers.LeakyReLU())
    model.add(layers.Reshape((<span style="color: #B452CD">7</span>, <span style="color: #B452CD">7</span>, BATCH_SIZE)))
    <span style="color: #8B008B; font-weight: bold">assert</span> model.output_shape == (<span style="color: #8B008B; font-weight: bold">None</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">7</span>, BATCH_SIZE)
    <span style="color: #228B22"># even though we just added four keras layers we think of everything above</span>
    <span style="color: #228B22"># as &#39;one&#39; layer</span>

    <span style="color: #228B22"># next we add our upscaling convolutional layers</span>
    model.add(layers.Conv2DTranspose(filters=<span style="color: #B452CD">128</span>,
                                     kernel_size=(<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>),
                                     strides=(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>),
                                     padding=<span style="color: #CD5555">&#39;same&#39;</span>,
                                     use_bias=<span style="color: #8B008B; font-weight: bold">False</span>))
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())
    <span style="color: #8B008B; font-weight: bold">assert</span> model.output_shape == (<span style="color: #8B008B; font-weight: bold">None</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">128</span>)

    model.add(layers.Conv2DTranspose(filters=<span style="color: #B452CD">64</span>,
                                     kernel_size=(<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>),
                                     strides=(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>),
                                     padding=<span style="color: #CD5555">&#39;same&#39;</span>,
                                     use_bias=<span style="color: #8B008B; font-weight: bold">False</span>))
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())
    <span style="color: #8B008B; font-weight: bold">assert</span> model.output_shape == (<span style="color: #8B008B; font-weight: bold">None</span>, <span style="color: #B452CD">14</span>, <span style="color: #B452CD">14</span>, <span style="color: #B452CD">64</span>)

    model.add(layers.Conv2DTranspose(filters=<span style="color: #B452CD">1</span>,
                                     kernel_size=(<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>),
                                     strides=(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>),
                                     padding=<span style="color: #CD5555">&#39;same&#39;</span>,
                                     use_bias=<span style="color: #8B008B; font-weight: bold">False</span>,
                                     activation=<span style="color: #CD5555">&#39;tanh&#39;</span>))
    <span style="color: #8B008B; font-weight: bold">assert</span> model.output_shape == (<span style="color: #8B008B; font-weight: bold">None</span>, <span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>, <span style="color: #B452CD">1</span>)

    <span style="color: #8B008B; font-weight: bold">return</span> model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>And there we have our 'simple' generator model. Now we move on to defining our
discriminator model \( d \), which is a convolutional neural network based image
classifier.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">discriminator_model</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    The discriminator is a convolutional neural network based image classifier</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>

    <span style="color: #228B22"># we define our model</span>
    model = tf.keras.Sequential()
    model.add(layers.Conv2D(filters=<span style="color: #B452CD">64</span>,
                            kernel_size=(<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>),
                            strides=(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>),
                            padding=<span style="color: #CD5555">&#39;same&#39;</span>,
                            input_shape=[<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>, <span style="color: #B452CD">1</span>]))
    model.add(layers.LeakyReLU())
    <span style="color: #228B22"># adding a dropout layer as you do in conv-nets</span>
    model.add(layers.Dropout(<span style="color: #B452CD">0.3</span>))


    model.add(layers.Conv2D(filters=<span style="color: #B452CD">128</span>,
                            kernel_size=(<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>),
                            strides=(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>),
                            padding=<span style="color: #CD5555">&#39;same&#39;</span>))
    model.add(layers.LeakyReLU())
    <span style="color: #228B22"># adding a dropout layer as you do in conv-nets</span>
    model.add(layers.Dropout(<span style="color: #B452CD">0.3</span>))

    model.add(layers.Flatten())
    model.add(layers.Dense(<span style="color: #B452CD">1</span>))

    <span style="color: #8B008B; font-weight: bold">return</span> model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="other-models">Other Models </h2>
<p>Let us take a look at our models. <b>Note</b>: double click images for bigger view.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">generator = generator_model()
plot_model(generator, show_shapes=<span style="color: #8B008B; font-weight: bold">True</span>, rankdir=<span style="color: #CD5555">&#39;LR&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">discriminator = discriminator_model()
plot_model(discriminator, show_shapes=<span style="color: #8B008B; font-weight: bold">True</span>, rankdir=<span style="color: #CD5555">&#39;LR&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we need a few helper objects we will use in training</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=<span style="color: #8B008B; font-weight: bold">True</span>)
generator_optimizer = tf.keras.optimizers.Adam(<span style="color: #B452CD">1e-4</span>)
discriminator_optimizer = tf.keras.optimizers.Adam(<span style="color: #B452CD">1e-4</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The first object, <em>cross_entropy</em> is our loss function and the two others are
our optimizers. Notice we use the same learning rate for both \( g \) and \( d \). This
is because they need to improve their accuracy at approximately equal speeds to
get convergence (not necessarily exactly equal). Now we define our loss
functions
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generator_loss</span>(fake_output):
    loss = cross_entropy(tf.ones_like(fake_output), fake_output)

    <span style="color: #8B008B; font-weight: bold">return</span> loss
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">discriminator_loss</span>(real_output, fake_output):
    real_loss = cross_entropy(tf.ones_like(real_output), real_output)
    fake_loss = cross_entropy(tf.zeros_liks(fake_output), fake_output)
    total_loss = real_loss + fake_loss

    <span style="color: #8B008B; font-weight: bold">return</span> total_loss
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we define a kind of seed to help us compare the learning process over
multiple training epochs.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">noise_dimension = <span style="color: #B452CD">100</span>
n_examples_to_generate = <span style="color: #B452CD">16</span>
seed_images = tf.random.normal([n_examples_to_generate, noise_dimension])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="training-step">Training Step </h2>

<p>Now we have everything we need to define our training step, which we will apply
for every step in our training loop. Notice the @tf.function flag signifying
that the function is tensorflow 'compiled'. Removing this flag doubles the
computation time.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #707a7c">@tf</span>.function
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">train_step</span>(images):
    noise = tf.random.normal([BATCH_SIZE, noise_dimension])

    <span style="color: #8B008B; font-weight: bold">with</span> tf.GradientTape() <span style="color: #8B008B; font-weight: bold">as</span> gen_tape, tf.GradientTape() <span style="color: #8B008B; font-weight: bold">as</span> disc_tape:
        generated_images = generator(noise, training=<span style="color: #8B008B; font-weight: bold">True</span>)

        real_output = discriminator(images, training=<span style="color: #8B008B; font-weight: bold">True</span>)
        fake_output = discriminator(generated_images, training=<span style="color: #8B008B; font-weight: bold">True</span>)

        gen_loss = generator_loss(fake_output)
        disc_loss = discriminator_loss(real_output, fake_output)

    gradients_of_generator = gen_tape.gradient(gen_loss,
                                            generator.trainable_variables)
    gradients_of_discriminator = disc_tape.gradient(disc_loss,
                                            discriminator.trainable_variables)
    generator_optimizer.apply_gradients(<span style="color: #658b00">zip</span>(gradients_of_generator,
                                            generator.trainable_variables))
    discriminator_optimizer.apply_gradients(<span style="color: #658b00">zip</span>(gradients_of_discriminator,
                                            discriminator.trainable_variables))

    <span style="color: #8B008B; font-weight: bold">return</span> gen_loss, disc_loss
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we define a helper function to produce an output over our training epochs
to see the predictive progression of our generator model. <b>Note</b>: I am including
this code here, but comment it out in the training loop.
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generate_and_save_images</span>(model, epoch, test_input):
    <span style="color: #228B22"># we&#39;re making inferences here</span>
    predictions = model(test_input, training=<span style="color: #8B008B; font-weight: bold">False</span>)

    fig = plt.figure(figsize=(<span style="color: #B452CD">4</span>, <span style="color: #B452CD">4</span>))

    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(predictions.shape[<span style="color: #B452CD">0</span>]):
        plt.subplot(<span style="color: #B452CD">4</span>, <span style="color: #B452CD">4</span>, i+<span style="color: #B452CD">1</span>)
        plt.imshow(predictions[i, :, :, <span style="color: #B452CD">0</span>] * <span style="color: #B452CD">127.5</span> + <span style="color: #B452CD">127.5</span>, cmap=<span style="color: #CD5555">&#39;gray&#39;</span>)
        plt.axis(<span style="color: #CD5555">&#39;off&#39;</span>)

    plt.savefig(<span style="color: #CD5555">f&#39;./images_from_seed_images/image_at_epoch_{</span><span style="color: #658b00">str</span>(epoch).zfill(<span style="color: #B452CD">3</span>)<span style="color: #CD5555">}.png&#39;</span>)
    plt.close()
    <span style="color: #228B22">#plt.show()</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="checkpoints">Checkpoints </h2>
<p>Setting up checkpoints to periodically save our model during training so that
everything is not lost even if the program were to somehow terminate while
training.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Setting up checkpoints to save model during training</span>
checkpoint_dir = <span style="color: #CD5555">&#39;./training_checkpoints&#39;</span>
checkpoint_prefix = os.path.join(checkpoint_dir, <span style="color: #CD5555">&#39;ckpt&#39;</span>)
checkpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer,
                            discriminator_optimizer=discriminator_optimizer,
                            generator=generator,
                            discriminator=discriminator)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now we define our training loop</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">train</span>(dataset, epochs):
    generator_loss_list = []
    discriminator_loss_list = []

    <span style="color: #8B008B; font-weight: bold">for</span> epoch <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(epochs):
        start = time.time()

        <span style="color: #8B008B; font-weight: bold">for</span> image_batch <span style="color: #8B008B">in</span> dataset:
            gen_loss, disc_loss = train_step(image_batch)
            generator_loss_list.append(gen_loss.numpy())
            discriminator_loss_list.append(disc_loss.numpy())

        <span style="color: #228B22">#generate_and_save_images(generator, epoch + 1, seed_images)</span>

        <span style="color: #8B008B; font-weight: bold">if</span> (epoch + <span style="color: #B452CD">1</span>) % <span style="color: #B452CD">15</span> == <span style="color: #B452CD">0</span>:
            checkpoint.save(file_prefix=checkpoint_prefix)

        <span style="color: #658b00">print</span>(<span style="color: #CD5555">f&#39;Time for epoch {</span>epoch<span style="color: #CD5555">} is {</span>time.time() - start<span style="color: #CD5555">}&#39;</span>)

    <span style="color: #228B22">#generate_and_save_images(generator, epochs, seed_images)</span>

    loss_file = <span style="color: #CD5555">&#39;./data/lossfile.txt&#39;</span>
    <span style="color: #8B008B; font-weight: bold">with</span> <span style="color: #658b00">open</span>(loss_file, <span style="color: #CD5555">&#39;w&#39;</span>) <span style="color: #8B008B; font-weight: bold">as</span> outfile:
        outfile.write(<span style="color: #658b00">str</span>(generator_loss_list))
        outfile.write(<span style="color: #CD5555">&#39;\n&#39;</span>)
        outfile.write(<span style="color: #CD5555">&#39;\n&#39;</span>)
        outfile.write(<span style="color: #658b00">str</span>(discriminator_loss_list))
        outfile.write(<span style="color: #CD5555">&#39;\n&#39;</span>)
        outfile.write(<span style="color: #CD5555">&#39;\n&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>To train simply call this function. <b>Warning</b>: this might take a long time so
there is a folder of a pretrained network already included in the repository.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">train(train_dataset, EPOCHS)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>And here is the result of training our model for 100 epochs</p>

<embed src="images_from_seed_images/generation.gif"  autoplay="false" loop="true"></embed>
<p><em></em></p>

<p>Now to avoid having to train and everything, which will take a while depending
on your computer setup we now load in the model which produced the above gif.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">checkpoint.restore(tf.train.latest_checkpoint(checkpoint_dir))
restored_generator = checkpoint.generator
restored_discriminator = checkpoint.discriminator

<span style="color: #658b00">print</span>(restored_generator)
<span style="color: #658b00">print</span>(restored_discriminator)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="exploring-the-latent-space">Exploring the Latent Space </h2>

<p>We have successfully loaded in our latest model. Let us now play around a bit
and see what kind of things we can learn about this model. Our generator takes
an array of 100 numbers. One idea can be to try to systematically change our
input. Let us try and see what we get
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generate_latent_points</span>(number=<span style="color: #B452CD">100</span>, scale_means=<span style="color: #B452CD">1</span>, scale_stds=<span style="color: #B452CD">1</span>):
    latent_dim = <span style="color: #B452CD">100</span>
    means = scale_means * tf.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, num=latent_dim)
    stds = scale_stds * tf.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, num=latent_dim)
    latent_space_value_range = tf.random.normal([number, latent_dim],
                                                means,
                                                stds,
                                                dtype=tf.float64)

    <span style="color: #8B008B; font-weight: bold">return</span> latent_space_value_range

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generate_images</span>(latent_points):
    <span style="color: #228B22"># notice we set training to false because we are making inferences</span>
    generated_images = restored_generator.predict(latent_points)

    <span style="color: #8B008B; font-weight: bold">return</span> generated_images
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_result</span>(generated_images, number=<span style="color: #B452CD">100</span>):
    <span style="color: #228B22"># obviously this assumes sqrt number is an int</span>
    fig, axs = plt.subplots(<span style="color: #658b00">int</span>(np.sqrt(number)), <span style="color: #658b00">int</span>(np.sqrt(number)),
                            figsize=(<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))

    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">int</span>(np.sqrt(number))):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">int</span>(np.sqrt(number))):
            axs[i, j].imshow(generated_images[i*j], cmap=<span style="color: #CD5555">&#39;Greys&#39;</span>)
            axs[i, j].axis(<span style="color: #CD5555">&#39;off&#39;</span>)

    plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">generated_images = generate_images(generate_latent_points())
plot_result(generated_images)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="getting-results">Getting Results </h2>
<p>We see that the generator generates images that look like MNIST
numbers: \( 1, 4, 7, 9 \). Let's try to tweak it a bit more to see if we are able
to generate a similar plot where we generate every MNIST number. Let us now try
to 'move' a bit around in the latent space. <b>Note</b>: decrease the plot number if
these following cells take too long to run on your computer.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">plot_number = <span style="color: #B452CD">225</span>

generated_images = generate_images(generate_latent_points(number=plot_number,
                                                          scale_means=<span style="color: #B452CD">5</span>,
                                                          scale_stds=<span style="color: #B452CD">1</span>))
plot_result(generated_images, number=plot_number)

generated_images = generate_images(generate_latent_points(number=plot_number,
                                                          scale_means=-<span style="color: #B452CD">5</span>,
                                                          scale_stds=<span style="color: #B452CD">1</span>))
plot_result(generated_images, number=plot_number)

generated_images = generate_images(generate_latent_points(number=plot_number,
                                                          scale_means=<span style="color: #B452CD">1</span>,
                                                          scale_stds=<span style="color: #B452CD">5</span>))
plot_result(generated_images, number=plot_number)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Again, we have found something interesting. <em>Moving</em> around using our means
takes us from digit to digit, while <em>moving</em> around using our standard
deviations seem to increase the number of different digits! In the last image
above, we can barely make out every MNIST digit. Let us make on last plot using
this information by upping the standard deviation of our Gaussian noises.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">plot_number = <span style="color: #B452CD">400</span>
generated_images = generate_images(generate_latent_points(number=plot_number,
                                                          scale_means=<span style="color: #B452CD">1</span>,
                                                          scale_stds=<span style="color: #B452CD">10</span>))
plot_result(generated_images, number=plot_number)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>A pretty cool result! We see that our generator indeed has learned a
distribution which qualitatively looks a whole lot like the MNIST dataset.
</p>
</section>

<section>
<h2 id="interpolating-between-mnist-digits">Interpolating Between MNIST Digits </h2>
<p>Another interesting way to explore the latent space of our generator model is by
interpolating between the MNIST digits. This section is largely based on
<a href="https://machinelearningmastery.com/how-to-interpolate-and-perform-vector-arithmetic-with-faces-using-a-generative-adversarial-network/" target="_blank">this excellent blogpost</a>
by Jason Brownlee.
</p>

<p>So let us start by defining a function to interpolate between two points in the
latent space.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">interpolation</span>(point_1, point_2, n_steps=<span style="color: #B452CD">10</span>):
    ratios = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, num=n_steps)
    vectors = []
    <span style="color: #8B008B; font-weight: bold">for</span> i, ratio <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(ratios):
        vectors.append(((<span style="color: #B452CD">1.0</span> - ratio) * point_1 + ratio * point_2))

    <span style="color: #8B008B; font-weight: bold">return</span> tf.stack(vectors)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now we have all we need to do our interpolation analysis.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">plot_number = <span style="color: #B452CD">100</span>
latent_points = generate_latent_points(number=plot_number)
results = <span style="color: #8B008B; font-weight: bold">None</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>*np.sqrt(plot_number), <span style="color: #B452CD">2</span>):
    interpolated = interpolation(latent_points[i], latent_points[i+<span style="color: #B452CD">1</span>])
    generated_images = generate_images(interpolated)

    <span style="color: #8B008B; font-weight: bold">if</span> results <span style="color: #8B008B">is</span> <span style="color: #8B008B; font-weight: bold">None</span>:
        results = generated_images
    <span style="color: #8B008B; font-weight: bold">else</span>:
        results = tf.stack((results, generated_images))

plot_results(results, plot_number)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>
