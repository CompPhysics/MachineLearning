<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week39.do.txt --pygments_html_style=perldoc --html_style=solarized3 --html_links_in_new_window --html_output=week39-solarized --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Week 39: Resampling methods and logistic regression">
<title>Week 39: Resampling methods and logistic regression</title>
<link href="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link href="https://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Plan for week 39, September 22-26, 2025',
               2,
               None,
               'plan-for-week-39-september-22-26-2025'),
              ('Readings and Videos, resampling methods',
               2,
               None,
               'readings-and-videos-resampling-methods'),
              ('Readings and Videos, logistic regression',
               2,
               None,
               'readings-and-videos-logistic-regression'),
              ('Lab sessions week 39', 2, None, 'lab-sessions-week-39'),
              ('Lecture material', 2, None, 'lecture-material'),
              ('Resampling methods', 2, None, 'resampling-methods'),
              ('Resampling approaches can be computationally expensive',
               2,
               None,
               'resampling-approaches-can-be-computationally-expensive'),
              ('Why resampling methods ?', 2, None, 'why-resampling-methods'),
              ('Statistical analysis', 2, None, 'statistical-analysis'),
              ('Resampling methods', 2, None, 'resampling-methods'),
              ('Resampling methods: Bootstrap',
               2,
               None,
               'resampling-methods-bootstrap'),
              ('The bias-variance tradeoff',
               2,
               None,
               'the-bias-variance-tradeoff'),
              ('A way to Read the Bias-Variance Tradeoff',
               2,
               None,
               'a-way-to-read-the-bias-variance-tradeoff'),
              ('Understanding what happens',
               2,
               None,
               'understanding-what-happens'),
              ('Summing up', 2, None, 'summing-up'),
              ("Another Example from Scikit-Learn's Repository",
               2,
               None,
               'another-example-from-scikit-learn-s-repository'),
              ('Various steps in cross-validation',
               2,
               None,
               'various-steps-in-cross-validation'),
              ('Cross-validation in brief',
               2,
               None,
               'cross-validation-in-brief'),
              ('Code Example for Cross-validation and $k$-fold '
               'Cross-validation',
               2,
               None,
               'code-example-for-cross-validation-and-k-fold-cross-validation'),
              ('More examples on bootstrap and cross-validation and errors',
               2,
               None,
               'more-examples-on-bootstrap-and-cross-validation-and-errors'),
              ('The same example but now with cross-validation',
               2,
               None,
               'the-same-example-but-now-with-cross-validation'),
              ('Logistic Regression', 2, None, 'logistic-regression'),
              ('Classification problems', 2, None, 'classification-problems'),
              ('Optimization and Deep learning',
               2,
               None,
               'optimization-and-deep-learning'),
              ('Basics', 2, None, 'basics'),
              ('Linear classifier', 2, None, 'linear-classifier'),
              ('Some selected properties', 2, None, 'some-selected-properties'),
              ('Simple example', 2, None, 'simple-example'),
              ('Plotting the mean value for each group',
               2,
               None,
               'plotting-the-mean-value-for-each-group'),
              ('The logistic function', 2, None, 'the-logistic-function'),
              ('Examples of likelihood functions used in logistic regression '
               'and nueral networks',
               2,
               None,
               'examples-of-likelihood-functions-used-in-logistic-regression-and-nueral-networks'),
              ('Two parameters', 2, None, 'two-parameters'),
              ('Maximum likelihood', 2, None, 'maximum-likelihood'),
              ('The cost function rewritten',
               2,
               None,
               'the-cost-function-rewritten'),
              ('Minimizing the cross entropy',
               2,
               None,
               'minimizing-the-cross-entropy'),
              ('A more compact expression',
               2,
               None,
               'a-more-compact-expression'),
              ('Extending to more predictors',
               2,
               None,
               'extending-to-more-predictors'),
              ('Including more classes', 2, None, 'including-more-classes'),
              ('More classes', 2, None, 'more-classes'),
              ('Optimization, the central part of any Machine Learning '
               'algortithm',
               2,
               None,
               'optimization-the-central-part-of-any-machine-learning-algortithm'),
              ('Revisiting our Logistic Regression case',
               2,
               None,
               'revisiting-our-logistic-regression-case'),
              ('The equations to solve', 2, None, 'the-equations-to-solve'),
              ("Solving using Newton-Raphson's method",
               2,
               None,
               'solving-using-newton-raphson-s-method'),
              ('Example code for Logistic Regression',
               2,
               None,
               'example-code-for-logistic-regression'),
              ('Synthetic data generation',
               3,
               None,
               'synthetic-data-generation')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>Week 39: Resampling methods and logistic regression</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics, University of Oslo</b>
</center>
<br>
<center>
<h4>Week 39</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plan-for-week-39-september-22-26-2025">Plan for week 39, September 22-26, 2025 </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Material for the lecture on Monday September 22</b>
<p>
<ol>
<li> Resampling techniques, Bootstrap and cross validation and bias-variance tradeoff</li>
<li> Logistic regression, our first classification encounter and a stepping stone towards neural networks</li>
<li> <a href="https://youtu.be/OVouJyhoksY" target="_blank">Video of lecture</a></li>
<li> <a href="https://github.com/CompPhysics/MachineLearning/blob/master/doc/HandWrittenNotes/2024/FYSSTKweek39.pdf" target="_blank">Whiteboard notes</a></li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="readings-and-videos-resampling-methods">Readings and Videos, resampling methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ol>
<li> Raschka et al, pages 175-192</li>
<li> Hastie et al Chapter 7, here we recommend 7.1-7.5 and 7.10 (cross-validation) and 7.11 (bootstrap). See <a href="https://link.springer.com/book/10.1007/978-0-387-84858-7" target="_blank"><tt>https://link.springer.com/book/10.1007/978-0-387-84858-7</tt></a>.</li>
<li> <a href="https://www.youtube.com/watch?v=EuBBz3bI-aA" target="_blank">Video on bias-variance tradeoff</a></li>
<li> <a href="https://www.youtube.com/watch?v=Xz0x-8-cgaQ" target="_blank">Video on Bootstrapping</a></li>
<li> <a href="https://www.youtube.com/watch?v=fSytzGwwBVw" target="_blank">Video on cross validation</a></li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="readings-and-videos-logistic-regression">Readings and Videos, logistic regression </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ol>
<li> Hastie et al 4.1, 4.2 and 4.3 on logistic regression</li>
<li> Raschka et al, pages 53-76 on Logistic regression and pages 37-52 on gradient optimization</li>
<li> <a href="https://www.youtube.com/watch?v=C5268D9t9Ak" target="_blank">Video on Logistic regression</a></li>
<li> <a href="https://www.youtube.com/watch?v=yIYKR4sgzI8" target="_blank">Yet another video on logistic regression</a></li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="lab-sessions-week-39">Lab sessions week 39 </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Material for the lab sessions on Tuesday and Wednesday</b>
<p>
<ol>
<li> Discussions on how to structure your report for the first project</li>
<li> Exercise for week 39 on how to write the abstract and the introduction of the report and how to include references.</li> 
<li> Work on project 1, in particular resampling methods like cross-validation and bootstrap. <b>For more discussions of project 1, chapter 5 of Goodfellow et al is a good read, in particular sections 5.1-5.5 and 5.7-5.11</b>.</li>
<li> <a href="https://youtu.be/tVW1ZDmZnwM" target="_blank">Video on how to write scientific reports recorded during one of the lab sessions</a></li>
<li> A general guideline can be found at <a href="https://github.com/CompPhysics/MachineLearning/blob/master/doc/Projects/EvaluationGrading/EvaluationForm.md" target="_blank"><tt>https://github.com/CompPhysics/MachineLearning/blob/master/doc/Projects/EvaluationGrading/EvaluationForm.md</tt></a>.</li>
</ol>
</div>
  

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="lecture-material">Lecture material </h2>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="resampling-methods">Resampling methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Resampling methods are an indispensable tool in modern
statistics. They involve repeatedly drawing samples from a training
set and refitting a model of interest on each sample in order to
obtain additional information about the fitted model. For example, in
order to estimate the variability of a linear regression fit, we can
repeatedly draw different samples from the training data, fit a linear
regression to each new sample, and then examine the extent to which
the resulting fits differ. Such an approach may allow us to obtain
information that would not be available from fitting the model only
once using the original training sample.
</p>

<p>Two resampling methods are often used in Machine Learning analyses,</p>
<ol>
<li> The <b>bootstrap method</b></li>
<li> and <b>Cross-Validation</b></li>
</ol>
<p>In addition there are several other methods such as the Jackknife and the Blocking methods. This week will repeat some of the elements of the bootstrap method and focus more on cross-validation.</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="resampling-approaches-can-be-computationally-expensive">Resampling approaches can be computationally expensive </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>Resampling approaches can be computationally expensive, because they
involve fitting the same statistical method multiple times using
different subsets of the training data. However, due to recent
advances in computing power, the computational requirements of
resampling methods generally are not prohibitive. In this chapter, we
discuss two of the most commonly used resampling methods,
cross-validation and the bootstrap. Both methods are important tools
in the practical application of many statistical learning
procedures. For example, cross-validation can be used to estimate the
test error associated with a given statistical learning method in
order to evaluate its performance, or to select the appropriate level
of flexibility. The process of evaluating a model&#8217;s performance is
known as model assessment, whereas the process of selecting the proper
level of flexibility for a model is known as model selection. The
bootstrap is widely used.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="why-resampling-methods">Why resampling methods ? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Statistical analysis</b>
<p>

<ul>
<li> Our simulations can be treated as <em>computer experiments</em>. This is particularly the case for Monte Carlo methods which are widely used in statistical analyses.</li>
<li> The results can be analysed with the same statistical tools as we would use when analysing experimental data.</li>
<li> As in all experiments, we are looking for expectation values and an estimate of how accurate they are, i.e., possible sources for errors.</li>
</ul>
</div>
    

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="statistical-analysis">Statistical analysis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<ul>
<li> As in other experiments, many numerical  experiments have two classes of errors:</li>
<ul>
  <li> Statistical errors</li>
  <li> Systematical errors</li>
</ul>
<li> Statistical errors can be estimated using standard tools from statistics</li>
<li> Systematical errors are method specific and must be treated differently from case to case.</li> 
</ul>
</div>
    

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="resampling-methods">Resampling methods </h2>

<p>With all these analytical equations for both the OLS and Ridge
regression, we will now outline how to assess a given model. This will
lead to a discussion of the so-called bias-variance tradeoff (see
below) and so-called resampling methods.
</p>

<p>One of the quantities we have discussed as a way to measure errors is
the mean-squared error (MSE), mainly used for fitting of continuous
functions. Another choice is the absolute error.
</p>

<p>In the discussions below we will focus on the MSE and in particular since we will split the data into test and training data,
we discuss the
</p>
<ol>
<li> prediction error or simply the <b>test error</b> \( \mathrm{Err_{Test}} \), where we have a fixed training set and the test error is the MSE arising from the data reserved for testing. We discuss also the</li> 
<li> training error \( \mathrm{Err_{Train}} \), which is the average loss over the training data.</li>
</ol>
<p>As our model becomes more and more complex, more of the training data tends to  used. The training may thence adapt to more complicated structures in the data. This may lead to a decrease in the bias (see below for code example) and a slight increase of the variance for the test error.
For a certain level of complexity the test error will reach minimum, before starting to increase again. The
training error reaches a saturation.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="resampling-methods-bootstrap">Resampling methods: Bootstrap </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Bootstrapping is a <a href="https://en.wikipedia.org/wiki/Nonparametric_statistics" target="_blank">non-parametric approach</a> to statistical inference
that substitutes computation for more traditional distributional
assumptions and asymptotic results. Bootstrapping offers a number of
advantages: 
</p>
<ol>
<li> The bootstrap is quite general, although there are some cases in which it fails.</li>  
<li> Because it does not require distributional assumptions (such as normally distributed errors), the bootstrap can provide more accurate inferences when the data are not well behaved or when the sample size is small.</li>  
<li> It is possible to apply the bootstrap to statistics with sampling distributions that are difficult to derive, even asymptotically.</li> 
<li> It is relatively simple to apply the bootstrap to complex data-collection plans (such as stratified and clustered samples).</li>
</ol>
</div>


<p>The textbook by <a href="https://www.cambridge.org/core/books/bootstrap-methods-and-their-application/ED2FD043579F27952363566DC09CBD6A" target="_blank">Davison on the Bootstrap Methods and their Applications</a> provides many more insights and proofs. In this course we will take a more practical approach and use the results and theorems provided in the literature. For those interested in reading more about the bootstrap methods, we recommend the above text and the one by <a href="https://www.routledge.com/An-Introduction-to-the-Bootstrap/Efron-Tibshirani/p/book/9780412042317" target="_blank">Efron and Tibshirani</a>.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-bias-variance-tradeoff">The bias-variance tradeoff </h2>

<p>We will discuss the bias-variance tradeoff in the context of
continuous predictions such as regression. However, many of the
intuitions and ideas discussed here also carry over to classification
tasks. Consider a dataset \( \mathcal{D} \) consisting of the data
\( \mathbf{X}_\mathcal{D}=\{(y_j, \boldsymbol{x}_j), j=0\ldots n-1\} \). 
</p>

<p>Let us assume that the true data is generated from a noisy model</p>

$$
\boldsymbol{y}=f(\boldsymbol{x}) + \boldsymbol{\epsilon}
$$

<p>where \( \epsilon \) is normally distributed with mean zero and standard deviation \( \sigma^2 \).</p>

<p>In our derivation of the ordinary least squares method we defined then
an approximation to the function \( f \) in terms of the parameters
\( \boldsymbol{\theta} \) and the design matrix \( \boldsymbol{X} \) which embody our model,
that is \( \boldsymbol{\tilde{y}}=\boldsymbol{X}\boldsymbol{\theta} \). 
</p>

<p>Thereafter we found the parameters \( \boldsymbol{\theta} \) by optimizing the means squared error via the so-called cost function</p>
$$
C(\boldsymbol{X},\boldsymbol{\theta}) =\frac{1}{n}\sum_{i=0}^{n-1}(y_i-\tilde{y}_i)^2=\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right].
$$

<p>We can rewrite this as </p>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\frac{1}{n}\sum_i(f_i-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2+\frac{1}{n}\sum_i(\tilde{y}_i-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2+\sigma^2.
$$

<p>The three terms represent the square of the bias of the learning
method, which can be thought of as the error caused by the simplifying
assumptions built into the method. The second term represents the
variance of the chosen model and finally the last terms is variance of
the error \( \boldsymbol{\epsilon} \).
</p>

<p>To derive this equation, we need to recall that the variance of \( \boldsymbol{y} \) and \( \boldsymbol{\epsilon} \) are both equal to \( \sigma^2 \). The mean value of \( \boldsymbol{\epsilon} \) is by definition equal to zero. Furthermore, the function \( f \) is not a stochastics variable, idem for \( \boldsymbol{\tilde{y}} \).
We use a more compact notation in terms of the expectation value 
</p>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\mathbb{E}\left[(\boldsymbol{f}+\boldsymbol{\epsilon}-\boldsymbol{\tilde{y}})^2\right],
$$

<p>and adding and subtracting \( \mathbb{E}\left[\boldsymbol{\tilde{y}}\right] \) we get</p>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\mathbb{E}\left[(\boldsymbol{f}+\boldsymbol{\epsilon}-\boldsymbol{\tilde{y}}+\mathbb{E}\left[\boldsymbol{\tilde{y}}\right]-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2\right],
$$

<p>which, using the abovementioned expectation values can be rewritten as </p>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\mathbb{E}\left[(\boldsymbol{y}-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2\right]+\mathrm{Var}\left[\boldsymbol{\tilde{y}}\right]+\sigma^2,
$$

<p>that is the rewriting in terms of the so-called bias, the variance of the model \( \boldsymbol{\tilde{y}} \) and the variance of \( \boldsymbol{\epsilon} \).</p>

<b>Note that in order to derive these equations we have assumed we can replace the unknown function \( \boldsymbol{f} \) with the target/output data \( \boldsymbol{y} \).</b>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="a-way-to-read-the-bias-variance-tradeoff">A way to Read the Bias-Variance Tradeoff </h2>

<br/><br/>
<center>
<p><img src="figures/BiasVariance.png" width="600" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="understanding-what-happens">Understanding what happens </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.pipeline</span> <span style="color: #8B008B; font-weight: bold">import</span> make_pipeline
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> resample

np.random.seed(<span style="color: #B452CD">2018</span>)

n = <span style="color: #B452CD">40</span>
n_boostraps = <span style="color: #B452CD">100</span>
maxdegree = <span style="color: #B452CD">14</span>


<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n).reshape(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
y = np.exp(-x**<span style="color: #B452CD">2</span>) + <span style="color: #B452CD">1.5</span> * np.exp(-(x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>)+ np.random.normal(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.1</span>, x.shape)
error = np.zeros(maxdegree)
bias = np.zeros(maxdegree)
variance = np.zeros(maxdegree)
polydegree = np.zeros(maxdegree)
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span style="color: #B452CD">0.2</span>)

<span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(maxdegree):
    model = make_pipeline(PolynomialFeatures(degree=degree), LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>))
    y_pred = np.empty((y_test.shape[<span style="color: #B452CD">0</span>], n_boostraps))
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n_boostraps):
        x_, y_ = resample(x_train, y_train)
        y_pred[:, i] = model.fit(x_, y_).predict(x_test).ravel()

    polydegree[degree] = degree
    error[degree] = np.mean( np.mean((y_test - y_pred)**<span style="color: #B452CD">2</span>, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>) )
    bias[degree] = np.mean( (y_test - np.mean(y_pred, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>))**<span style="color: #B452CD">2</span> )
    variance[degree] = np.mean( np.var(y_pred, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>) )
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Polynomial degree:&#39;</span>, degree)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Error:&#39;</span>, error[degree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Bias^2:&#39;</span>, bias[degree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Var:&#39;</span>, variance[degree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;{} &gt;= {} + {} = {}&#39;</span>.format(error[degree], bias[degree], variance[degree], bias[degree]+variance[degree]))

plt.plot(polydegree, error, label=<span style="color: #CD5555">&#39;Error&#39;</span>)
plt.plot(polydegree, bias, label=<span style="color: #CD5555">&#39;bias&#39;</span>)
plt.plot(polydegree, variance, label=<span style="color: #CD5555">&#39;Variance&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split  -->
<h2 id="summing-up">Summing up </h2>

<p>The bias-variance tradeoff summarizes the fundamental tension in
machine learning, particularly supervised learning, between the
complexity of a model and the amount of training data needed to train
it.  Since data is often limited, in practice it is often useful to
use a less-complex model with higher bias, that is  a model whose asymptotic
performance is worse than another model because it is easier to
train and less sensitive to sampling noise arising from having a
finite-sized training dataset (smaller variance). 
</p>

<p>The above equations tell us that in
order to minimize the expected test error, we need to select a
statistical learning method that simultaneously achieves low variance
and low bias. Note that variance is inherently a nonnegative quantity,
and squared bias is also nonnegative. Hence, we see that the expected
test MSE can never lie below \( Var(\epsilon) \), the irreducible error.
</p>

<p>What do we mean by the variance and bias of a statistical learning
method? The variance refers to the amount by which our model would change if we
estimated it using a different training data set. Since the training
data are used to fit the statistical learning method, different
training data sets  will result in a different estimate. But ideally the
estimate for our model should not vary too much between training
sets. However, if a method has high variance  then small changes in
the training data can result in large changes in the model. In general, more
flexible statistical methods have higher variance.
</p>

<p>You may also find this recent <a href="https://www.pnas.org/content/116/32/15849" target="_blank">article</a> of interest.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="another-example-from-scikit-learn-s-repository">Another Example from Scikit-Learn's Repository </h2>

<p>This example demonstrates the problems of underfitting and overfitting and
how we can use linear regression with polynomial features to approximate
nonlinear functions. The plot shows the function that we want to approximate,
which is a part of the cosine function. In addition, the samples from the
real function and the approximations of different models are displayed. The
models have polynomial features of different degrees. We can see that a
linear function (polynomial with degree 1) is not sufficient to fit the
training samples. This is called <b>underfitting</b>. A polynomial of degree 4
approximates the true function almost perfectly. However, for higher degrees
the model will <b>overfit</b> the training data, i.e. it learns the noise of the
training data.
We evaluate quantitatively overfitting and underfitting by using
cross-validation. We calculate the mean squared error (MSE) on the validation
set, the higher, the less likely the model generalizes correctly from the
training data.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22">#print(__doc__)</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.pipeline</span> <span style="color: #8B008B; font-weight: bold">import</span> Pipeline
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> cross_val_score


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">true_fun</span>(X):
    <span style="color: #8B008B; font-weight: bold">return</span> np.cos(<span style="color: #B452CD">1.5</span> * np.pi * X)

np.random.seed(<span style="color: #B452CD">0</span>)

n_samples = <span style="color: #B452CD">30</span>
degrees = [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">4</span>, <span style="color: #B452CD">15</span>]

X = np.sort(np.random.rand(n_samples))
y = true_fun(X) + np.random.randn(n_samples) * <span style="color: #B452CD">0.1</span>

plt.figure(figsize=(<span style="color: #B452CD">14</span>, <span style="color: #B452CD">5</span>))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(degrees)):
    ax = plt.subplot(<span style="color: #B452CD">1</span>, <span style="color: #658b00">len</span>(degrees), i + <span style="color: #B452CD">1</span>)
    plt.setp(ax, xticks=(), yticks=())

    polynomial_features = PolynomialFeatures(degree=degrees[i],
                                             include_bias=<span style="color: #8B008B; font-weight: bold">False</span>)
    linear_regression = LinearRegression()
    pipeline = Pipeline([(<span style="color: #CD5555">&quot;polynomial_features&quot;</span>, polynomial_features),
                         (<span style="color: #CD5555">&quot;linear_regression&quot;</span>, linear_regression)])
    pipeline.fit(X[:, np.newaxis], y)

    <span style="color: #228B22"># Evaluate the models using crossvalidation</span>
    scores = cross_val_score(pipeline, X[:, np.newaxis], y,
                             scoring=<span style="color: #CD5555">&quot;neg_mean_squared_error&quot;</span>, cv=<span style="color: #B452CD">10</span>)

    X_test = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">100</span>)
    plt.plot(X_test, pipeline.predict(X_test[:, np.newaxis]), label=<span style="color: #CD5555">&quot;Model&quot;</span>)
    plt.plot(X_test, true_fun(X_test), label=<span style="color: #CD5555">&quot;True function&quot;</span>)
    plt.scatter(X, y, edgecolor=<span style="color: #CD5555">&#39;b&#39;</span>, s=<span style="color: #B452CD">20</span>, label=<span style="color: #CD5555">&quot;Samples&quot;</span>)
    plt.xlabel(<span style="color: #CD5555">&quot;x&quot;</span>)
    plt.ylabel(<span style="color: #CD5555">&quot;y&quot;</span>)
    plt.xlim((<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>))
    plt.ylim((-<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>))
    plt.legend(loc=<span style="color: #CD5555">&quot;best&quot;</span>)
    plt.title(<span style="color: #CD5555">&quot;Degree {}\nMSE = {:.2e}(+/- {:.2e})&quot;</span>.format(
        degrees[i], -scores.mean(), scores.std()))
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split  -->
<h2 id="various-steps-in-cross-validation">Various steps in cross-validation </h2>

<p>When the repetitive splitting of the data set is done randomly,
samples may accidently end up in a fast majority of the splits in
either training or test set. Such samples may have an unbalanced
influence on either model building or prediction evaluation. To avoid
this \( k \)-fold cross-validation structures the data splitting. The
samples are divided into \( k \) more or less equally sized exhaustive and
mutually exclusive subsets. In turn (at each split) one of these
subsets plays the role of the test set while the union of the
remaining subsets constitutes the training set. Such a splitting
warrants a balanced representation of each sample in both training and
test set over the splits. Still the division into the \( k \) subsets
involves a degree of randomness. This may be fully excluded when
choosing \( k=n \). This particular case is referred to as leave-one-out
cross-validation (LOOCV). 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="cross-validation-in-brief">Cross-validation in brief </h2>

<p>For the various values of \( k \)</p>

<ol>
<li> shuffle the dataset randomly.</li>
<li> Split the dataset into \( k \) groups.</li>
<li> For each unique group:
<ol type="a"></li>
<li> Decide which group to use as set for test data</li>
<li> Take the remaining groups as a training data set</li>
<li> Fit a model on the training set and evaluate it on the test set</li>
<li> Retain the evaluation score and discard the model</li>
</ol>
<li> Summarize the model using the sample of model evaluation scores</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="code-example-for-cross-validation-and-k-fold-cross-validation">Code Example for Cross-validation and \( k \)-fold Cross-validation </h2>

<p>The code here uses Ridge regression with cross-validation (CV)  resampling and \( k \)-fold CV in order to fit a specific polynomial. </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> KFold
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> Ridge
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> cross_val_score
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures

<span style="color: #228B22"># A seed just to ensure that the random numbers are the same for every run.</span>
<span style="color: #228B22"># Useful for eventual debugging.</span>
np.random.seed(<span style="color: #B452CD">3155</span>)

<span style="color: #228B22"># Generate the data.</span>
nsamples = <span style="color: #B452CD">100</span>
x = np.random.randn(nsamples)
y = <span style="color: #B452CD">3</span>*x**<span style="color: #B452CD">2</span> + np.random.randn(nsamples)

<span style="color: #228B22">## Cross-validation on Ridge regression using KFold only</span>

<span style="color: #228B22"># Decide degree on polynomial to fit</span>
poly = PolynomialFeatures(degree = <span style="color: #B452CD">6</span>)

<span style="color: #228B22"># Decide which values of lambda to use</span>
nlambdas = <span style="color: #B452CD">500</span>
lambdas = np.logspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">5</span>, nlambdas)

<span style="color: #228B22"># Initialize a KFold instance</span>
k = <span style="color: #B452CD">5</span>
kfold = KFold(n_splits = k)

<span style="color: #228B22"># Perform the cross-validation to estimate MSE</span>
scores_KFold = np.zeros((nlambdas, k))

i = <span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> lmb <span style="color: #8B008B">in</span> lambdas:
    ridge = Ridge(alpha = lmb)
    j = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> train_inds, test_inds <span style="color: #8B008B">in</span> kfold.split(x):
        xtrain = x[train_inds]
        ytrain = y[train_inds]

        xtest = x[test_inds]
        ytest = y[test_inds]

        Xtrain = poly.fit_transform(xtrain[:, np.newaxis])
        ridge.fit(Xtrain, ytrain[:, np.newaxis])

        Xtest = poly.fit_transform(xtest[:, np.newaxis])
        ypred = ridge.predict(Xtest)

        scores_KFold[i,j] = np.sum((ypred - ytest[:, np.newaxis])**<span style="color: #B452CD">2</span>)/np.size(ypred)

        j += <span style="color: #B452CD">1</span>
    i += <span style="color: #B452CD">1</span>


estimated_mse_KFold = np.mean(scores_KFold, axis = <span style="color: #B452CD">1</span>)

<span style="color: #228B22">## Cross-validation using cross_val_score from sklearn along with KFold</span>

<span style="color: #228B22"># kfold is an instance initialized above as:</span>
<span style="color: #228B22"># kfold = KFold(n_splits = k)</span>

estimated_mse_sklearn = np.zeros(nlambdas)
i = <span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> lmb <span style="color: #8B008B">in</span> lambdas:
    ridge = Ridge(alpha = lmb)

    X = poly.fit_transform(x[:, np.newaxis])
    estimated_mse_folds = cross_val_score(ridge, X, y[:, np.newaxis], scoring=<span style="color: #CD5555">&#39;neg_mean_squared_error&#39;</span>, cv=kfold)

    <span style="color: #228B22"># cross_val_score return an array containing the estimated negative mse for every fold.</span>
    <span style="color: #228B22"># we have to the the mean of every array in order to get an estimate of the mse of the model</span>
    estimated_mse_sklearn[i] = np.mean(-estimated_mse_folds)

    i += <span style="color: #B452CD">1</span>

<span style="color: #228B22">## Plot and compare the slightly different ways to perform cross-validation</span>

plt.figure()

plt.plot(np.log10(lambdas), estimated_mse_sklearn, label = <span style="color: #CD5555">&#39;cross_val_score&#39;</span>)
<span style="color: #228B22">#plt.plot(np.log10(lambdas), estimated_mse_KFold, &#39;r--&#39;, label = &#39;KFold&#39;)</span>

plt.xlabel(<span style="color: #CD5555">&#39;log10(lambda)&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;mse&#39;</span>)

plt.legend()

plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-examples-on-bootstrap-and-cross-validation-and-errors">More examples on bootstrap and cross-validation and errors </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> resample
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

infile = <span style="color: #658b00">open</span>(data_path(<span style="color: #CD5555">&quot;EoS.csv&quot;</span>),<span style="color: #CD5555">&#39;r&#39;</span>)

<span style="color: #228B22"># Read the EoS data as  csv file and organize the data into two arrays with density and energies</span>
EoS = pd.read_csv(infile, names=(<span style="color: #CD5555">&#39;Density&#39;</span>, <span style="color: #CD5555">&#39;Energy&#39;</span>))
EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>] = pd.to_numeric(EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>], errors=<span style="color: #CD5555">&#39;coerce&#39;</span>)
EoS = EoS.dropna()
Energies = EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>]
Density = EoS[<span style="color: #CD5555">&#39;Density&#39;</span>]
<span style="color: #228B22">#  The design matrix now as function of various polytrops</span>

Maxpolydegree = <span style="color: #B452CD">30</span>
X = np.zeros((<span style="color: #658b00">len</span>(Density),Maxpolydegree))
X[:,<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1.0</span>
testerror = np.zeros(Maxpolydegree)
trainingerror = np.zeros(Maxpolydegree)
polynomial = np.zeros(Maxpolydegree)

trials = <span style="color: #B452CD">100</span>
<span style="color: #8B008B; font-weight: bold">for</span> polydegree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Maxpolydegree):
    polynomial[polydegree] = polydegree
    <span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(polydegree):
        X[:,degree] = Density**(degree/<span style="color: #B452CD">3.0</span>)

<span style="color: #228B22"># loop over trials in order to estimate the expectation value of the MSE</span>
    testerror[polydegree] = <span style="color: #B452CD">0.0</span>
    trainingerror[polydegree] = <span style="color: #B452CD">0.0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> samples <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(trials):
        x_train, x_test, y_train, y_test = train_test_split(X, Energies, test_size=<span style="color: #B452CD">0.2</span>)
        model = LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>).fit(x_train, y_train)
        ypred = model.predict(x_train)
        ytilde = model.predict(x_test)
        testerror[polydegree] += mean_squared_error(y_test, ytilde)
        trainingerror[polydegree] += mean_squared_error(y_train, ypred) 

    testerror[polydegree] /= trials
    trainingerror[polydegree] /= trials
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Degree of polynomial: %3d&quot;</span>% polynomial[polydegree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Mean squared error on training data: %.8f&quot;</span> % trainingerror[polydegree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Mean squared error on test data: %.8f&quot;</span> % testerror[polydegree])

plt.plot(polynomial, np.log10(trainingerror), label=<span style="color: #CD5555">&#39;Training Error&#39;</span>)
plt.plot(polynomial, np.log10(testerror), label=<span style="color: #CD5555">&#39;Test Error&#39;</span>)
plt.xlabel(<span style="color: #CD5555">&#39;Polynomial degree&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;log10[MSE]&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that we kept the intercept column in the fitting here. This means that we need to set the <b>intercept</b> in the call to the <b>Scikit-Learn</b> function as <b>False</b>. Alternatively, we could have set up the design matrix \( X \) without the first column of ones.</p>

<!-- !split  -->
<h2 id="the-same-example-but-now-with-cross-validation">The same example but now with cross-validation </h2>

<p>In this example we keep the intercept column again but add cross-validation in order to estimate the best possible value of the means squared error.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> KFold
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> cross_val_score


<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

infile = <span style="color: #658b00">open</span>(data_path(<span style="color: #CD5555">&quot;EoS.csv&quot;</span>),<span style="color: #CD5555">&#39;r&#39;</span>)

<span style="color: #228B22"># Read the EoS data as  csv file and organize the data into two arrays with density and energies</span>
EoS = pd.read_csv(infile, names=(<span style="color: #CD5555">&#39;Density&#39;</span>, <span style="color: #CD5555">&#39;Energy&#39;</span>))
EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>] = pd.to_numeric(EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>], errors=<span style="color: #CD5555">&#39;coerce&#39;</span>)
EoS = EoS.dropna()
Energies = EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>]
Density = EoS[<span style="color: #CD5555">&#39;Density&#39;</span>]
<span style="color: #228B22">#  The design matrix now as function of various polytrops</span>

Maxpolydegree = <span style="color: #B452CD">30</span>
X = np.zeros((<span style="color: #658b00">len</span>(Density),Maxpolydegree))
X[:,<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1.0</span>
estimated_mse_sklearn = np.zeros(Maxpolydegree)
polynomial = np.zeros(Maxpolydegree)
k =<span style="color: #B452CD">5</span>
kfold = KFold(n_splits = k)

<span style="color: #8B008B; font-weight: bold">for</span> polydegree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Maxpolydegree):
    polynomial[polydegree] = polydegree
    <span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(polydegree):
        X[:,degree] = Density**(degree/<span style="color: #B452CD">3.0</span>)
        OLS = LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>)
<span style="color: #228B22"># loop over trials in order to estimate the expectation value of the MSE</span>
    estimated_mse_folds = cross_val_score(OLS, X, Energies, scoring=<span style="color: #CD5555">&#39;neg_mean_squared_error&#39;</span>, cv=kfold)
<span style="color: #228B22">#[:, np.newaxis]</span>
    estimated_mse_sklearn[polydegree] = np.mean(-estimated_mse_folds)

plt.plot(polynomial, np.log10(estimated_mse_sklearn), label=<span style="color: #CD5555">&#39;Test Error&#39;</span>)
plt.xlabel(<span style="color: #CD5555">&#39;Polynomial degree&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;log10[MSE]&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split  -->
<h2 id="logistic-regression">Logistic Regression </h2>

<p>In linear regression our main interest was centered on learning the
coefficients of a functional fit (say a polynomial) in order to be
able to predict the response of a continuous variable on some unseen
data. The fit to the continuous variable \( y_i \) is based on some
independent variables \( \boldsymbol{x}_i \). Linear regression resulted in
analytical expressions for standard ordinary Least Squares or Ridge
regression (in terms of matrices to invert) for several quantities,
ranging from the variance and thereby the confidence intervals of the
parameters \( \boldsymbol{\theta} \) to the mean squared error. If we can invert
the product of the design matrices, linear regression gives then a
simple recipe for fitting our data.
</p>

<!-- !split  -->
<h2 id="classification-problems">Classification problems </h2>

<p>Classification problems, however, are concerned with outcomes taking
the form of discrete variables (i.e. categories). We may for example,
on the basis of DNA sequencing for a number of patients, like to find
out which mutations are important for a certain disease; or based on
scans of various patients' brains, figure out if there is a tumor or
not; or given a specific physical system, we'd like to identify its
state, say whether it is an ordered or disordered system (typical
situation in solid state physics); or classify the status of a
patient, whether she/he has a stroke or not and many other similar
situations.
</p>

<p>The most common situation we encounter when we apply logistic
regression is that of two possible outcomes, normally denoted as a
binary outcome, true or false, positive or negative, success or
failure etc.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimization-and-deep-learning">Optimization and Deep learning </h2>

<p>Logistic regression will also serve as our stepping stone towards
neural network algorithms and supervised deep learning. For logistic
learning, the minimization of the cost function leads to a non-linear
equation in the parameters \( \boldsymbol{\theta} \). The optimization of the
problem calls therefore for minimization algorithms. This forms the
bottle neck of all machine learning algorithms, namely how to find
reliable minima of a multi-variable function. This leads us to the
family of gradient descent methods. The latter are the working horses
of basically all modern machine learning algorithms.
</p>

<p>We note also that many of the topics discussed here on logistic 
regression are also commonly used in modern supervised Deep Learning
models, as we will see later.
</p>

<!-- !split  -->
<h2 id="basics">Basics </h2>

<p>We consider the case where the outputs/targets, also called the
responses or the outcomes, \( y_i \) are discrete and only take values
from \( k=0,\dots,K-1 \) (i.e. \( K \) classes).
</p>

<p>The goal is to predict the
output classes from the design matrix \( \boldsymbol{X}\in\mathbb{R}^{n\times p} \)
made of \( n \) samples, each of which carries \( p \) features or predictors. The
primary goal is to identify the classes to which new unseen samples
belong.
</p>

<p>Let us specialize to the case of two classes only, with outputs
\( y_i=0 \) and \( y_i=1 \). Our outcomes could represent the status of a
credit card user that could default or not on her/his credit card
debt. That is
</p>

$$
y_i = \begin{bmatrix} 0 & \mathrm{no}\\  1 & \mathrm{yes} \end{bmatrix}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="linear-classifier">Linear classifier </h2>

<p>Before moving to the logistic model, let us try to use our linear
regression model to classify these two outcomes. We could for example
fit a linear model to the default case if \( y_i > 0.5 \) and the no
default case \( y_i \leq 0.5 \).
</p>

<p>We would then have our 
weighted linear combination, namely 
</p>
$$
\begin{equation}
\boldsymbol{y} = \boldsymbol{X}^T\boldsymbol{\theta} +  \boldsymbol{\epsilon},
\label{_auto1}
\end{equation}
$$

<p>where \( \boldsymbol{y} \) is a vector representing the possible outcomes, \( \boldsymbol{X} \) is our
\( n\times p \) design matrix and \( \boldsymbol{\theta} \) represents our estimators/predictors.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="some-selected-properties">Some selected properties </h2>

<p>The main problem with our function is that it takes values on the
entire real axis. In the case of logistic regression, however, the
labels \( y_i \) are discrete variables. A typical example is the credit
card data discussed below here, where we can set the state of
defaulting the debt to \( y_i=1 \) and not to \( y_i=0 \) for one the persons
in the data set (see the full example below).
</p>

<p>One simple way to get a discrete output is to have sign
functions that map the output of a linear regressor to values \( \{0,1\} \),
\( f(s_i)=sign(s_i)=1 \) if \( s_i\ge 0 \) and 0 if otherwise. 
We will encounter this model in our first demonstration of neural networks.
</p>

<p>Historically it is called the <b>perceptron</b> model in the machine learning
literature. This model is extremely simple. However, in many cases it is more
favorable to use a ``soft" classifier that outputs
the probability of a given category. This leads us to the logistic function.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="simple-example">Simple example </h2>

<p>The following example on data for coronary heart disease (CHD) as function of age may serve as an illustration. In the code here we read and plot whether a person has had CHD (output = 1) or not (output = 0). This ouput  is plotted the person's against age. Clearly, the figure shows that attempting to make a standard linear regression fit may not be very meaningful.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> resample
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">IPython.display</span> <span style="color: #8B008B; font-weight: bold">import</span> display
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">pylab</span> <span style="color: #8B008B; font-weight: bold">import</span> plt, mpl
mpl.rcParams[<span style="color: #CD5555">&#39;font.family&#39;</span>] = <span style="color: #CD5555">&#39;serif&#39;</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

infile = <span style="color: #658b00">open</span>(data_path(<span style="color: #CD5555">&quot;chddata.csv&quot;</span>),<span style="color: #CD5555">&#39;r&#39;</span>)

<span style="color: #228B22"># Read the chd data as  csv file and organize the data into arrays with age group, age, and chd</span>
chd = pd.read_csv(infile, names=(<span style="color: #CD5555">&#39;ID&#39;</span>, <span style="color: #CD5555">&#39;Age&#39;</span>, <span style="color: #CD5555">&#39;Agegroup&#39;</span>, <span style="color: #CD5555">&#39;CHD&#39;</span>))
chd.columns = [<span style="color: #CD5555">&#39;ID&#39;</span>, <span style="color: #CD5555">&#39;Age&#39;</span>, <span style="color: #CD5555">&#39;Agegroup&#39;</span>, <span style="color: #CD5555">&#39;CHD&#39;</span>]
output = chd[<span style="color: #CD5555">&#39;CHD&#39;</span>]
age = chd[<span style="color: #CD5555">&#39;Age&#39;</span>]
agegroup = chd[<span style="color: #CD5555">&#39;Agegroup&#39;</span>]
numberID  = chd[<span style="color: #CD5555">&#39;ID&#39;</span>] 
display(chd)

plt.scatter(age, output, marker=<span style="color: #CD5555">&#39;o&#39;</span>)
plt.axis([<span style="color: #B452CD">18</span>,<span style="color: #B452CD">70.0</span>,-<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">1.2</span>])
plt.xlabel(<span style="color: #CD5555">r&#39;Age&#39;</span>)
plt.ylabel(<span style="color: #CD5555">r&#39;CHD&#39;</span>)
plt.title(<span style="color: #CD5555">r&#39;Age distribution and Coronary heart disease&#39;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plotting-the-mean-value-for-each-group">Plotting the mean value for each group </h2>

<p>What we could attempt however is to plot the mean value for each group.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">agegroupmean = np.array([<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.133</span>, <span style="color: #B452CD">0.250</span>, <span style="color: #B452CD">0.333</span>, <span style="color: #B452CD">0.462</span>, <span style="color: #B452CD">0.625</span>, <span style="color: #B452CD">0.765</span>, <span style="color: #B452CD">0.800</span>])
group = np.array([<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">6</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">8</span>])
plt.plot(group, agegroupmean, <span style="color: #CD5555">&quot;r-&quot;</span>)
plt.axis([<span style="color: #B452CD">0</span>,<span style="color: #B452CD">9</span>,<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1.0</span>])
plt.xlabel(<span style="color: #CD5555">r&#39;Age group&#39;</span>)
plt.ylabel(<span style="color: #CD5555">r&#39;CHD mean values&#39;</span>)
plt.title(<span style="color: #CD5555">r&#39;Mean values for each age group&#39;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We are now trying to find a function \( f(y\vert x) \), that is a function which gives us an expected value for the output \( y \) with a given input \( x \).
In standard linear regression with a linear dependence on \( x \), we would write this in terms of our model
</p>
$$
f(y_i\vert x_i)=\theta_0+\theta_1 x_i.
$$

<p>This expression implies however that \( f(y_i\vert x_i) \) could take any
value from minus infinity to plus infinity. If we however let
\( f(y\vert y) \) be represented by the mean value, the above example
shows us that we can constrain the function to take values between
zero and one, that is we have \( 0 \le f(y_i\vert x_i) \le 1 \). Looking
at our last curve we see also that it has an S-shaped form. This leads
us to a very popular model for the function \( f \), namely the so-called
Sigmoid function or logistic model. We will consider this function as
representing the probability for finding a value of \( y_i \) with a given
\( x_i \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-logistic-function">The logistic function </h2>

<p>Another widely studied model, is the so-called 
perceptron model, which is an example of a &quot;hard classification&quot; model. We
will encounter this model when we discuss neural networks as
well. Each datapoint is deterministically assigned to a category (i.e
\( y_i=0 \) or \( y_i=1 \)). In many cases, and the coronary heart disease data forms one of many such examples, it is favorable to have a &quot;soft&quot;
classifier that outputs the probability of a given category rather
than a single value. For example, given \( x_i \), the classifier
outputs the probability of being in a category \( k \).  Logistic regression
is the most common example of a so-called soft classifier. In logistic
regression, the probability that a data point \( x_i \)
belongs to a category \( y_i=\{0,1\} \) is given by the so-called logit function (or Sigmoid) which is meant to represent the likelihood for a given event, 
</p>
$$
p(t) = \frac{1}{1+\mathrm \exp{-t}}=\frac{\exp{t}}{1+\mathrm \exp{t}}.
$$

<p>Note that \( 1-p(t)= p(-t) \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="examples-of-likelihood-functions-used-in-logistic-regression-and-nueral-networks">Examples of likelihood functions used in logistic regression and nueral networks </h2>

<p>The following code plots the logistic function, the step function and other functions we will encounter from here and on.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #CD5555">&quot;&quot;&quot;The sigmoid function (or the logistic curve) is a</span>
<span style="color: #CD5555">function that takes any real number, z, and outputs a number (0,1).</span>
<span style="color: #CD5555">It is useful in neural networks for assigning weights on a relative scale.</span>
<span style="color: #CD5555">The value z is the weighted sum of parameters involved in the learning algorithm.&quot;&quot;&quot;</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">mt</span>

z = numpy.arange(-<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">.1</span>)
sigma_fn = numpy.vectorize(<span style="color: #8B008B; font-weight: bold">lambda</span> z: <span style="color: #B452CD">1</span>/(<span style="color: #B452CD">1</span>+numpy.exp(-z)))
sigma = sigma_fn(z)

fig = plt.figure()
ax = fig.add_subplot(<span style="color: #B452CD">111</span>)
ax.plot(z, sigma)
ax.set_ylim([-<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">1.1</span>])
ax.set_xlim([-<span style="color: #B452CD">5</span>,<span style="color: #B452CD">5</span>])
ax.grid(<span style="color: #8B008B; font-weight: bold">True</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;z&#39;</span>)
ax.set_title(<span style="color: #CD5555">&#39;sigmoid function&#39;</span>)

plt.show()

<span style="color: #CD5555">&quot;&quot;&quot;Step Function&quot;&quot;&quot;</span>
z = numpy.arange(-<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">.02</span>)
step_fn = numpy.vectorize(<span style="color: #8B008B; font-weight: bold">lambda</span> z: <span style="color: #B452CD">1.0</span> <span style="color: #8B008B; font-weight: bold">if</span> z &gt;= <span style="color: #B452CD">0.0</span> <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0.0</span>)
step = step_fn(z)

fig = plt.figure()
ax = fig.add_subplot(<span style="color: #B452CD">111</span>)
ax.plot(z, step)
ax.set_ylim([-<span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1.5</span>])
ax.set_xlim([-<span style="color: #B452CD">5</span>,<span style="color: #B452CD">5</span>])
ax.grid(<span style="color: #8B008B; font-weight: bold">True</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;z&#39;</span>)
ax.set_title(<span style="color: #CD5555">&#39;step function&#39;</span>)

plt.show()

<span style="color: #CD5555">&quot;&quot;&quot;tanh Function&quot;&quot;&quot;</span>
z = numpy.arange(-<span style="color: #B452CD">2</span>*mt.pi, <span style="color: #B452CD">2</span>*mt.pi, <span style="color: #B452CD">0.1</span>)
t = numpy.tanh(z)

fig = plt.figure()
ax = fig.add_subplot(<span style="color: #B452CD">111</span>)
ax.plot(z, t)
ax.set_ylim([-<span style="color: #B452CD">1.0</span>, <span style="color: #B452CD">1.0</span>])
ax.set_xlim([-<span style="color: #B452CD">2</span>*mt.pi,<span style="color: #B452CD">2</span>*mt.pi])
ax.grid(<span style="color: #8B008B; font-weight: bold">True</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;z&#39;</span>)
ax.set_title(<span style="color: #CD5555">&#39;tanh function&#39;</span>)

plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="two-parameters">Two parameters </h2>

<p>We assume now that we have two classes with \( y_i \) either \( 0 \) or \( 1 \). Furthermore we assume also that we have only two parameters \( \theta \) in our fitting of the Sigmoid function, that is we define probabilities </p>
$$
\begin{align*}
p(y_i=1|x_i,\boldsymbol{\theta}) &= \frac{\exp{(\theta_0+\theta_1x_i)}}{1+\exp{(\theta_0+\theta_1x_i)}},\nonumber\\
p(y_i=0|x_i,\boldsymbol{\theta}) &= 1 - p(y_i=1|x_i,\boldsymbol{\theta}),
\end{align*}
$$

<p>where \( \boldsymbol{\theta} \) are the weights we wish to extract from data, in our case \( \theta_0 \) and \( \theta_1 \). </p>

<p>Note that we used</p>
$$
p(y_i=0\vert x_i, \boldsymbol{\theta}) = 1-p(y_i=1\vert x_i, \boldsymbol{\theta}).
$$


<!-- !split  -->
<h2 id="maximum-likelihood">Maximum likelihood </h2>

<p>In order to define the total likelihood for all possible outcomes from a  
dataset \( \mathcal{D}=\{(y_i,x_i)\} \), with the binary labels
\( y_i\in\{0,1\} \) and where the data points are drawn independently, we use the so-called <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation" target="_blank">Maximum Likelihood Estimation</a> (MLE) principle. 
We aim thus at maximizing 
the probability of seeing the observed data. We can then approximate the 
likelihood in terms of the product of the individual probabilities of a specific outcome \( y_i \), that is 
</p>
$$
\begin{align*}
P(\mathcal{D}|\boldsymbol{\theta})& = \prod_{i=1}^n \left[p(y_i=1|x_i,\boldsymbol{\theta})\right]^{y_i}\left[1-p(y_i=1|x_i,\boldsymbol{\theta}))\right]^{1-y_i}\nonumber \\
\end{align*}
$$

<p>from which we obtain the log-likelihood and our <b>cost/loss</b> function</p>
$$
\mathcal{C}(\boldsymbol{\theta}) = \sum_{i=1}^n \left( y_i\log{p(y_i=1|x_i,\boldsymbol{\theta})} + (1-y_i)\log\left[1-p(y_i=1|x_i,\boldsymbol{\theta}))\right]\right).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-cost-function-rewritten">The cost function rewritten </h2>

<p>Reordering the logarithms, we can rewrite the <b>cost/loss</b> function as</p>
$$
\mathcal{C}(\boldsymbol{\theta}) = \sum_{i=1}^n  \left(y_i(\theta_0+\theta_1x_i) -\log{(1+\exp{(\theta_0+\theta_1x_i)})}\right).
$$

<p>The maximum likelihood estimator is defined as the set of parameters that maximize the log-likelihood where we maximize with respect to \( \theta \).
Since the cost (error) function is just the negative log-likelihood, for logistic regression we have that
</p>
$$
\mathcal{C}(\boldsymbol{\theta})=-\sum_{i=1}^n  \left(y_i(\theta_0+\theta_1x_i) -\log{(1+\exp{(\theta_0+\theta_1x_i)})}\right).
$$

<p>This equation is known in statistics as the <b>cross entropy</b>. Finally, we note that just as in linear regression, 
in practice we often supplement the cross-entropy with additional regularization terms, usually \( L_1 \) and \( L_2 \) regularization as we did for Ridge and Lasso regression.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="minimizing-the-cross-entropy">Minimizing the cross entropy </h2>

<p>The cross entropy is a convex function of the weights \( \boldsymbol{\theta} \) and,
therefore, any local minimizer is a global minimizer. 
</p>

<p>Minimizing this
cost function with respect to the two parameters \( \theta_0 \) and \( \theta_1 \) we obtain
</p>

$$
\frac{\partial \mathcal{C}(\boldsymbol{\theta})}{\partial \theta_0} = -\sum_{i=1}^n  \left(y_i -\frac{\exp{(\theta_0+\theta_1x_i)}}{1+\exp{(\theta_0+\theta_1x_i)}}\right),
$$

<p>and </p>
$$
\frac{\partial \mathcal{C}(\boldsymbol{\theta})}{\partial \theta_1} = -\sum_{i=1}^n  \left(y_ix_i -x_i\frac{\exp{(\theta_0+\theta_1x_i)}}{1+\exp{(\theta_0+\theta_1x_i)}}\right).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="a-more-compact-expression">A more compact expression </h2>

<p>Let us now define a vector \( \boldsymbol{y} \) with \( n \) elements \( y_i \), an
\( n\times p \) matrix \( \boldsymbol{X} \) which contains the \( x_i \) values and a
vector \( \boldsymbol{p} \) of fitted probabilities \( p(y_i\vert x_i,\boldsymbol{\theta}) \). We can rewrite in a more compact form the first
derivative of the cost function as
</p>

$$
\frac{\partial \mathcal{C}(\boldsymbol{\theta})}{\partial \boldsymbol{\theta}} = -\boldsymbol{X}^T\left(\boldsymbol{y}-\boldsymbol{p}\right). 
$$

<p>If we in addition define a diagonal matrix \( \boldsymbol{W} \) with elements 
\( p(y_i\vert x_i,\boldsymbol{\theta})(1-p(y_i\vert x_i,\boldsymbol{\theta}) \), we can obtain a compact expression of the second derivative as 
</p>

$$
\frac{\partial^2 \mathcal{C}(\boldsymbol{\theta})}{\partial \boldsymbol{\theta}\partial \boldsymbol{\theta}^T} = \boldsymbol{X}^T\boldsymbol{W}\boldsymbol{X}. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="extending-to-more-predictors">Extending to more predictors </h2>

<p>Within a binary classification problem, we can easily expand our model to include multiple predictors. Our ratio between likelihoods is then with \( p \) predictors</p>
$$
\log{ \frac{p(\boldsymbol{\theta}\boldsymbol{x})}{1-p(\boldsymbol{\theta}\boldsymbol{x})}} = \theta_0+\theta_1x_1+\theta_2x_2+\dots+\theta_px_p.
$$

<p>Here we defined \( \boldsymbol{x}=[1,x_1,x_2,\dots,x_p] \) and \( \boldsymbol{\theta}=[\theta_0, \theta_1, \dots, \theta_p] \) leading to</p>
$$
p(\boldsymbol{\theta}\boldsymbol{x})=\frac{ \exp{(\theta_0+\theta_1x_1+\theta_2x_2+\dots+\theta_px_p)}}{1+\exp{(\theta_0+\theta_1x_1+\theta_2x_2+\dots+\theta_px_p)}}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="including-more-classes">Including more classes </h2>

<p>Till now we have mainly focused on two classes, the so-called binary
system. Suppose we wish to extend to \( K \) classes.  Let us for the sake
of simplicity assume we have only two predictors. We have then following model
</p>

$$
\log{\frac{p(C=1\vert x)}{p(K\vert x)}} = \theta_{10}+\theta_{11}x_1,
$$

<p>and </p>
$$
\log{\frac{p(C=2\vert x)}{p(K\vert x)}} = \theta_{20}+\theta_{21}x_1,
$$

<p>and so on till the class \( C=K-1 \) class</p>
$$
\log{\frac{p(C=K-1\vert x)}{p(K\vert x)}} = \theta_{(K-1)0}+\theta_{(K-1)1}x_1,
$$

<p>and the model is specified in term of \( K-1 \) so-called log-odds or
<b>logit</b> transformations.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-classes">More classes </h2>

<p>In our discussion of neural networks we will encounter the above again
in terms of a slightly modified function, the so-called <b>Softmax</b> function.
</p>

<p>The softmax function is used in various multiclass classification
methods, such as multinomial logistic regression (also known as
softmax regression), multiclass linear discriminant analysis, naive
Bayes classifiers, and artificial neural networks.  Specifically, in
multinomial logistic regression and linear discriminant analysis, the
input to the function is the result of \( K \) distinct linear functions,
and the predicted probability for the \( k \)-th class given a sample
vector \( \boldsymbol{x} \) and a weighting vector \( \boldsymbol{\theta} \) is (with two
predictors):
</p>

$$
p(C=k\vert \mathbf {x} )=\frac{\exp{(\theta_{k0}+\theta_{k1}x_1)}}{1+\sum_{l=1}^{K-1}\exp{(\theta_{l0}+\theta_{l1}x_1)}}.
$$

<p>It is easy to extend to more predictors. The final class is </p>
$$
p(C=K\vert \mathbf {x} )=\frac{1}{1+\sum_{l=1}^{K-1}\exp{(\theta_{l0}+\theta_{l1}x_1)}},
$$

<p>and they sum to one. Our earlier discussions were all specialized to
the case with two classes only. It is easy to see from the above that
what we derived earlier is compatible with these equations.
</p>

<p>To find the optimal parameters we would typically use a gradient
descent method.  Newton's method and gradient descent methods are
discussed in the material on <a href="https://compphysics.github.io/MachineLearning/doc/pub/Splines/html/Splines-bs.html" target="_blank">optimization
methods</a>.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimization-the-central-part-of-any-machine-learning-algortithm">Optimization, the central part of any Machine Learning algortithm </h2>

<p>Almost every problem in machine learning and data science starts with
a dataset \( X \), a model \( g(\theta) \), which is a function of the
parameters \( \theta \) and a cost function \( C(X, g(\theta)) \) that allows
us to judge how well the model \( g(\theta) \) explains the observations
\( X \). The model is fit by finding the values of \( \theta \) that minimize
the cost function. Ideally we would be able to solve for \( \theta \)
analytically, however this is not possible in general and we must use
some approximative/numerical method to compute the minimum.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="revisiting-our-logistic-regression-case">Revisiting our Logistic Regression case </h2>

<p>In our discussion on Logistic Regression we studied the 
case of
two classes, with \( y_i \) either
\( 0 \) or \( 1 \). Furthermore we assumed also that we have only two
parameters \( \theta \) in our fitting, that is we
defined probabilities
</p>

$$
\begin{align*}
p(y_i=1|x_i,\boldsymbol{\theta}) &= \frac{\exp{(\theta_0+\theta_1x_i)}}{1+\exp{(\theta_0+\theta_1x_i)}},\nonumber\\
p(y_i=0|x_i,\boldsymbol{\theta}) &= 1 - p(y_i=1|x_i,\boldsymbol{\theta}),
\end{align*}
$$

<p>where \( \boldsymbol{\theta} \) are the weights we wish to extract from data, in our case \( \theta_0 \) and \( \theta_1 \). </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-equations-to-solve">The equations to solve </h2>

<p>Our compact equations used a definition of a vector \( \boldsymbol{y} \) with \( n \)
elements \( y_i \), an \( n\times p \) matrix \( \boldsymbol{X} \) which contains the
\( x_i \) values and a vector \( \boldsymbol{p} \) of fitted probabilities
\( p(y_i\vert x_i,\boldsymbol{\theta}) \). We rewrote in a more compact form
the first derivative of the cost function as
</p>

$$
\frac{\partial \mathcal{C}(\boldsymbol{\theta})}{\partial \boldsymbol{\theta}} = -\boldsymbol{X}^T\left(\boldsymbol{y}-\boldsymbol{p}\right). 
$$

<p>If we in addition define a diagonal matrix \( \boldsymbol{W} \) with elements 
\( p(y_i\vert x_i,\boldsymbol{\theta})(1-p(y_i\vert x_i,\boldsymbol{\theta}) \), we can obtain a compact expression of the second derivative as 
</p>

$$
\frac{\partial^2 \mathcal{C}(\boldsymbol{\theta})}{\partial \boldsymbol{\theta}\partial \boldsymbol{\theta}^T} = \boldsymbol{X}^T\boldsymbol{W}\boldsymbol{X}. 
$$

<p>This defines what is called  the Hessian matrix.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="solving-using-newton-raphson-s-method">Solving using Newton-Raphson's method </h2>

<p>If we can set up these equations, Newton-Raphson's iterative method is normally the method of choice. It requires however that we can compute in an efficient way the  matrices that define the first and second derivatives. </p>

<p>Our iterative scheme is then given by</p>

$$
\boldsymbol{\theta}^{\mathrm{new}} = \boldsymbol{\theta}^{\mathrm{old}}-\left(\frac{\partial^2 \mathcal{C}(\boldsymbol{\theta})}{\partial \boldsymbol{\theta}\partial \boldsymbol{\theta}^T}\right)^{-1}_{\boldsymbol{\theta}^{\mathrm{old}}}\times \left(\frac{\partial \mathcal{C}(\boldsymbol{\theta})}{\partial \boldsymbol{\theta}}\right)_{\boldsymbol{\theta}^{\mathrm{old}}},
$$

<p>or in matrix form as</p>

$$
\boldsymbol{\theta}^{\mathrm{new}} = \boldsymbol{\theta}^{\mathrm{old}}-\left(\boldsymbol{X}^T\boldsymbol{W}\boldsymbol{X} \right)^{-1}\times \left(-\boldsymbol{X}^T(\boldsymbol{y}-\boldsymbol{p}) \right)_{\boldsymbol{\theta}^{\mathrm{old}}}.
$$

<p>The right-hand side is computed with the old values of \( \theta \). </p>

<p>If we can compute these matrices, in particular the Hessian, the above is often the easiest method to implement. </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-code-for-logistic-regression">Example code for Logistic Regression </h2>

<p>Here we make a class for Logistic regression. The code uses a simple data set and includes both a binary case and a multiclass case.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">LogisticRegression</span>:
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Logistic Regression for binary and multiclass classification.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, lr=<span style="color: #B452CD">0.01</span>, epochs=<span style="color: #B452CD">1000</span>, fit_intercept=<span style="color: #8B008B; font-weight: bold">True</span>, verbose=<span style="color: #8B008B; font-weight: bold">False</span>):
        <span style="color: #658b00">self</span>.lr = lr                  <span style="color: #228B22"># Learning rate for gradient descent</span>
        <span style="color: #658b00">self</span>.epochs = epochs          <span style="color: #228B22"># Number of iterations</span>
        <span style="color: #658b00">self</span>.fit_intercept = fit_intercept  <span style="color: #228B22"># Whether to add intercept (bias)</span>
        <span style="color: #658b00">self</span>.verbose = verbose        <span style="color: #228B22"># Print loss during training if True</span>
        <span style="color: #658b00">self</span>.weights = <span style="color: #8B008B; font-weight: bold">None</span>
        <span style="color: #658b00">self</span>.multi_class = <span style="color: #8B008B; font-weight: bold">False</span>      <span style="color: #228B22"># Will be determined at fit time</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">_add_intercept</span>(<span style="color: #658b00">self</span>, X):
        <span style="color: #CD5555">&quot;&quot;&quot;Add intercept term (column of ones) to feature matrix.&quot;&quot;&quot;</span>
        intercept = np.ones((X.shape[<span style="color: #B452CD">0</span>], <span style="color: #B452CD">1</span>))
        <span style="color: #8B008B; font-weight: bold">return</span> np.concatenate((intercept, X), axis=<span style="color: #B452CD">1</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">_sigmoid</span>(<span style="color: #658b00">self</span>, z):
        <span style="color: #CD5555">&quot;&quot;&quot;Sigmoid function for binary logistic.&quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span> / (<span style="color: #B452CD">1</span> + np.exp(-z))

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">_softmax</span>(<span style="color: #658b00">self</span>, Z):
        <span style="color: #CD5555">&quot;&quot;&quot;Softmax function for multiclass logistic.&quot;&quot;&quot;</span>
        exp_Z = np.exp(Z - np.max(Z, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>))
        <span style="color: #8B008B; font-weight: bold">return</span> exp_Z / np.sum(exp_Z, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">fit</span>(<span style="color: #658b00">self</span>, X, y):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Train the logistic regression model using gradient descent.</span>
<span style="color: #CD5555">        Supports binary (sigmoid) and multiclass (softmax) based on y.</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        X = np.array(X)
        y = np.array(y)
        n_samples, n_features = X.shape

        <span style="color: #228B22"># Add intercept if needed</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.fit_intercept:
            X = <span style="color: #658b00">self</span>._add_intercept(X)
            n_features += <span style="color: #B452CD">1</span>

        <span style="color: #228B22"># Determine classes and mode (binary vs multiclass)</span>
        unique_classes = np.unique(y)
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(unique_classes) &gt; <span style="color: #B452CD">2</span>:
            <span style="color: #658b00">self</span>.multi_class = <span style="color: #8B008B; font-weight: bold">True</span>
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #658b00">self</span>.multi_class = <span style="color: #8B008B; font-weight: bold">False</span>

        <span style="color: #228B22"># ----- Multiclass case -----</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.multi_class:
            n_classes = <span style="color: #658b00">len</span>(unique_classes)
            <span style="color: #228B22"># Map original labels to 0...n_classes-1</span>
            class_to_index = {c: idx <span style="color: #8B008B; font-weight: bold">for</span> idx, c <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(unique_classes)}
            y_indices = np.array([class_to_index[c] <span style="color: #8B008B; font-weight: bold">for</span> c <span style="color: #8B008B">in</span> y])
            <span style="color: #228B22"># Initialize weight matrix (features x classes)</span>
            <span style="color: #658b00">self</span>.weights = np.zeros((n_features, n_classes))

            <span style="color: #228B22"># One-hot encode y</span>
            Y_onehot = np.zeros((n_samples, n_classes))
            Y_onehot[np.arange(n_samples), y_indices] = <span style="color: #B452CD">1</span>

            <span style="color: #228B22"># Gradient descent</span>
            <span style="color: #8B008B; font-weight: bold">for</span> epoch <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">self</span>.epochs):
                scores = X.dot(<span style="color: #658b00">self</span>.weights)          <span style="color: #228B22"># Linear scores (n_samples x n_classes)</span>
                probs = <span style="color: #658b00">self</span>._softmax(scores)        <span style="color: #228B22"># Probabilities (n_samples x n_classes)</span>
                <span style="color: #228B22"># Compute gradient (features x classes)</span>
                gradient = (<span style="color: #B452CD">1</span> / n_samples) * X.T.dot(probs - Y_onehot)
                <span style="color: #228B22"># Update weights</span>
                <span style="color: #658b00">self</span>.weights -= <span style="color: #658b00">self</span>.lr * gradient

                <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.verbose <span style="color: #8B008B">and</span> epoch % <span style="color: #B452CD">100</span> == <span style="color: #B452CD">0</span>:
                    <span style="color: #228B22"># Compute current loss (categorical cross-entropy)</span>
                    loss = -np.sum(Y_onehot * np.log(probs + <span style="color: #B452CD">1e-15</span>)) / n_samples
                    <span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;[Epoch {</span>epoch<span style="color: #CD5555">}] Multiclass loss: {</span>loss<span style="color: #CD5555">:.4f}&quot;</span>)

        <span style="color: #228B22"># ----- Binary case -----</span>
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #228B22"># Convert y to 0/1 if not already</span>
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> np.array_equal(unique_classes, [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]):
                <span style="color: #228B22"># Map the two classes to 0 and 1</span>
                class0, class1 = unique_classes
                y_binary = np.where(y == class1, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0</span>)
            <span style="color: #8B008B; font-weight: bold">else</span>:
                y_binary = y.copy().astype(<span style="color: #658b00">int</span>)

            <span style="color: #228B22"># Initialize weights vector (features,)</span>
            <span style="color: #658b00">self</span>.weights = np.zeros(n_features)

            <span style="color: #228B22"># Gradient descent</span>
            <span style="color: #8B008B; font-weight: bold">for</span> epoch <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">self</span>.epochs):
                linear_model = X.dot(<span style="color: #658b00">self</span>.weights)     <span style="color: #228B22"># (n_samples,)</span>
                probs = <span style="color: #658b00">self</span>._sigmoid(linear_model)   <span style="color: #228B22"># (n_samples,)</span>
                <span style="color: #228B22"># Gradient for binary cross-entropy</span>
                gradient = (<span style="color: #B452CD">1</span> / n_samples) * X.T.dot(probs - y_binary)
                <span style="color: #658b00">self</span>.weights -= <span style="color: #658b00">self</span>.lr * gradient

                <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.verbose <span style="color: #8B008B">and</span> epoch % <span style="color: #B452CD">100</span> == <span style="color: #B452CD">0</span>:
                    <span style="color: #228B22"># Compute binary cross-entropy loss</span>
                    loss = -np.mean(
                        y_binary * np.log(probs + <span style="color: #B452CD">1e-15</span>) + 
                        (<span style="color: #B452CD">1</span> - y_binary) * np.log(<span style="color: #B452CD">1</span> - probs + <span style="color: #B452CD">1e-15</span>)
                    )
                    <span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;[Epoch {</span>epoch<span style="color: #CD5555">}] Binary loss: {</span>loss<span style="color: #CD5555">:.4f}&quot;</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">predict_prob</span>(<span style="color: #658b00">self</span>, X):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Compute probability estimates. Returns a 1D array for binary or</span>
<span style="color: #CD5555">        a 2D array (n_samples x n_classes) for multiclass.</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        X = np.array(X)
        <span style="color: #228B22"># Add intercept if the model used it</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.fit_intercept:
            X = <span style="color: #658b00">self</span>._add_intercept(X)
        scores = X.dot(<span style="color: #658b00">self</span>.weights)
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.multi_class:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>._softmax(scores)
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>._sigmoid(scores)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">predict</span>(<span style="color: #658b00">self</span>, X):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Predict class labels for samples in X.</span>
<span style="color: #CD5555">        Returns integer class labels (0,1 for binary, or 0...C-1 for multiclass).</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        probs = <span style="color: #658b00">self</span>.predict_prob(X)
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.multi_class:
            <span style="color: #228B22"># Choose class with highest probability</span>
            <span style="color: #8B008B; font-weight: bold">return</span> np.argmax(probs, axis=<span style="color: #B452CD">1</span>)
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #228B22"># Threshold at 0.5 for binary</span>
            <span style="color: #8B008B; font-weight: bold">return</span> (probs &gt;= <span style="color: #B452CD">0.5</span>).astype(<span style="color: #658b00">int</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The class implements the sigmoid and softmax internally. During fit(),
we check the number of classes: if more than 2, we set
self.multi_class=True and perform multinomial logistic regression. We
one-hot encode the target vector and update a weight matrix with
softmax probabilities. Otherwise, we do standard binary logistic
regression, converting labels to 0/1 if needed and updating a weight
vector. In both cases we use batch gradient descent on the
cross-entropy loss (we add a small epsilon 1e-15 to logs for numerical
stability). Progress (loss) can be printed if verbose=True.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Evaluation Metrics</span>
<span style="color: #228B22">#We define helper functions for accuracy and cross-entropy loss. Accuracy is the fraction of correct predictions . For loss, we compute the appropriate cross-entropy:</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">accuracy_score</span>(y_true, y_pred):
    <span style="color: #CD5555">&quot;&quot;&quot;Accuracy = (# correct predictions) / (total samples).&quot;&quot;&quot;</span>
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    <span style="color: #8B008B; font-weight: bold">return</span> np.mean(y_true == y_pred)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">binary_cross_entropy</span>(y_true, y_prob):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Binary cross-entropy loss.</span>
<span style="color: #CD5555">    y_true: true binary labels (0 or 1), y_prob: predicted probabilities for class 1.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    y_true = np.array(y_true)
    y_prob = np.clip(np.array(y_prob), <span style="color: #B452CD">1e-15</span>, <span style="color: #B452CD">1</span>-<span style="color: #B452CD">1e-15</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> -np.mean(y_true * np.log(y_prob) + (<span style="color: #B452CD">1</span> - y_true) * np.log(<span style="color: #B452CD">1</span> - y_prob))

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">categorical_cross_entropy</span>(y_true, y_prob):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Categorical cross-entropy loss for multiclass.</span>
<span style="color: #CD5555">    y_true: true labels (0...C-1), y_prob: array of predicted probabilities (n_samples x C).</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    y_true = np.array(y_true, dtype=<span style="color: #658b00">int</span>)
    y_prob = np.clip(np.array(y_prob), <span style="color: #B452CD">1e-15</span>, <span style="color: #B452CD">1</span>-<span style="color: #B452CD">1e-15</span>)
    <span style="color: #228B22"># One-hot encode true labels</span>
    n_samples, n_classes = y_prob.shape
    one_hot = np.zeros_like(y_prob)
    one_hot[np.arange(n_samples), y_true] = <span style="color: #B452CD">1</span>
    <span style="color: #228B22"># Compute cross-entropy</span>
    loss_vec = -np.sum(one_hot * np.log(y_prob), axis=<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> np.mean(loss_vec)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h3 id="synthetic-data-generation">Synthetic data generation </h3>

<p>Binary classification data: Create two Gaussian clusters in 2D. For example, class 0 around mean [-2,-2] and class 1 around [2,2].
Multiclass data: Create several Gaussian clusters (one per class) spread out in feature space.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generate_binary_data</span>(n_samples=<span style="color: #B452CD">100</span>, n_features=<span style="color: #B452CD">2</span>, random_state=<span style="color: #8B008B; font-weight: bold">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Generate synthetic binary classification data.</span>
<span style="color: #CD5555">    Returns (X, y) where X is (n_samples x n_features), y in {0,1}.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    rng = np.random.RandomState(random_state)
    <span style="color: #228B22"># Half samples for class 0, half for class 1</span>
    n0 = n_samples // <span style="color: #B452CD">2</span>
    n1 = n_samples - n0
    <span style="color: #228B22"># Class 0 around mean -2, class 1 around +2</span>
    mean0 = -<span style="color: #B452CD">2</span> * np.ones(n_features)
    mean1 =  <span style="color: #B452CD">2</span> * np.ones(n_features)
    X0 = rng.randn(n0, n_features) + mean0
    X1 = rng.randn(n1, n_features) + mean1
    X = np.vstack((X0, X1))
    y = np.array([<span style="color: #B452CD">0</span>]*n0 + [<span style="color: #B452CD">1</span>]*n1)
    <span style="color: #8B008B; font-weight: bold">return</span> X, y

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generate_multiclass_data</span>(n_samples=<span style="color: #B452CD">150</span>, n_features=<span style="color: #B452CD">2</span>, n_classes=<span style="color: #B452CD">3</span>, random_state=<span style="color: #8B008B; font-weight: bold">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Generate synthetic multiclass data with n_classes Gaussian clusters.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    rng = np.random.RandomState(random_state)
    X = []
    y = []
    samples_per_class = n_samples // n_classes
    <span style="color: #8B008B; font-weight: bold">for</span> <span style="color: #658b00">cls</span> <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n_classes):
        <span style="color: #228B22"># Random cluster center for each class</span>
        center = rng.uniform(-<span style="color: #B452CD">5</span>, <span style="color: #B452CD">5</span>, size=n_features)
        Xi = rng.randn(samples_per_class, n_features) + center
        yi = [<span style="color: #658b00">cls</span>] * samples_per_class
        X.append(Xi)
        y.extend(yi)
    X = np.vstack(X)
    y = np.array(y)
    <span style="color: #8B008B; font-weight: bold">return</span> X, y


<span style="color: #228B22"># Generate and test on binary data</span>
X_bin, y_bin = generate_binary_data(n_samples=<span style="color: #B452CD">200</span>, n_features=<span style="color: #B452CD">2</span>, random_state=<span style="color: #B452CD">42</span>)
model_bin = LogisticRegression(lr=<span style="color: #B452CD">0.1</span>, epochs=<span style="color: #B452CD">1000</span>)
model_bin.fit(X_bin, y_bin)
y_prob_bin = model_bin.predict_prob(X_bin)      <span style="color: #228B22"># probabilities for class 1</span>
y_pred_bin = model_bin.predict(X_bin)           <span style="color: #228B22"># predicted classes 0 or 1</span>

acc_bin = accuracy_score(y_bin, y_pred_bin)
loss_bin = binary_cross_entropy(y_bin, y_prob_bin)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Binary Classification - Accuracy: {</span>acc_bin<span style="color: #CD5555">:.2f}, Cross-Entropy Loss: {</span>loss_bin<span style="color: #CD5555">:.2f}&quot;</span>)
<span style="color: #228B22">#For multiclass:</span>
<span style="color: #228B22"># Generate and test on multiclass data</span>
X_multi, y_multi = generate_multiclass_data(n_samples=<span style="color: #B452CD">300</span>, n_features=<span style="color: #B452CD">2</span>, n_classes=<span style="color: #B452CD">3</span>, random_state=<span style="color: #B452CD">1</span>)
model_multi = LogisticRegression(lr=<span style="color: #B452CD">0.1</span>, epochs=<span style="color: #B452CD">1000</span>)
model_multi.fit(X_multi, y_multi)
y_prob_multi = model_multi.predict_prob(X_multi)     <span style="color: #228B22"># (n_samples x 3) probabilities</span>
y_pred_multi = model_multi.predict(X_multi)          <span style="color: #228B22"># predicted labels 0,1,2</span>

acc_multi = accuracy_score(y_multi, y_pred_multi)
loss_multi = categorical_cross_entropy(y_multi, y_prob_multi)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Multiclass Classification - Accuracy: {</span>acc_multi<span style="color: #CD5555">:.2f}, Cross-Entropy Loss: {</span>loss_multi<span style="color: #CD5555">:.2f}&quot;</span>)

<span style="color: #228B22"># CSV Export</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">csv</span>

<span style="color: #228B22"># Export binary results</span>
<span style="color: #8B008B; font-weight: bold">with</span> <span style="color: #658b00">open</span>(<span style="color: #CD5555">&#39;binary_results.csv&#39;</span>, mode=<span style="color: #CD5555">&#39;w&#39;</span>, newline=<span style="color: #CD5555">&#39;&#39;</span>) <span style="color: #8B008B; font-weight: bold">as</span> f:
    writer = csv.writer(f)
    writer.writerow([<span style="color: #CD5555">&quot;TrueLabel&quot;</span>, <span style="color: #CD5555">&quot;PredictedLabel&quot;</span>])
    <span style="color: #8B008B; font-weight: bold">for</span> true, pred <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(y_bin, y_pred_bin):
        writer.writerow([true, pred])

<span style="color: #228B22"># Export multiclass results</span>
<span style="color: #8B008B; font-weight: bold">with</span> <span style="color: #658b00">open</span>(<span style="color: #CD5555">&#39;multiclass_results.csv&#39;</span>, mode=<span style="color: #CD5555">&#39;w&#39;</span>, newline=<span style="color: #CD5555">&#39;&#39;</span>) <span style="color: #8B008B; font-weight: bold">as</span> f:
    writer = csv.writer(f)
    writer.writerow([<span style="color: #CD5555">&quot;TrueLabel&quot;</span>, <span style="color: #CD5555">&quot;PredictedLabel&quot;</span>])
    <span style="color: #8B008B; font-weight: bold">for</span> true, pred <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(y_multi, y_pred_multi):
        writer.writerow([true, pred])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ------------------- end of main content --------------- -->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2025, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

