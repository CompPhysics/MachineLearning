<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week37-reveal.html week37-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Week 37: Statitsitcal interpretations and Resampling Methods">
<title>Week 37: Statitsitcal interpretations and Resampling Methods</title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<center>
<h1 style="text-align: center;">Week 37: Statitsitcal interpretations and Resampling Methods</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics, University of Oslo</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University</b>
</center>
<br>
<center>
<h4>Sep 14, 2023</h4>
</center> <!-- date -->
<br>

<!-- todo add link to videos and add link to Van Wieringens notes -->


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2023, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>

<section>
<h2 id="plans-for-week-37">Plans for week 37 </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Material for the active learning sessions on Tuesday and Wednesday</b>
<p>
<ul>

<p><li> Lecture from last week on calculations of expectation values</li>

<p><li> Exercise for week 37</li>

<p><li> Work on project 1</li>

<p><li> See also additional note on scaling (jupyter-notebook) sent separately. This will be discussed during the first hour of each session. This note is added at the end of these slides.</li>

<p><li> For more discussions of Ridge regression and calculation of averages, <a href="https://arxiv.org/abs/1509.09169" target="_blank">Wessel van Wieringen's</a> article is highly recommended.</li>
</ul>
</div>
  
<div class="alert alert-block alert-block alert-text-normal">
<b>Material for the lecture on Thursday September 7</b>
<p>
<ul>

<p><li> Resampling techniques, Bootstrap and cross validation and bias-variance tradeoff</li>

<p><li> Statistical interpretation of Ridge and Lasso regression</li>

<p><li> Readings and Videos:</li>
<ul>

<p><li> Hastie et al Chapter 7, here we recommend 7.1-7.5 and 7.10 (cross-validation) and 7.11 (bootstrap).</li>

<p><li> <a href="https://www.youtube.com/watch?v=fSytzGwwBVw" target="_blank">Video on cross validation</a></li>

<p><li> <a href="https://www.youtube.com/watch?v=Xz0x-8-cgaQ" target="_blank">Video on Bootstrapping</a></li>

<p><li> <a href="https://www.youtube.com/watch?v=EuBBz3bI-aA" target="_blank">Video on bias-variance tradeoff</a></li>
</ul>
<p>
</ul>
</div>
</section>

<section>
<h2 id="material-from-last-week-and-relevant-for-the-weekly-exercises">Material from last week and relevant for the weekly exercises </h2>
</section>

<section>
<h2 id="linking-the-regression-analysis-with-a-statistical-interpretation">Linking the regression analysis with a statistical interpretation </h2>

<p>We will now couple the discussions of ordinary least squares, Ridge
and Lasso regression with a statistical interpretation, that is we
move from a linear algebra analysis to a statistical analysis. In
particular, we will focus on what the regularization terms can result
in.  We will amongst other things show that the regularization
parameter can reduce considerably the variance of the parameters
\( \beta \).
</p>

<p>The
advantage of doing linear regression is that we actually end up with
analytical expressions for several statistical quantities.  
Standard least squares and Ridge regression  allow us to
derive quantities like the variance and other expectation values in a
rather straightforward way.
</p>

<p>It is assumed that \( \varepsilon_i
\sim \mathcal{N}(0, \sigma^2) \) and the \( \varepsilon_{i} \) are
independent, i.e.: 
</p>
<p>&nbsp;<br>
$$
\begin{align*} 
\mbox{Cov}(\varepsilon_{i_1},
\varepsilon_{i_2}) & = \left\{ \begin{array}{lcc} \sigma^2 & \mbox{if}
& i_1 = i_2, \\ 0 & \mbox{if} & i_1 \not= i_2.  \end{array} \right.
\end{align*} 
$$
<p>&nbsp;<br>

<p>The randomness of \( \varepsilon_i \) implies that
\( \mathbf{y}_i \) is also a random variable. In particular,
\( \mathbf{y}_i \) is normally distributed, because \( \varepsilon_i \sim
\mathcal{N}(0, \sigma^2) \) and \( \mathbf{X}_{i,\ast} \, \boldsymbol{\beta} \) is a
non-random scalar. To specify the parameters of the distribution of
\( \mathbf{y}_i \) we need to calculate its first two moments. 
</p>

<p>Recall that \( \boldsymbol{X} \) is a matrix of dimensionality \( n\times p \). The
notation above \( \mathbf{X}_{i,\ast} \) means that we are looking at the
row number \( i \) and perform a sum over all values \( p \).
</p>
</section>

<section>
<h2 id="assumptions-made">Assumptions made </h2>

<p>The assumption we have made here can be summarized as (and this is going to be useful when we discuss the bias-variance trade off)
that there exists a function \( f(\boldsymbol{x}) \) and  a normal distributed error \( \boldsymbol{\varepsilon}\sim \mathcal{N}(0, \sigma^2) \)
which describe our data
</p>
<p>&nbsp;<br>
$$
\boldsymbol{y} = f(\boldsymbol{x})+\boldsymbol{\varepsilon}
$$
<p>&nbsp;<br>

<p>We approximate this function with our model from the solution of the linear regression equations, that is our
function \( f \) is approximated by \( \boldsymbol{\tilde{y}} \) where we want to minimize \( (\boldsymbol{y}-\boldsymbol{\tilde{y}})^2 \), our MSE, with
</p>
<p>&nbsp;<br>
$$
\boldsymbol{\tilde{y}} = \boldsymbol{X}\boldsymbol{\beta}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="expectation-value-and-variance">Expectation value and variance </h2>

<p>We can calculate the expectation value of \( \boldsymbol{y} \) for a given element \( i \) </p>
<p>&nbsp;<br>
$$
\begin{align*} 
\mathbb{E}(y_i) & =
\mathbb{E}(\mathbf{X}_{i, \ast} \, \boldsymbol{\beta}) + \mathbb{E}(\varepsilon_i)
\, \, \, = \, \, \, \mathbf{X}_{i, \ast} \, \beta, 
\end{align*} 
$$
<p>&nbsp;<br>

<p>while
its variance is 
</p>
<p>&nbsp;<br>
$$
\begin{align*} \mbox{Var}(y_i) & = \mathbb{E} \{ [y_i
- \mathbb{E}(y_i)]^2 \} \, \, \, = \, \, \, \mathbb{E} ( y_i^2 ) -
[\mathbb{E}(y_i)]^2  \\  & = \mathbb{E} [ ( \mathbf{X}_{i, \ast} \,
\beta + \varepsilon_i )^2] - ( \mathbf{X}_{i, \ast} \, \boldsymbol{\beta})^2 \\ &
= \mathbb{E} [ ( \mathbf{X}_{i, \ast} \, \boldsymbol{\beta})^2 + 2 \varepsilon_i
\mathbf{X}_{i, \ast} \, \boldsymbol{\beta} + \varepsilon_i^2 ] - ( \mathbf{X}_{i,
\ast} \, \beta)^2 \\  & = ( \mathbf{X}_{i, \ast} \, \boldsymbol{\beta})^2 + 2
\mathbb{E}(\varepsilon_i) \mathbf{X}_{i, \ast} \, \boldsymbol{\beta} +
\mathbb{E}(\varepsilon_i^2 ) - ( \mathbf{X}_{i, \ast} \, \boldsymbol{\beta})^2 
\\ & = \mathbb{E}(\varepsilon_i^2 ) \, \, \, = \, \, \,
\mbox{Var}(\varepsilon_i) \, \, \, = \, \, \, \sigma^2.  
\end{align*}
$$
<p>&nbsp;<br>

<p>Hence, \( y_i \sim \mathcal{N}( \mathbf{X}_{i, \ast} \, \boldsymbol{\beta}, \sigma^2) \), that is \( \boldsymbol{y} \) follows a normal distribution with 
mean value \( \boldsymbol{X}\boldsymbol{\beta} \) and variance \( \sigma^2 \) (not be confused with the singular values of the SVD). 
</p>
</section>

<section>
<h2 id="expectation-value-and-variance-for-boldsymbol-beta">Expectation value and variance for \( \boldsymbol{\beta} \) </h2>

<p>With the OLS expressions for the optimal parameters \( \boldsymbol{\hat{\beta}} \) we can evaluate the expectation value</p>
<p>&nbsp;<br>
$$
\mathbb{E}(\boldsymbol{\hat{\beta}}) = \mathbb{E}[ (\mathbf{X}^{\top} \mathbf{X})^{-1}\mathbf{X}^{T} \mathbf{Y}]=(\mathbf{X}^{T} \mathbf{X})^{-1}\mathbf{X}^{T} \mathbb{E}[ \mathbf{Y}]=(\mathbf{X}^{T} \mathbf{X})^{-1} \mathbf{X}^{T}\mathbf{X}\boldsymbol{\beta}=\boldsymbol{\beta}.
$$
<p>&nbsp;<br>

<p>This means that the estimator of the regression parameters is unbiased.</p>

<p>We can also calculate the variance</p>

<p>The variance of the optimal value \( \boldsymbol{\hat{\beta}} \) is</p>
<p>&nbsp;<br>
$$
\begin{eqnarray*}
\mbox{Var}(\boldsymbol{\hat{\beta}}) & = & \mathbb{E} \{ [\boldsymbol{\beta} - \mathbb{E}(\boldsymbol{\beta})] [\boldsymbol{\beta} - \mathbb{E}(\boldsymbol{\beta})]^{T} \}
\\
& = & \mathbb{E} \{ [(\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \mathbf{y} - \boldsymbol{\beta}] \, [(\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \mathbf{y} - \boldsymbol{\beta}]^{T} \}
\\
% & = & \mathbb{E} \{ [(\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \mathbf{y}] \, [(\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \mathbf{y}]^{T} \} - \boldsymbol{\beta} \, \boldsymbol{\beta}^{T}
% \\
% & = & \mathbb{E} \{ (\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \mathbf{y} \, \mathbf{y}^{T} \, \mathbf{X} \, (\mathbf{X}^{T} \mathbf{X})^{-1}  \} - \boldsymbol{\beta} \, \boldsymbol{\beta}^{T}
% \\
& = & (\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \, \mathbb{E} \{ \mathbf{y} \, \mathbf{y}^{T} \} \, \mathbf{X} \, (\mathbf{X}^{T} \mathbf{X})^{-1} - \boldsymbol{\beta} \, \boldsymbol{\beta}^{T}
\\
& = & (\mathbf{X}^{T} \mathbf{X})^{-1} \, \mathbf{X}^{T} \, \{ \mathbf{X} \, \boldsymbol{\beta} \, \boldsymbol{\beta}^{T} \,  \mathbf{X}^{T} + \sigma^2 \} \, \mathbf{X} \, (\mathbf{X}^{T} \mathbf{X})^{-1} - \boldsymbol{\beta} \, \boldsymbol{\beta}^{T}
% \\
% & = & (\mathbf{X}^T \mathbf{X})^{-1} \, \mathbf{X}^T \, \mathbf{X} \, \boldsymbol{\beta} \, \boldsymbol{\beta}^T \,  \mathbf{X}^T \, \mathbf{X} \, (\mathbf{X}^T % \mathbf{X})^{-1}
% \\
% & & + \, \, \sigma^2 \, (\mathbf{X}^T \mathbf{X})^{-1} \, \mathbf{X}^T  \, \mathbf{X} \, (\mathbf{X}^T \mathbf{X})^{-1} - \boldsymbol{\beta} \boldsymbol{\beta}^T
\\
& = & \boldsymbol{\beta} \, \boldsymbol{\beta}^{T}  + \sigma^2 \, (\mathbf{X}^{T} \mathbf{X})^{-1} - \boldsymbol{\beta} \, \boldsymbol{\beta}^{T}
\, \, \, = \, \, \, \sigma^2 \, (\mathbf{X}^{T} \mathbf{X})^{-1},
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>where we have used  that \( \mathbb{E} (\mathbf{y} \mathbf{y}^{T}) =
\mathbf{X} \, \boldsymbol{\beta} \, \boldsymbol{\beta}^{T} \, \mathbf{X}^{T} +
\sigma^2 \, \mathbf{I}_{nn} \). From \( \mbox{Var}(\boldsymbol{\beta}) = \sigma^2
\, (\mathbf{X}^{T} \mathbf{X})^{-1} \), one obtains an estimate of the
variance of the estimate of the \( j \)-th regression coefficient:
\( \boldsymbol{\sigma}^2 (\boldsymbol{\beta}_j ) = \boldsymbol{\sigma}^2 [(\mathbf{X}^{T} \mathbf{X})^{-1}]_{jj}  \). This may be used to
construct a confidence interval for the estimates.
</p>

<p>In a similar way, we can obtain analytical expressions for say the
expectation values of the parameters \( \boldsymbol{\beta} \) and their variance
when we employ Ridge regression, allowing us again to define a confidence interval. 
</p>

<p>It is rather straightforward to show that</p>
<p>&nbsp;<br>
$$
\mathbb{E} \big[ \hat{\boldsymbol{\beta}}^{\mathrm{Ridge}} \big]=(\mathbf{X}^{T} \mathbf{X} + \lambda \mathbf{I}_{pp})^{-1} (\mathbf{X}^{\top} \mathbf{X})\boldsymbol{\beta}.
$$
<p>&nbsp;<br>

<p>We see clearly that 
\( \mathbb{E} \big[ \hat{\boldsymbol{\beta}}^{\mathrm{Ridge}} \big] \not= \hat{\boldsymbol{\beta}}^{\mathrm{OLS}} \) for any \( \lambda > 0 \).
</p>

<p>We can also compute the variance as </p>

<p>&nbsp;<br>
$$
\mbox{Var}[\hat{\boldsymbol{\beta}}^{\mathrm{Ridge}}]=\sigma^2[  \mathbf{X}^{T} \mathbf{X} + \lambda \mathbf{I} ]^{-1}  \mathbf{X}^{T} \mathbf{X} \{ [  \mathbf{X}^{\top} \mathbf{X} + \lambda \mathbf{I} ]^{-1}\}^{T},
$$
<p>&nbsp;<br>

<p>and it is easy to see that if the parameter \( \lambda \) goes to infinity then the variance of Ridge parameters \( \boldsymbol{\beta} \) goes to zero. </p>

<p>With this, we can compute the difference </p>

<p>&nbsp;<br>
$$
\mbox{Var}[\hat{\boldsymbol{\beta}}^{\mathrm{OLS}}]-\mbox{Var}(\hat{\boldsymbol{\beta}}^{\mathrm{Ridge}})=\sigma^2 [  \mathbf{X}^{T} \mathbf{X} + \lambda \mathbf{I} ]^{-1}[ 2\lambda\mathbf{I} + \lambda^2 (\mathbf{X}^{T} \mathbf{X})^{-1} ] \{ [  \mathbf{X}^{T} \mathbf{X} + \lambda \mathbf{I} ]^{-1}\}^{T}.
$$
<p>&nbsp;<br>

<p>The difference is non-negative definite since each component of the
matrix product is non-negative definite. 
This means the variance we obtain with the standard OLS will always for \( \lambda > 0 \) be larger than the variance of \( \boldsymbol{\beta} \) obtained with the Ridge estimator. This has interesting consequences when we discuss the so-called bias-variance trade-off below. 
</p>

<p>For more discussions of Ridge regression and calculation of averages, <a href="https://arxiv.org/abs/1509.09169" target="_blank">Wessel van Wieringen's</a> article is highly recommended.</p>
</section>

<section>
<h2 id="material-for-lecture-thursday-september-14">Material for lecture Thursday September 14 </h2>
</section>

<section>
<h2 id="deriving-ols-from-a-probability-distribution">Deriving OLS from a probability distribution </h2>

<p>Our basic assumption when we derived the OLS equations was to assume
that our output is determined by a given continuous function
\( f(\boldsymbol{x}) \) and a random noise \( \boldsymbol{\epsilon} \) given by the normal
distribution with zero mean value and an undetermined variance
\( \sigma^2 \).
</p>

<p>We found above that the outputs \( \boldsymbol{y} \) have a mean value given by
\( \boldsymbol{X}\hat{\boldsymbol{\beta}} \) and variance \( \sigma^2 \). Since the entries to
the design matrix are not stochastic variables, we can assume that the
probability distribution of our targets is also a normal distribution
but now with mean value \( \boldsymbol{X}\hat{\boldsymbol{\beta}} \). This means that a
single output \( y_i \) is given by the Gaussian distribution
</p>

<p>&nbsp;<br>
$$
y_i\sim \mathcal{N}(\boldsymbol{X}_{i,*}\boldsymbol{\beta}, \sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="independent-and-identically-distrubuted-iid">Independent and Identically Distrubuted (iid) </h2>

<p>We assume now that the various \( y_i \) values are stochastically distributed according to the above Gaussian distribution. 
We define this distribution as
</p>
<p>&nbsp;<br>
$$
p(y_i, \boldsymbol{X}\vert\boldsymbol{\beta})=\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]},
$$
<p>&nbsp;<br>

<p>which reads as finding the likelihood of an event \( y_i \) with the input variables \( \boldsymbol{X} \) given the parameters (to be determined) \( \boldsymbol{\beta} \).</p>

<p>Since these events are assumed to be independent and identicall distributed we can build the probability distribution function (PDF) for all possible event \( \boldsymbol{y} \) as the product of the single events, that is we have</p>

<p>&nbsp;<br>
$$
p(\boldsymbol{y},\boldsymbol{X}\vert\boldsymbol{\beta})=\prod_{i=0}^{n-1}\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]}=\prod_{i=0}^{n-1}p(y_i,\boldsymbol{X}\vert\boldsymbol{\beta}).
$$
<p>&nbsp;<br>

<p>We will write this in a more compact form reserving \( \boldsymbol{D} \) for the domain of events, including the ouputs (targets) and the inputs. That is
in case we have a simple one-dimensional input and output case
</p>
<p>&nbsp;<br>
$$
\boldsymbol{D}=[(x_0,y_0), (x_1,y_1),\dots, (x_{n-1},y_{n-1})].
$$
<p>&nbsp;<br>

<p>In the more general case the various inputs should be replaced by the possible features represented by the input data set \( \boldsymbol{X} \). 
We can now rewrite the above probability as 
</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{D}\vert\boldsymbol{\beta})=\prod_{i=0}^{n-1}\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]}.
$$
<p>&nbsp;<br>

<p>It is a conditional probability (see below) and reads as the likelihood of a domain of events \( \boldsymbol{D} \) given a set of parameters \( \boldsymbol{\beta} \).</p>
</section>

<section>
<h2 id="maximum-likelihood-estimation-mle">Maximum Likelihood Estimation (MLE) </h2>

<p>In statistics, maximum likelihood estimation (MLE) is a method of
estimating the parameters of an assumed probability distribution,
given some observed data. This is achieved by maximizing a likelihood
function so that, under the assumed statistical model, the observed
data is the most probable. 
</p>

<p>We will assume here that our events are given by the above Gaussian
distribution and we will determine the optimal parameters \( \beta \) by
maximizing the above PDF. However, computing the derivatives of a
product function is cumbersome and can easily lead to overflow and/or
underflowproblems, with potentials for loss of numerical precision.
</p>

<p>In practice, it is more convenient to maximize the logarithm of the
PDF because it is a monotonically increasing function of the argument.
Alternatively, and this will be our option, we will minimize the
negative of the logarithm since this is a monotonically decreasing
function.
</p>

<p>Note also that maximization/minimization of the logarithm of the PDF
is equivalent to the maximization/minimization of the function itself.
</p>
</section>

<section>
<h2 id="a-new-cost-function">A new Cost Function </h2>

<p>We could now define a new cost function to minimize, namely the negative logarithm of the above PDF</p>

<p>&nbsp;<br>
$$
C(\boldsymbol{\beta}=-\log{\prod_{i=0}^{n-1}p(y_i,\boldsymbol{X}\vert\boldsymbol{\beta})}=-\sum_{i=0}^{n-1}\log{p(y_i,\boldsymbol{X}\vert\boldsymbol{\beta})},
$$
<p>&nbsp;<br>

<p>which becomes</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{\beta}=\frac{n}{2}\log{2\pi\sigma^2}+\frac{\vert\vert (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\vert\vert_2^2}{2\sigma^2}.
$$
<p>&nbsp;<br>

<p>Taking the derivative of the <em>new</em> cost function with respect to the parameters \( \beta \) we recognize our familiar OLS equation, namely</p>

<p>&nbsp;<br>
$$
\boldsymbol{X}^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right) =0,
$$
<p>&nbsp;<br>

<p>which leads to the well-known OLS equation for the optimal paramters \( \beta \)</p>
<p>&nbsp;<br>
$$
\hat{\boldsymbol{\beta}}^{\mathrm{OLS}}=\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}!
$$
<p>&nbsp;<br>

<p>Before we make a similar analysis for Ridge and Lasso regression, we need a short reminder on statistics. </p>
</section>

<section>
<h2 id="more-basic-statistics-and-bayes-theorem">More basic Statistics and Bayes' theorem </h2>

<p>A central theorem in statistics is Bayes' theorem. This theorem plays a similar role as the good old Pythagoras' theorem in geometry.
Bayes' theorem is extremely simple to derive. But to do so we need some basic axioms from statistics.
</p>

<p>Assume we have two domains of events \( X=[x_0,x_1,\dots,x_{n-1}] \) and \( Y=[y_0,y_1,\dots,y_{n-1}] \).</p>

<p>We define also the likelihood for \( X \) and \( Y \) as \( p(X) \) and \( p(Y) \) respectively.
The likelihood of a specific event \( x_i \) (or \( y_i \)) is then written as \( p(X=x_i) \) or just \( p(x_i)=p_i \). 
</p>

<div class="alert alert-block alert-block alert-text-normal">
<b>Union of events is given by</b>
<p>
<p>&nbsp;<br>
$$
p(X \cup Y)= p(X)+p(Y)-p(X \cap Y).
$$
<p>&nbsp;<br>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>The product rule (aka joint probability) is given by</b>
<p>
<p>&nbsp;<br>
$$
p(X \cup Y)= p(X,Y)= p(X\vert Y)p(Y)=p(Y\vert X)p(X),
$$
<p>&nbsp;<br>

<p>where we read \( p(X\vert Y) \) as the likelihood of obtaining \( X \) given \( Y \).</p>
</div>

<p>If we have independent events then \( p(X,Y)=p(X)p(Y) \).</p>
</section>

<section>
<h2 id="marginal-probability">Marginal Probability </h2>

<p>The marginal probability is defined in terms of only one of the set of variables \( X,Y \). For a discrete probability we have</p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>&nbsp;<br>
$$
p(X)=\sum_{i=0}^{n-1}p(X,Y=y_i)=\sum_{i=0}^{n-1}p(X\vert Y=y_i)p(Y=y_i)=\sum_{i=0}^{n-1}p(X\vert y_i)p(y_i).
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="conditional-probability">Conditional  Probability </h2>

<p>The conditional  probability, if \( p(Y) > 0 \), is </p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{p(Y)}=\frac{p(X,Y)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}.
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="bayes-theorem">Bayes' Theorem </h2>

<p>If we combine the conditional probability with the marginal probability and the standard product rule, we have</p>
<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{p(Y)},
$$
<p>&nbsp;<br>

<p>which we can rewrite as</p>

<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}=\frac{p(Y\vert X)p(X)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)},
$$
<p>&nbsp;<br>

<p>which is Bayes' theorem. It allows us to evaluate the uncertainty in in \( X \) after we have observed \( Y \). We can easily interchange \( X \) with \( Y \).  </p>
</section>

<section>
<h2 id="interpretations-of-bayes-theorem">Interpretations of Bayes' Theorem </h2>

<p>The quantity \( p(Y\vert X) \) on the right-hand side of the theorem is
evaluated for the observed data \( Y \) and can be viewed as a function of
the parameter space represented by \( X \). This function is not
necesseraly normalized and is normally called the likelihood function.
</p>

<p>The function \( p(X) \) on the right hand side is called the prior while the function on the left hand side is the called the posterior probability. The denominator on the right hand side serves as a normalization factor for the posterior distribution.</p>

<p>Let us try to illustrate Bayes' theorem through an example.</p>
</section>

<section>
<h2 id="example-of-usage-of-bayes-theorem">Example of Usage of Bayes' theorem </h2>

<p>Let us suppose that you are undergoing a series of mammography scans in
order to rule out possible breast cancer cases.  We define the
sensitivity for a positive event by the variable \( X \). It takes binary
values with \( X=1 \) representing a positive event and \( X=0 \) being a
negative event. We reserve \( Y \) as a classification parameter for
either a negative or a positive breast cancer confirmation. (Short note on wordings: positive here means having breast cancer, although none of us would consider this being a  positive thing).
</p>

<p>We let \( Y=1 \) represent the the case of having breast cancer and \( Y=0 \) as not.</p>

<p>Let us assume that if you have breast cancer, the test will be positive with a probability of \( 0.8 \), that is we have</p>

<p>&nbsp;<br>
$$
p(X=1\vert Y=1) =0.8.
$$
<p>&nbsp;<br>

<p>This obviously sounds  scary since many would conclude that if the test is positive, there is a likelihood of \( 80\% \) for having cancer.
It is however not correct, as the following Bayesian analysis shows.
</p>
</section>

<section>
<h2 id="doing-it-correctly">Doing it correctly </h2>

<p>If we look at various national surveys on breast cancer, the general likelihood of developing breast cancer is a very small number.
Let us assume that the prior probability in the population as a whole is
</p>

<p>&nbsp;<br>
$$
p(Y=1) =0.004.
$$
<p>&nbsp;<br>

<p>We need also to account for the fact that the test may produce a false positive result (false alarm). Let us here assume that we have</p>
<p>&nbsp;<br>
$$
p(X=1\vert Y=0) =0.1.
$$
<p>&nbsp;<br>

<p>Using Bayes' theorem we can then find the posterior probability that the person has breast cancer in case of a positive test, that is we can compute</p>

<p>&nbsp;<br>
$$
p(Y=1\vert X=1)=\frac{p(X=1\vert Y=1)p(Y=1)}{p(X=1\vert Y=1)p(Y=1)+p(X=1\vert Y=0)p(Y=0)}=\frac{0.8\times 0.004}{0.8\times 0.004+0.1\times 0.996}=0.031.
$$
<p>&nbsp;<br>

<p>That is, in case of a positive test, there is only a \( 3\% \) chance of having breast cancer!</p>
</section>

<section>
<h2 id="bayes-theorem-and-ridge-and-lasso-regression">Bayes' Theorem and Ridge and Lasso Regression </h2>

<p>Using Bayes' theorem we can gain a better intuition about Ridge and Lasso regression. </p>

<p>For ordinary least squares we postulated that the maximum likelihood for the doamin of events \( \boldsymbol{D} \) (one-dimensional case)</p>
<p>&nbsp;<br>
$$
\boldsymbol{D}=[(x_0,y_0), (x_1,y_1),\dots, (x_{n-1},y_{n-1})],
$$
<p>&nbsp;<br>

<p>is given by</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{D}\vert\boldsymbol{\beta})=\prod_{i=0}^{n-1}\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]}.
$$
<p>&nbsp;<br>

<p>In Bayes' theorem this function plays the role of the so-called likelihood. We could now ask the question what is the posterior probability of a parameter set \( \boldsymbol{\beta} \) given a domain of events \( \boldsymbol{D} \)?  That is, how can we define the posterior probability </p>

<p>&nbsp;<br>
$$
p(\boldsymbol{\beta}\vert\boldsymbol{D}).
$$
<p>&nbsp;<br>

<p>Bayes' theorem comes to our rescue here since (omitting the normalization constant)</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{\beta}\vert\boldsymbol{D})\propto p(\boldsymbol{D}\vert\boldsymbol{\beta})p(\boldsymbol{\beta}).
$$
<p>&nbsp;<br>

<p>We have a model for \( p(\boldsymbol{D}\vert\boldsymbol{\beta}) \) but need one for the <b>prior</b> \( p(\boldsymbol{\beta} \)!   </p>
</section>

<section>
<h2 id="ridge-and-bayes">Ridge and Bayes </h2>

<p>With the posterior probability defined by a likelihood which we have
already modeled and an unknown prior, we are now ready to make
additional models for the prior.
</p>

<p>We can, based on our discussions of the variance of \( \boldsymbol{\beta} \) and the mean value, assume that the prior for the values \( \boldsymbol{\beta} \) is given by a Gaussian with mean value zero and variance \( \tau^2 \), that is</p>

<p>&nbsp;<br>
$$
p(\boldsymbol{\beta})=\prod_{j=0}^{p-1}\exp{\left(-\frac{\beta_j^2}{2\tau^2}\right)}.
$$
<p>&nbsp;<br>

<p>Our posterior probability becomes then (omitting the normalization factor which is just a constant)</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{\beta\vert\boldsymbol{D})}=\prod_{i=0}^{n-1}\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]}\prod_{j=0}^{p-1}\exp{\left(-\frac{\beta_j^2}{2\tau^2}\right)}.
$$
<p>&nbsp;<br>

<p>We can now optimize this quantity with respect to \( \boldsymbol{\beta} \). As we
did for OLS, this is most conveniently done by taking the negative
logarithm of the posterior probability. Doing so and leaving out the
constants terms that do not depend on \( \beta \), we have
</p>

<p>&nbsp;<br>
$$
C(\boldsymbol{\beta})=\frac{\vert\vert (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\vert\vert_2^2}{2\sigma^2}+\frac{1}{2\tau^2}\vert\vert\boldsymbol{\beta}\vert\vert_2^2,
$$
<p>&nbsp;<br>

<p>and replacing \( 1/2\tau^2 \) with \( \lambda \) we have</p>

<p>&nbsp;<br>
$$
C(\boldsymbol{\beta})=\frac{\vert\vert (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\vert\vert_2^2}{2\sigma^2}+\lambda\vert\vert\boldsymbol{\beta}\vert\vert_2^2,
$$
<p>&nbsp;<br>

<p>which is our Ridge cost function!  Nice, isn't it?</p>
</section>

<section>
<h2 id="lasso-and-bayes">Lasso and Bayes </h2>

<p>To derive the Lasso cost function, we simply replace the Gaussian prior with an exponential distribution (<a href="https://en.wikipedia.org/wiki/Laplace_distribution" target="_blank">Laplace in this case</a>) with zero mean value,  that is</p>

<p>&nbsp;<br>
$$
p(\boldsymbol{\beta})=\prod_{j=0}^{p-1}\exp{\left(-\frac{\vert\beta_j\vert}{\tau}\right)}.
$$
<p>&nbsp;<br>

<p>Our posterior probability becomes then (omitting the normalization factor which is just a constant)</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{\beta}\vert\boldsymbol{D})=\prod_{i=0}^{n-1}\frac{1}{\sqrt{2\pi\sigma^2}}\exp{\left[-\frac{(y_i-\boldsymbol{X}_{i,*}\boldsymbol{\beta})^2}{2\sigma^2}\right]}\prod_{j=0}^{p-1}\exp{\left(-\frac{\vert\beta_j\vert}{\tau}\right)}.
$$
<p>&nbsp;<br>

<p>Taking the negative
logarithm of the posterior probability and leaving out the
constants terms that do not depend on \( \beta \), we have
</p>

<p>&nbsp;<br>
$$
C(\boldsymbol{\beta}=\frac{\vert\vert (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\vert\vert_2^2}{2\sigma^2}+\frac{1}{\tau}\vert\vert\boldsymbol{\beta}\vert\vert_1,
$$
<p>&nbsp;<br>

<p>and replacing \( 1/\tau \) with \( \lambda \) we have</p>

<p>&nbsp;<br>
$$
C(\boldsymbol{\beta}=\frac{\vert\vert (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\vert\vert_2^2}{2\sigma^2}+\lambda\vert\vert\boldsymbol{\beta}\vert\vert_1,
$$
<p>&nbsp;<br>

<p>which is our Lasso cost function!  </p>
</section>

<section>
<h2 id="why-resampling-methods">Why resampling methods </h2>

<p>Before we proceed, we need to rethink what we have been doing. In our
eager to fit the data, we have omitted several important elements in
our regression analysis. In what follows we will
</p>
<ol>
<p><li> look at statistical properties, including a discussion of mean values, variance and the so-called bias-variance tradeoff</li>
<p><li> introduce resampling techniques like cross-validation, bootstrapping and jackknife and more</li>
</ol>
<p>
<p>and discuss how to select a given model (one of the difficult parts in machine learning).</p>
</section>

<section>
<h2 id="resampling-methods">Resampling methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Resampling methods are an indispensable tool in modern
statistics. They involve repeatedly drawing samples from a training
set and refitting a model of interest on each sample in order to
obtain additional information about the fitted model. For example, in
order to estimate the variability of a linear regression fit, we can
repeatedly draw different samples from the training data, fit a linear
regression to each new sample, and then examine the extent to which
the resulting fits differ. Such an approach may allow us to obtain
information that would not be available from fitting the model only
once using the original training sample.
</p>

<p>Two resampling methods are often used in Machine Learning analyses,</p>
<ol>
<p><li> The <b>bootstrap method</b></li>
<p><li> and <b>Cross-Validation</b></li>
</ol>
<p>
<p>In addition there are several other methods such as the Jackknife and the Blocking methods. We will discuss in particular
cross-validation and the bootstrap method. 
</p>
</div>
</section>

<section>
<h2 id="resampling-approaches-can-be-computationally-expensive">Resampling approaches can be computationally expensive </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>Resampling approaches can be computationally expensive, because they
involve fitting the same statistical method multiple times using
different subsets of the training data. However, due to recent
advances in computing power, the computational requirements of
resampling methods generally are not prohibitive. In this chapter, we
discuss two of the most commonly used resampling methods,
cross-validation and the bootstrap. Both methods are important tools
in the practical application of many statistical learning
procedures. For example, cross-validation can be used to estimate the
test error associated with a given statistical learning method in
order to evaluate its performance, or to select the appropriate level
of flexibility. The process of evaluating a model&#8217;s performance is
known as model assessment, whereas the process of selecting the proper
level of flexibility for a model is known as model selection. The
bootstrap is widely used.
</p>
</div>
</section>

<section>
<h2 id="why-resampling-methods">Why resampling methods ? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Statistical analysis</b>
<p>

<ul>
<p><li> Our simulations can be treated as <em>computer experiments</em>. This is particularly the case for Monte Carlo methods which are widely used in statistical analyses.</li>
<p><li> The results can be analysed with the same statistical tools as we would use when analysing experimental data.</li>
<p><li> As in all experiments, we are looking for expectation values and an estimate of how accurate they are, i.e., possible sources for errors.</li>
</ul>
</div>
</section>

<section>
<h2 id="statistical-analysis">Statistical analysis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<ul>
<p><li> As in other experiments, many numerical  experiments have two classes of errors:</li>
<ul>

<p><li> Statistical errors</li>

<p><li> Systematical errors</li>
</ul>
<p>
<p><li> Statistical errors can be estimated using standard tools from statistics</li>
<p><li> Systematical errors are method specific and must be treated differently from case to case.</li> 
</ul>
</div>
</section>

<section>
<h2 id="resampling-methods">Resampling methods </h2>

<p>With all these analytical equations for both the OLS and Ridge
regression, we will now outline how to assess a given model. This will
lead to a discussion of the so-called bias-variance tradeoff (see
below) and so-called resampling methods.
</p>

<p>One of the quantities we have discussed as a way to measure errors is
the mean-squared error (MSE), mainly used for fitting of continuous
functions. Another choice is the absolute error.
</p>

<p>In the discussions below we will focus on the MSE and in particular since we will split the data into test and training data,
we discuss the
</p>
<ol>
<p><li> prediction error or simply the <b>test error</b> \( \mathrm{Err_{Test}} \), where we have a fixed training set and the test error is the MSE arising from the data reserved for testing. We discuss also the</li> 
<p><li> training error \( \mathrm{Err_{Train}} \), which is the average loss over the training data.</li>
</ol>
<p>
<p>As our model becomes more and more complex, more of the training data tends to  used. The training may thence adapt to more complicated structures in the data. This may lead to a decrease in the bias (see below for code example) and a slight increase of the variance for the test error.
For a certain level of complexity the test error will reach minimum, before starting to increase again. The
training error reaches a saturation.
</p>
</section>

<section>
<h2 id="resampling-methods-bootstrap">Resampling methods: Bootstrap </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Bootstrapping is a <a href="https://en.wikipedia.org/wiki/Nonparametric_statistics" target="_blank">non-parametric approach</a> to statistical inference
that substitutes computation for more traditional distributional
assumptions and asymptotic results. Bootstrapping offers a number of
advantages: 
</p>
<ol>
<p><li> The bootstrap is quite general, although there are some cases in which it fails.</li>

<p><li> Because it does not require distributional assumptions (such as normally distributed errors), the bootstrap can provide more accurate inferences when the data are not well behaved or when the sample size is small.</li>

<p><li> It is possible to apply the bootstrap to statistics with sampling distributions that are difficult to derive, even asymptotically.</li> 
<p><li> It is relatively simple to apply the bootstrap to complex data-collection plans (such as stratified and clustered samples).</li>
</ol>
</div>

<p>The textbook by <a href="https://www.cambridge.org/core/books/bootstrap-methods-and-their-application/ED2FD043579F27952363566DC09CBD6A" target="_blank">Davison on the Bootstrap Methods and their Applications</a> provides many more insights and proofs. In this course we will take a more practical approach and use the results and theorems provided in the literature. For those interested in reading more about the bootstrap methods, we recommend the above text and the one by <a href="https://www.routledge.com/An-Introduction-to-the-Bootstrap/Efron-Tibshirani/p/book/9780412042317" target="_blank">Efron and Tibshirani</a>.</p>

<p>Before we proceed however, we need to remind ourselves about a central theorem in statistics, namely the so-called <b>central limit theorem</b>.</p>
</section>

<section>
<h2 id="the-central-limit-theorem">The Central Limit Theorem </h2>

<p>Suppose we have a PDF \( p(x) \) from which we generate  a series \( N \)
of averages \( \mathbb{E}[x_i] \). Each mean value \( \mathbb{E}[x_i] \)
is viewed as the average of a specific measurement, e.g., throwing 
dice 100 times and then taking the average value, or producing a certain
amount of random numbers. 
For notational ease, we set \( \mathbb{E}[x_i]=x_i \) in the discussion
which follows. We do the same for \( \mathbb{E}[z]=z \).
</p>

<p>If we compute the mean \( z \) of \( m \) such mean values \( x_i \)   </p>
<p>&nbsp;<br>
$$
   z=\frac{x_1+x_2+\dots+x_m}{m},
$$
<p>&nbsp;<br>

<p>the question we pose is which is the PDF of the new variable \( z \).</p>
</section>

<section>
<h2 id="finding-the-limit">Finding the Limit </h2>

<p>The probability of obtaining an average value \( z \) is the product of the 
probabilities of obtaining arbitrary individual mean values \( x_i \),
but with the constraint that the average is \( z \). We can express this through
the following expression
</p>
<p>&nbsp;<br>
$$
    \tilde{p}(z)=\int dx_1p(x_1)\int dx_2p(x_2)\dots\int dx_mp(x_m)
    \delta(z-\frac{x_1+x_2+\dots+x_m}{m}),
$$
<p>&nbsp;<br>

<p>where the \( \delta \)-function enbodies the constraint that the mean is \( z \).
All measurements that lead to each individual \( x_i \) are expected to
be independent, which in turn means that we can express \( \tilde{p} \) as the 
product of individual \( p(x_i) \).  The independence assumption is important in the derivation of the central limit theorem.
</p>
</section>

<section>
<h2 id="rewriting-the-delta-function">Rewriting the \( \delta \)-function </h2>

<p>If we use the integral expression for the \( \delta \)-function</p>

<p>&nbsp;<br>
$$
   \delta(z-\frac{x_1+x_2+\dots+x_m}{m})=\frac{1}{2\pi}\int_{-\infty}^{\infty}
   dq\exp{\left(iq(z-\frac{x_1+x_2+\dots+x_m}{m})\right)},
$$
<p>&nbsp;<br>

<p>and inserting \( e^{i\mu q-i\mu q} \) where \( \mu \) is the mean value
we arrive at
</p>
<p>&nbsp;<br>
$$
   \tilde{p}(z)=\frac{1}{2\pi}\int_{-\infty}^{\infty}
   dq\exp{\left(iq(z-\mu)\right)}\left[\int_{-\infty}^{\infty}
   dxp(x)\exp{\left(iq(\mu-x)/m\right)}\right]^m,
$$
<p>&nbsp;<br>

<p>with the integral over \( x \) resulting in</p>

<p>&nbsp;<br>
$$
  \int_{-\infty}^{\infty}dxp(x)\exp{\left(iq(\mu-x)/m\right)}=
  \int_{-\infty}^{\infty}dxp(x)
   \left[1+\frac{iq(\mu-x)}{m}-\frac{q^2(\mu-x)^2}{2m^2}+\dots\right].
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="identifying-terms">Identifying Terms </h2>

<p>The second term on the rhs disappears since this is just the mean and 
employing the definition of \( \sigma^2 \) we have 
</p>
<p>&nbsp;<br>
$$
  \int_{-\infty}^{\infty}dxp(x)e^{\left(iq(\mu-x)/m\right)}=
  1-\frac{q^2\sigma^2}{2m^2}+\dots,
$$
<p>&nbsp;<br>

<p>resulting in </p>

<p>&nbsp;<br>
$$
  \left[\int_{-\infty}^{\infty}dxp(x)\exp{\left(iq(\mu-x)/m\right)}\right]^m\approx
  \left[1-\frac{q^2\sigma^2}{2m^2}+\dots \right]^m,
$$
<p>&nbsp;<br>

<p>and in the limit \( m\rightarrow \infty \) we obtain </p>

<p>&nbsp;<br>
$$
   \tilde{p}(z)=\frac{1}{\sqrt{2\pi}(\sigma/\sqrt{m})}
    \exp{\left(-\frac{(z-\mu)^2}{2(\sigma/\sqrt{m})^2}\right)},
$$
<p>&nbsp;<br>

<p>which is the normal distribution with variance
\( \sigma^2_m=\sigma^2/m \), where \( \sigma \) is the variance of the PDF \( p(x) \)
and \( \mu \) is also the mean of the PDF \( p(x) \). 
</p>
</section>

<section>
<h2 id="wrapping-it-up">Wrapping it up </h2>

<p>Thus, the central limit theorem states that the PDF \( \tilde{p}(z) \) of
the average of \( m \) random values corresponding to a PDF \( p(x) \) 
is a normal distribution whose mean is the 
mean value of the PDF \( p(x) \) and whose variance is the variance
of the PDF \( p(x) \) divided by \( m \), the number of values used to compute \( z \).
</p>

<p>The central limit theorem leads to the well-known expression for the
standard deviation, given by 
</p>

<p>&nbsp;<br>
$$
    \sigma_m=
\frac{\sigma}{\sqrt{m}}.
$$
<p>&nbsp;<br>

<p>The latter is true only if the average value is known exactly. This is obtained in the limit
\( m\rightarrow \infty \)  only. Because the mean and the variance are measured quantities we obtain 
the familiar expression in statistics (the so-called Bessel correction)
</p>
<p>&nbsp;<br>
$$
    \sigma_m\approx 
\frac{\sigma}{\sqrt{m-1}}.
$$
<p>&nbsp;<br>

<p>In many cases however the above estimate for the standard deviation,
in particular if correlations are strong, may be too simplistic. Keep
in mind that we have assumed that the variables \( x \) are independent
and identically distributed. This is obviously not always the
case. For example, the random numbers (or better pseudorandom numbers)
we generate in various calculations do always exhibit some
correlations.
</p>

<p>The theorem is satisfied by a large class of PDFs. Note however that for a
finite \( m \), it is not always possible to find a closed form /analytic expression for
\( \tilde{p}(x) \).
</p>
</section>

<section>
<h2 id="confidence-intervals">Confidence Intervals </h2>

<p>Confidence intervals are used in statistics and represent a type of estimate
computed from the observed data. This gives a range of values for an
unknown parameter such as the parameters \( \boldsymbol{\beta} \) from linear regression.
</p>

<p>With the OLS expressions for the parameters \( \boldsymbol{\beta} \) we found 
\( \mathbb{E}(\boldsymbol{\beta}) = \boldsymbol{\beta} \), which means that the estimator of the regression parameters is unbiased.
</p>

<p>We found also that the variance of the estimate of the \( j \)-th regression coefficient is
\( \boldsymbol{\sigma}^2 (\boldsymbol{\beta}_j ) = \boldsymbol{\sigma}^2 [(\mathbf{X}^{T} \mathbf{X})^{-1}]_{jj}  \).
</p>

<p>This quantity will be used to
construct a confidence interval for the estimates.
</p>
</section>

<section>
<h2 id="standard-approach-based-on-the-normal-distribution">Standard Approach based on the Normal Distribution </h2>

<p>We will assume that the parameters \( \beta \) follow a normal
distribution.  We can then define the confidence interval.  Here we will be using as
shorthands \( \mu_{\beta} \) for the above mean value and \( \sigma_{\beta} \)
for the standard deviation. We have then a confidence interval
</p>

<p>&nbsp;<br>
$$
\left(\mu_{\beta}\pm \frac{z\sigma_{\beta}}{\sqrt{n}}\right),
$$
<p>&nbsp;<br>

<p>where \( z \) defines the level of certainty (or confidence). For a normal
distribution typical parameters are \( z=2.576 \) which corresponds to a
confidence of \( 99\% \) while \( z=1.96 \) corresponds to a confidence of
\( 95\% \).  A confidence level of \( 95\% \) is commonly used and it is
normally referred to as a <em>two-sigmas</em> confidence level, that is we
approximate \( z\approx 2 \).
</p>

<p>For more discussions of confidence intervals (and in particular linked with a discussion of the bootstrap method), see chapter 5 of the textbook by <a href="https://www.cambridge.org/core/books/bootstrap-methods-and-their-application/ED2FD043579F27952363566DC09CBD6A" target="_blank">Davison on the Bootstrap Methods and their Applications</a></p>

<p>In this text you will also find an in-depth discussion of the
Bootstrap method, why it works and various theorems related to it. 
</p>
</section>

<section>
<h2 id="resampling-methods-bootstrap-background">Resampling methods: Bootstrap background </h2>

<p>Since \( \widehat{\beta} = \widehat{\beta}(\boldsymbol{X}) \) is a function of random variables,
\( \widehat{\beta} \) itself must be a random variable. Thus it has
a pdf, call this function \( p(\boldsymbol{t}) \). The aim of the bootstrap is to
estimate \( p(\boldsymbol{t}) \) by the relative frequency of
\( \widehat{\beta} \). You can think of this as using a histogram
in the place of \( p(\boldsymbol{t}) \). If the relative frequency closely
resembles \( p(\vec{t}) \), then using numerics, it is straight forward to
estimate all the interesting parameters of \( p(\boldsymbol{t}) \) using point
estimators.  
</p>
</section>

<section>
<h2 id="resampling-methods-more-bootstrap-background">Resampling methods: More Bootstrap background </h2>

<p>In the case that \( \widehat{\beta} \) has
more than one component, and the components are independent, we use the
same estimator on each component separately.  If the probability
density function of \( X_i \), \( p(x) \), had been known, then it would have
been straightforward to do this by: 
</p>
<ol>
<p><li> Drawing lots of numbers from \( p(x) \), suppose we call one such set of numbers \( (X_1^*, X_2^*, \cdots, X_n^*) \).</li> 
<p><li> Then using these numbers, we could compute a replica of \( \widehat{\beta} \) called \( \widehat{\beta}^* \).</li> 
</ol>
<p>
<p>By repeated use of the above two points, many
estimates of \( \widehat{\beta} \) can  be obtained. The
idea is to use the relative frequency of \( \widehat{\beta}^* \)
(think of a histogram) as an estimate of \( p(\boldsymbol{t}) \).
</p>
</section>

<section>
<h2 id="resampling-methods-bootstrap-approach">Resampling methods: Bootstrap approach </h2>

<p>But
unless there is enough information available about the process that
generated \( X_1,X_2,\cdots,X_n \), \( p(x) \) is in general
unknown. Therefore, <a href="https://projecteuclid.org/euclid.aos/1176344552" target="_blank">Efron in 1979</a>  asked the
question: What if we replace \( p(x) \) by the relative frequency
of the observation \( X_i \)?
</p>

<p>If we draw observations in accordance with
the relative frequency of the observations, will we obtain the same
result in some asymptotic sense? The answer is yes.
</p>
</section>

<section>
<h2 id="resampling-methods-bootstrap-steps">Resampling methods: Bootstrap steps </h2>

<p>The independent bootstrap works like this: </p>

<ol>
<p><li> Draw with replacement \( n \) numbers for the observed variables \( \boldsymbol{x} = (x_1,x_2,\cdots,x_n) \).</li> 
<p><li> Define a vector \( \boldsymbol{x}^* \) containing the values which were drawn from \( \boldsymbol{x} \).</li> 
<p><li> Using the vector \( \boldsymbol{x}^* \) compute \( \widehat{\beta}^* \) by evaluating \( \widehat \beta \) under the observations \( \boldsymbol{x}^* \).</li> 
<p><li> Repeat this process \( k \) times.</li> 
</ol>
<p>
<p>When you are done, you can draw a histogram of the relative frequency
of \( \widehat \beta^* \). This is your estimate of the probability
distribution \( p(t) \). Using this probability distribution you can
estimate any statistics thereof. In principle you never draw the
histogram of the relative frequency of \( \widehat{\beta}^* \). Instead
you use the estimators corresponding to the statistic of interest. For
example, if you are interested in estimating the variance of \( \widehat
\beta \), apply the etsimator \( \widehat \sigma^2 \) to the values
\( \widehat \beta^* \).
</p>
</section>

<section>
<h2 id="code-example-for-the-bootstrap-method">Code example for the Bootstrap method </h2>

<p>The following code starts with a Gaussian distribution with mean value
\( \mu =100 \) and variance \( \sigma=15 \). We use this to generate the data
used in the bootstrap analysis. The bootstrap analysis returns a data
set after a given number of bootstrap operations (as many as we have
data points). This data set consists of estimated mean values for each
bootstrap operation. The histogram generated by the bootstrap method
shows that the distribution for these mean values is also a Gaussian,
centered around the mean value \( \mu=100 \) but with standard deviation
\( \sigma/\sqrt{n} \), where \( n \) is the number of bootstrap samples (in
this case the same as the number of original data points). The value
of the standard deviation is what we expect from the central limit
theorem.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">time</span> <span style="color: #8B008B; font-weight: bold">import</span> time
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy.stats</span> <span style="color: #8B008B; font-weight: bold">import</span> norm
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #228B22"># Returns mean of bootstrap samples </span>
<span style="color: #228B22"># Bootstrap algorithm</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">bootstrap</span>(data, datapoints):
    t = np.zeros(datapoints)
    n = <span style="color: #658b00">len</span>(data)
    <span style="color: #228B22"># non-parametric bootstrap         </span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(datapoints):
        t[i] = np.mean(data[np.random.randint(<span style="color: #B452CD">0</span>,n,n)])
    <span style="color: #228B22"># analysis    </span>
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Bootstrap Statistics :&quot;</span>)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;original           bias      std. error&quot;</span>)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;%8g %8g %14g %15g&quot;</span> % (np.mean(data), np.std(data),np.mean(t),np.std(t)))
    <span style="color: #8B008B; font-weight: bold">return</span> t

<span style="color: #228B22"># We set the mean value to 100 and the standard deviation to 15</span>
mu, sigma = <span style="color: #B452CD">100</span>, <span style="color: #B452CD">15</span>
datapoints = <span style="color: #B452CD">10000</span>
<span style="color: #228B22"># We generate random numbers according to the normal distribution</span>
x = mu + sigma*np.random.randn(datapoints)
<span style="color: #228B22"># bootstrap returns the data sample                                    </span>
t = bootstrap(x, datapoints)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We see that our new variance and from that the standard deviation, agrees with the central limit theorem.</p>
</section>

<section>
<h2 id="plotting-the-histogram">Plotting the Histogram </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># the histogram of the bootstrapped data (normalized data if density = True)</span>
n, binsboot, patches = plt.hist(t, <span style="color: #B452CD">50</span>, density=<span style="color: #8B008B; font-weight: bold">True</span>, facecolor=<span style="color: #CD5555">&#39;red&#39;</span>, alpha=<span style="color: #B452CD">0.75</span>)
<span style="color: #228B22"># add a &#39;best fit&#39; line  </span>
y = norm.pdf(binsboot, np.mean(t), np.std(t))
lt = plt.plot(binsboot, y, <span style="color: #CD5555">&#39;b&#39;</span>, linewidth=<span style="color: #B452CD">1</span>)
plt.xlabel(<span style="color: #CD5555">&#39;x&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;Probability&#39;</span>)
plt.grid(<span style="color: #8B008B; font-weight: bold">True</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="the-bias-variance-tradeoff">The bias-variance tradeoff </h2>

<p>We will discuss the bias-variance tradeoff in the context of
continuous predictions such as regression. However, many of the
intuitions and ideas discussed here also carry over to classification
tasks. Consider a dataset \( \mathcal{D} \) consisting of the data
\( \mathbf{X}_\mathcal{D}=\{(y_j, \boldsymbol{x}_j), j=0\ldots n-1\} \). 
</p>

<p>Let us assume that the true data is generated from a noisy model</p>

<p>&nbsp;<br>
$$
\boldsymbol{y}=f(\boldsymbol{x}) + \boldsymbol{\epsilon}
$$
<p>&nbsp;<br>

<p>where \( \epsilon \) is normally distributed with mean zero and standard deviation \( \sigma^2 \).</p>

<p>In our derivation of the ordinary least squares method we defined then
an approximation to the function \( f \) in terms of the parameters
\( \boldsymbol{\beta} \) and the design matrix \( \boldsymbol{X} \) which embody our model,
that is \( \boldsymbol{\tilde{y}}=\boldsymbol{X}\boldsymbol{\beta} \). 
</p>

<p>Thereafter we found the parameters \( \boldsymbol{\beta} \) by optimizing the means squared error via the so-called cost function</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{X},\boldsymbol{\beta}) =\frac{1}{n}\sum_{i=0}^{n-1}(y_i-\tilde{y}_i)^2=\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right].
$$
<p>&nbsp;<br>

<p>We can rewrite this as </p>
<p>&nbsp;<br>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\frac{1}{n}\sum_i(f_i-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2+\frac{1}{n}\sum_i(\tilde{y}_i-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2+\sigma^2.
$$
<p>&nbsp;<br>

<p>The three terms represent the square of the bias of the learning
method, which can be thought of as the error caused by the simplifying
assumptions built into the method. The second term represents the
variance of the chosen model and finally the last terms is variance of
the error \( \boldsymbol{\epsilon} \).
</p>

<p>To derive this equation, we need to recall that the variance of \( \boldsymbol{y} \) and \( \boldsymbol{\epsilon} \) are both equal to \( \sigma^2 \). The mean value of \( \boldsymbol{\epsilon} \) is by definition equal to zero. Furthermore, the function \( f \) is not a stochastics variable, idem for \( \boldsymbol{\tilde{y}} \).
We use a more compact notation in terms of the expectation value 
</p>
<p>&nbsp;<br>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\mathbb{E}\left[(\boldsymbol{f}+\boldsymbol{\epsilon}-\boldsymbol{\tilde{y}})^2\right],
$$
<p>&nbsp;<br>

<p>and adding and subtracting \( \mathbb{E}\left[\boldsymbol{\tilde{y}}\right] \) we get</p>
<p>&nbsp;<br>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\mathbb{E}\left[(\boldsymbol{f}+\boldsymbol{\epsilon}-\boldsymbol{\tilde{y}}+\mathbb{E}\left[\boldsymbol{\tilde{y}}\right]-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2\right],
$$
<p>&nbsp;<br>

<p>which, using the abovementioned expectation values can be rewritten as </p>
<p>&nbsp;<br>
$$
\mathbb{E}\left[(\boldsymbol{y}-\boldsymbol{\tilde{y}})^2\right]=\mathbb{E}\left[(\boldsymbol{y}-\mathbb{E}\left[\boldsymbol{\tilde{y}}\right])^2\right]+\mathrm{Var}\left[\boldsymbol{\tilde{y}}\right]+\sigma^2,
$$
<p>&nbsp;<br>

<p>that is the rewriting in terms of the so-called bias, the variance of the model \( \boldsymbol{\tilde{y}} \) and the variance of \( \boldsymbol{\epsilon} \).</p>
</section>

<section>
<h2 id="a-way-to-read-the-bias-variance-tradeoff">A way to Read the Bias-Variance Tradeoff </h2>

<br/><br/>
<center>
<p><img src="figures/BiasVariance.png" width="600" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="example-code-for-bias-variance-tradeoff">Example code for Bias-Variance tradeoff </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.pipeline</span> <span style="color: #8B008B; font-weight: bold">import</span> make_pipeline
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> resample

np.random.seed(<span style="color: #B452CD">2018</span>)

n = <span style="color: #B452CD">500</span>
n_boostraps = <span style="color: #B452CD">100</span>
degree = <span style="color: #B452CD">18</span>  <span style="color: #228B22"># A quite high value, just to show.</span>
noise = <span style="color: #B452CD">0.1</span>

<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">3</span>, n).reshape(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
y = np.exp(-x**<span style="color: #B452CD">2</span>) + <span style="color: #B452CD">1.5</span> * np.exp(-(x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>) + np.random.normal(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.1</span>, x.shape)

<span style="color: #228B22"># Hold out some test data that is never used in training.</span>
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span style="color: #B452CD">0.2</span>)

<span style="color: #228B22"># Combine x transformation and model into one operation.</span>
<span style="color: #228B22"># Not neccesary, but convenient.</span>
model = make_pipeline(PolynomialFeatures(degree=degree), LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>))

<span style="color: #228B22"># The following (m x n_bootstraps) matrix holds the column vectors y_pred</span>
<span style="color: #228B22"># for each bootstrap iteration.</span>
y_pred = np.empty((y_test.shape[<span style="color: #B452CD">0</span>], n_boostraps))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n_boostraps):
    x_, y_ = resample(x_train, y_train)

    <span style="color: #228B22"># Evaluate the new model on the same test data each time.</span>
    y_pred[:, i] = model.fit(x_, y_).predict(x_test).ravel()

<span style="color: #228B22"># Note: Expectations and variances taken w.r.t. different training</span>
<span style="color: #228B22"># data sets, hence the axis=1. Subsequent means are taken across the test data</span>
<span style="color: #228B22"># set in order to obtain a total value, but before this we have error/bias/variance</span>
<span style="color: #228B22"># calculated per data point in the test set.</span>
<span style="color: #228B22"># Note 2: The use of keepdims=True is important in the calculation of bias as this </span>
<span style="color: #228B22"># maintains the column vector form. Dropping this yields very unexpected results.</span>
error = np.mean( np.mean((y_test - y_pred)**<span style="color: #B452CD">2</span>, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>) )
bias = np.mean( (y_test - np.mean(y_pred, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>))**<span style="color: #B452CD">2</span> )
variance = np.mean( np.var(y_pred, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>) )
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Error:&#39;</span>, error)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Bias^2:&#39;</span>, bias)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Var:&#39;</span>, variance)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;{} &gt;= {} + {} = {}&#39;</span>.format(error, bias, variance, bias+variance))

plt.plot(x[::<span style="color: #B452CD">5</span>, :], y[::<span style="color: #B452CD">5</span>, :], label=<span style="color: #CD5555">&#39;f(x)&#39;</span>)
plt.scatter(x_test, y_test, label=<span style="color: #CD5555">&#39;Data points&#39;</span>)
plt.scatter(x_test, np.mean(y_pred, axis=<span style="color: #B452CD">1</span>), label=<span style="color: #CD5555">&#39;Pred&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="understanding-what-happens">Understanding what happens </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.pipeline</span> <span style="color: #8B008B; font-weight: bold">import</span> make_pipeline
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> resample

np.random.seed(<span style="color: #B452CD">2018</span>)

n = <span style="color: #B452CD">40</span>
n_boostraps = <span style="color: #B452CD">100</span>
maxdegree = <span style="color: #B452CD">14</span>


<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n).reshape(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
y = np.exp(-x**<span style="color: #B452CD">2</span>) + <span style="color: #B452CD">1.5</span> * np.exp(-(x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>)+ np.random.normal(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.1</span>, x.shape)
error = np.zeros(maxdegree)
bias = np.zeros(maxdegree)
variance = np.zeros(maxdegree)
polydegree = np.zeros(maxdegree)
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span style="color: #B452CD">0.2</span>)

<span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(maxdegree):
    model = make_pipeline(PolynomialFeatures(degree=degree), LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>))
    y_pred = np.empty((y_test.shape[<span style="color: #B452CD">0</span>], n_boostraps))
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n_boostraps):
        x_, y_ = resample(x_train, y_train)
        y_pred[:, i] = model.fit(x_, y_).predict(x_test).ravel()

    polydegree[degree] = degree
    error[degree] = np.mean( np.mean((y_test - y_pred)**<span style="color: #B452CD">2</span>, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>) )
    bias[degree] = np.mean( (y_test - np.mean(y_pred, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>))**<span style="color: #B452CD">2</span> )
    variance[degree] = np.mean( np.var(y_pred, axis=<span style="color: #B452CD">1</span>, keepdims=<span style="color: #8B008B; font-weight: bold">True</span>) )
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Polynomial degree:&#39;</span>, degree)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Error:&#39;</span>, error[degree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Bias^2:&#39;</span>, bias[degree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Var:&#39;</span>, variance[degree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;{} &gt;= {} + {} = {}&#39;</span>.format(error[degree], bias[degree], variance[degree], bias[degree]+variance[degree]))

plt.plot(polydegree, error, label=<span style="color: #CD5555">&#39;Error&#39;</span>)
plt.plot(polydegree, bias, label=<span style="color: #CD5555">&#39;bias&#39;</span>)
plt.plot(polydegree, variance, label=<span style="color: #CD5555">&#39;Variance&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="summing-up">Summing up </h2>

<p>The bias-variance tradeoff summarizes the fundamental tension in
machine learning, particularly supervised learning, between the
complexity of a model and the amount of training data needed to train
it.  Since data is often limited, in practice it is often useful to
use a less-complex model with higher bias, that is  a model whose asymptotic
performance is worse than another model because it is easier to
train and less sensitive to sampling noise arising from having a
finite-sized training dataset (smaller variance). 
</p>

<p>The above equations tell us that in
order to minimize the expected test error, we need to select a
statistical learning method that simultaneously achieves low variance
and low bias. Note that variance is inherently a nonnegative quantity,
and squared bias is also nonnegative. Hence, we see that the expected
test MSE can never lie below \( Var(\epsilon) \), the irreducible error.
</p>

<p>What do we mean by the variance and bias of a statistical learning
method? The variance refers to the amount by which our model would change if we
estimated it using a different training data set. Since the training
data are used to fit the statistical learning method, different
training data sets  will result in a different estimate. But ideally the
estimate for our model should not vary too much between training
sets. However, if a method has high variance  then small changes in
the training data can result in large changes in the model. In general, more
flexible statistical methods have higher variance.
</p>

<p>You may also find this recent <a href="https://www.pnas.org/content/116/32/15849" target="_blank">article</a> of interest.</p>
</section>

<section>
<h2 id="another-example-from-scikit-learn-s-repository">Another Example from Scikit-Learn's Repository </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">============================</span>
<span style="color: #CD5555">Underfitting vs. Overfitting</span>
<span style="color: #CD5555">============================</span>

<span style="color: #CD5555">This example demonstrates the problems of underfitting and overfitting and</span>
<span style="color: #CD5555">how we can use linear regression with polynomial features to approximate</span>
<span style="color: #CD5555">nonlinear functions. The plot shows the function that we want to approximate,</span>
<span style="color: #CD5555">which is a part of the cosine function. In addition, the samples from the</span>
<span style="color: #CD5555">real function and the approximations of different models are displayed. The</span>
<span style="color: #CD5555">models have polynomial features of different degrees. We can see that a</span>
<span style="color: #CD5555">linear function (polynomial with degree 1) is not sufficient to fit the</span>
<span style="color: #CD5555">training samples. This is called **underfitting**. A polynomial of degree 4</span>
<span style="color: #CD5555">approximates the true function almost perfectly. However, for higher degrees</span>
<span style="color: #CD5555">the model will **overfit** the training data, i.e. it learns the noise of the</span>
<span style="color: #CD5555">training data.</span>
<span style="color: #CD5555">We evaluate quantitatively **overfitting** / **underfitting** by using</span>
<span style="color: #CD5555">cross-validation. We calculate the mean squared error (MSE) on the validation</span>
<span style="color: #CD5555">set, the higher, the less likely the model generalizes correctly from the</span>
<span style="color: #CD5555">training data.</span>
<span style="color: #CD5555">&quot;&quot;&quot;</span>

<span style="color: #658b00">print</span>(<span style="color: #00688B">__doc__</span>)

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.pipeline</span> <span style="color: #8B008B; font-weight: bold">import</span> Pipeline
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> cross_val_score


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">true_fun</span>(X):
    <span style="color: #8B008B; font-weight: bold">return</span> np.cos(<span style="color: #B452CD">1.5</span> * np.pi * X)

np.random.seed(<span style="color: #B452CD">0</span>)

n_samples = <span style="color: #B452CD">30</span>
degrees = [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">4</span>, <span style="color: #B452CD">15</span>]

X = np.sort(np.random.rand(n_samples))
y = true_fun(X) + np.random.randn(n_samples) * <span style="color: #B452CD">0.1</span>

plt.figure(figsize=(<span style="color: #B452CD">14</span>, <span style="color: #B452CD">5</span>))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(degrees)):
    ax = plt.subplot(<span style="color: #B452CD">1</span>, <span style="color: #658b00">len</span>(degrees), i + <span style="color: #B452CD">1</span>)
    plt.setp(ax, xticks=(), yticks=())

    polynomial_features = PolynomialFeatures(degree=degrees[i],
                                             include_bias=<span style="color: #8B008B; font-weight: bold">False</span>)
    linear_regression = LinearRegression()
    pipeline = Pipeline([(<span style="color: #CD5555">&quot;polynomial_features&quot;</span>, polynomial_features),
                         (<span style="color: #CD5555">&quot;linear_regression&quot;</span>, linear_regression)])
    pipeline.fit(X[:, np.newaxis], y)

    <span style="color: #228B22"># Evaluate the models using crossvalidation</span>
    scores = cross_val_score(pipeline, X[:, np.newaxis], y,
                             scoring=<span style="color: #CD5555">&quot;neg_mean_squared_error&quot;</span>, cv=<span style="color: #B452CD">10</span>)

    X_test = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">100</span>)
    plt.plot(X_test, pipeline.predict(X_test[:, np.newaxis]), label=<span style="color: #CD5555">&quot;Model&quot;</span>)
    plt.plot(X_test, true_fun(X_test), label=<span style="color: #CD5555">&quot;True function&quot;</span>)
    plt.scatter(X, y, edgecolor=<span style="color: #CD5555">&#39;b&#39;</span>, s=<span style="color: #B452CD">20</span>, label=<span style="color: #CD5555">&quot;Samples&quot;</span>)
    plt.xlabel(<span style="color: #CD5555">&quot;x&quot;</span>)
    plt.ylabel(<span style="color: #CD5555">&quot;y&quot;</span>)
    plt.xlim((<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>))
    plt.ylim((-<span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>))
    plt.legend(loc=<span style="color: #CD5555">&quot;best&quot;</span>)
    plt.title(<span style="color: #CD5555">&quot;Degree {}\nMSE = {:.2e}(+/- {:.2e})&quot;</span>.format(
        degrees[i], -scores.mean(), scores.std()))
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="various-steps-in-cross-validation">Various steps in cross-validation </h2>

<p>When the repetitive splitting of the data set is done randomly,
samples may accidently end up in a fast majority of the splits in
either training or test set. Such samples may have an unbalanced
influence on either model building or prediction evaluation. To avoid
this \( k \)-fold cross-validation structures the data splitting. The
samples are divided into \( k \) more or less equally sized exhaustive and
mutually exclusive subsets. In turn (at each split) one of these
subsets plays the role of the test set while the union of the
remaining subsets constitutes the training set. Such a splitting
warrants a balanced representation of each sample in both training and
test set over the splits. Still the division into the \( k \) subsets
involves a degree of randomness. This may be fully excluded when
choosing \( k=n \). This particular case is referred to as leave-one-out
cross-validation (LOOCV). 
</p>
</section>

<section>
<h2 id="cross-validation-in-brief">Cross-validation in brief </h2>

<p>For the various values of \( k \)</p>

<ol>
<p><li> shuffle the dataset randomly.</li>
<p><li> Split the dataset into \( k \) groups.</li>
<p><li> For each unique group:
<ol type="a"></li>
<p><li> Decide which group to use as set for test data</li>
<p><li> Take the remaining groups as a training data set</li>
<p><li> Fit a model on the training set and evaluate it on the test set</li>
<p><li> Retain the evaluation score and discard the model</li>
</ol>
<p>
<p><li> Summarize the model using the sample of model evaluation scores</li>
</ol>
</section>

<section>
<h2 id="code-example-for-cross-validation-and-k-fold-cross-validation">Code Example for Cross-validation and \( k \)-fold Cross-validation </h2>

<p>The code here uses Ridge regression with cross-validation (CV)  resampling and \( k \)-fold CV in order to fit a specific polynomial. </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> KFold
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> Ridge
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> cross_val_score
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures

<span style="color: #228B22"># A seed just to ensure that the random numbers are the same for every run.</span>
<span style="color: #228B22"># Useful for eventual debugging.</span>
np.random.seed(<span style="color: #B452CD">3155</span>)

<span style="color: #228B22"># Generate the data.</span>
nsamples = <span style="color: #B452CD">100</span>
x = np.random.randn(nsamples)
y = <span style="color: #B452CD">3</span>*x**<span style="color: #B452CD">2</span> + np.random.randn(nsamples)

<span style="color: #228B22">## Cross-validation on Ridge regression using KFold only</span>

<span style="color: #228B22"># Decide degree on polynomial to fit</span>
poly = PolynomialFeatures(degree = <span style="color: #B452CD">6</span>)

<span style="color: #228B22"># Decide which values of lambda to use</span>
nlambdas = <span style="color: #B452CD">500</span>
lambdas = np.logspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">5</span>, nlambdas)

<span style="color: #228B22"># Initialize a KFold instance</span>
k = <span style="color: #B452CD">5</span>
kfold = KFold(n_splits = k)

<span style="color: #228B22"># Perform the cross-validation to estimate MSE</span>
scores_KFold = np.zeros((nlambdas, k))

i = <span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> lmb <span style="color: #8B008B">in</span> lambdas:
    ridge = Ridge(alpha = lmb)
    j = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> train_inds, test_inds <span style="color: #8B008B">in</span> kfold.split(x):
        xtrain = x[train_inds]
        ytrain = y[train_inds]

        xtest = x[test_inds]
        ytest = y[test_inds]

        Xtrain = poly.fit_transform(xtrain[:, np.newaxis])
        ridge.fit(Xtrain, ytrain[:, np.newaxis])

        Xtest = poly.fit_transform(xtest[:, np.newaxis])
        ypred = ridge.predict(Xtest)

        scores_KFold[i,j] = np.sum((ypred - ytest[:, np.newaxis])**<span style="color: #B452CD">2</span>)/np.size(ypred)

        j += <span style="color: #B452CD">1</span>
    i += <span style="color: #B452CD">1</span>


estimated_mse_KFold = np.mean(scores_KFold, axis = <span style="color: #B452CD">1</span>)

<span style="color: #228B22">## Cross-validation using cross_val_score from sklearn along with KFold</span>

<span style="color: #228B22"># kfold is an instance initialized above as:</span>
<span style="color: #228B22"># kfold = KFold(n_splits = k)</span>

estimated_mse_sklearn = np.zeros(nlambdas)
i = <span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> lmb <span style="color: #8B008B">in</span> lambdas:
    ridge = Ridge(alpha = lmb)

    X = poly.fit_transform(x[:, np.newaxis])
    estimated_mse_folds = cross_val_score(ridge, X, y[:, np.newaxis], scoring=<span style="color: #CD5555">&#39;neg_mean_squared_error&#39;</span>, cv=kfold)

    <span style="color: #228B22"># cross_val_score return an array containing the estimated negative mse for every fold.</span>
    <span style="color: #228B22"># we have to the the mean of every array in order to get an estimate of the mse of the model</span>
    estimated_mse_sklearn[i] = np.mean(-estimated_mse_folds)

    i += <span style="color: #B452CD">1</span>

<span style="color: #228B22">## Plot and compare the slightly different ways to perform cross-validation</span>

plt.figure()

plt.plot(np.log10(lambdas), estimated_mse_sklearn, label = <span style="color: #CD5555">&#39;cross_val_score&#39;</span>)
plt.plot(np.log10(lambdas), estimated_mse_KFold, <span style="color: #CD5555">&#39;r--&#39;</span>, label = <span style="color: #CD5555">&#39;KFold&#39;</span>)

plt.xlabel(<span style="color: #CD5555">&#39;log10(lambda)&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;mse&#39;</span>)

plt.legend()

plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="more-examples-on-bootstrap-and-cross-validation-and-errors">More examples on bootstrap and cross-validation and errors </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> resample
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

infile = <span style="color: #658b00">open</span>(data_path(<span style="color: #CD5555">&quot;EoS.csv&quot;</span>),<span style="color: #CD5555">&#39;r&#39;</span>)

<span style="color: #228B22"># Read the EoS data as  csv file and organize the data into two arrays with density and energies</span>
EoS = pd.read_csv(infile, names=(<span style="color: #CD5555">&#39;Density&#39;</span>, <span style="color: #CD5555">&#39;Energy&#39;</span>))
EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>] = pd.to_numeric(EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>], errors=<span style="color: #CD5555">&#39;coerce&#39;</span>)
EoS = EoS.dropna()
Energies = EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>]
Density = EoS[<span style="color: #CD5555">&#39;Density&#39;</span>]
<span style="color: #228B22">#  The design matrix now as function of various polytrops</span>

Maxpolydegree = <span style="color: #B452CD">30</span>
X = np.zeros((<span style="color: #658b00">len</span>(Density),Maxpolydegree))
X[:,<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1.0</span>
testerror = np.zeros(Maxpolydegree)
trainingerror = np.zeros(Maxpolydegree)
polynomial = np.zeros(Maxpolydegree)

trials = <span style="color: #B452CD">100</span>
<span style="color: #8B008B; font-weight: bold">for</span> polydegree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Maxpolydegree):
    polynomial[polydegree] = polydegree
    <span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(polydegree):
        X[:,degree] = Density**(degree/<span style="color: #B452CD">3.0</span>)

<span style="color: #228B22"># loop over trials in order to estimate the expectation value of the MSE</span>
    testerror[polydegree] = <span style="color: #B452CD">0.0</span>
    trainingerror[polydegree] = <span style="color: #B452CD">0.0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> samples <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(trials):
        x_train, x_test, y_train, y_test = train_test_split(X, Energies, test_size=<span style="color: #B452CD">0.2</span>)
        model = LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>).fit(x_train, y_train)
        ypred = model.predict(x_train)
        ytilde = model.predict(x_test)
        testerror[polydegree] += mean_squared_error(y_test, ytilde)
        trainingerror[polydegree] += mean_squared_error(y_train, ypred) 

    testerror[polydegree] /= trials
    trainingerror[polydegree] /= trials
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Degree of polynomial: %3d&quot;</span>% polynomial[polydegree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Mean squared error on training data: %.8f&quot;</span> % trainingerror[polydegree])
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Mean squared error on test data: %.8f&quot;</span> % testerror[polydegree])

plt.plot(polynomial, np.log10(trainingerror), label=<span style="color: #CD5555">&#39;Training Error&#39;</span>)
plt.plot(polynomial, np.log10(testerror), label=<span style="color: #CD5555">&#39;Test Error&#39;</span>)
plt.xlabel(<span style="color: #CD5555">&#39;Polynomial degree&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;log10[MSE]&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that we kept the intercept column in the fitting here. This means that we need to set the <b>intercept</b> in the call to the <b>Scikit-Learn</b> function as <b>False</b>. Alternatively, we could have set up the design matrix \( X \) without the first column of ones.</p>
</section>

<section>
<h2 id="the-same-example-but-now-with-cross-validation">The same example but now with cross-validation </h2>

<p>In this example we keep the intercept column again but add cross-validation in order to estimate the best possible value of the means squared error.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression, Ridge, Lasso
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> KFold
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> cross_val_score


<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

infile = <span style="color: #658b00">open</span>(data_path(<span style="color: #CD5555">&quot;EoS.csv&quot;</span>),<span style="color: #CD5555">&#39;r&#39;</span>)

<span style="color: #228B22"># Read the EoS data as  csv file and organize the data into two arrays with density and energies</span>
EoS = pd.read_csv(infile, names=(<span style="color: #CD5555">&#39;Density&#39;</span>, <span style="color: #CD5555">&#39;Energy&#39;</span>))
EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>] = pd.to_numeric(EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>], errors=<span style="color: #CD5555">&#39;coerce&#39;</span>)
EoS = EoS.dropna()
Energies = EoS[<span style="color: #CD5555">&#39;Energy&#39;</span>]
Density = EoS[<span style="color: #CD5555">&#39;Density&#39;</span>]
<span style="color: #228B22">#  The design matrix now as function of various polytrops</span>

Maxpolydegree = <span style="color: #B452CD">30</span>
X = np.zeros((<span style="color: #658b00">len</span>(Density),Maxpolydegree))
X[:,<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1.0</span>
estimated_mse_sklearn = np.zeros(Maxpolydegree)
polynomial = np.zeros(Maxpolydegree)
k =<span style="color: #B452CD">5</span>
kfold = KFold(n_splits = k)

<span style="color: #8B008B; font-weight: bold">for</span> polydegree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Maxpolydegree):
    polynomial[polydegree] = polydegree
    <span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(polydegree):
        X[:,degree] = Density**(degree/<span style="color: #B452CD">3.0</span>)
        OLS = LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>)
<span style="color: #228B22"># loop over trials in order to estimate the expectation value of the MSE</span>
    estimated_mse_folds = cross_val_score(OLS, X, Energies, scoring=<span style="color: #CD5555">&#39;neg_mean_squared_error&#39;</span>, cv=kfold)
<span style="color: #228B22">#[:, np.newaxis]</span>
    estimated_mse_sklearn[polydegree] = np.mean(-estimated_mse_folds)

plt.plot(polynomial, np.log10(estimated_mse_sklearn), label=<span style="color: #CD5555">&#39;Test Error&#39;</span>)
plt.xlabel(<span style="color: #CD5555">&#39;Polynomial degree&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;log10[MSE]&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h2 id="notes-on-scaling-with-examples">Notes on scaling with examples </h2>

<p>The programs here use both ordinrary least squares (OLS) and Ridge
regression with one value only for the hyperparameter \( \lambda \). The
first example has no scaling and includes the intercept as well and we
are trying to fit a second-order polynomial. The second code takes out
the intercept and subtracts the mean values of each column of the
design matrix and the mean value of the outputs.
</p>

<p>The third and final code uses <b>Scikit-Learn</b> as library in order to
calculate the optimal parameters for OLS and Ridge regression. Note
that it is highly recommended to not include the intercept in Ridge
and Lasso regression, in order to avoid penalizing the optimization by
the intercept. The second and third codes do thus not include the
intercept. In the second code we do the scaling ourselves while the
last code uses the standard scaler option included in <b>Scikit-Learn</b>, known as centering (where
we subtract the mean values).
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> StandardScaler

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">MSE</span>(y_data,y_model):
    n = np.size(y_model)
    <span style="color: #8B008B; font-weight: bold">return</span> np.sum((y_data-y_model)**<span style="color: #B452CD">2</span>)/n

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">OLS_fit_beta</span>(X, y):
    <span style="color: #8B008B; font-weight: bold">return</span> np.linalg.pinv(X.T @ X) @ X.T @ y

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Ridge_fit_beta</span>(X, y,L,d):
    I = np.eye(d,d)
    <span style="color: #8B008B; font-weight: bold">return</span> np.linalg.pinv(X.T @ X + L*I) @ X.T @ y

<span style="color: #228B22"># Same random numbers for each test.</span>
np.random.seed(<span style="color: #B452CD">2018</span>)
n = <span style="color: #B452CD">100</span>
d = <span style="color: #B452CD">3</span>
<span style="color: #228B22"># hyperparameter lambda</span>
Lambda = <span style="color: #B452CD">0.01</span>

<span style="color: #228B22"># Make data set, simple second-order polynomial</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n)
y = <span style="color: #B452CD">2.0</span> + <span style="color: #B452CD">0.5</span>*x + <span style="color: #B452CD">5.0</span>*(x**<span style="color: #B452CD">2</span>)+ np.random.randn(n)

<span style="color: #228B22"># The design matrix X includes the intercept and no scaling is made</span>
X = np.zeros((<span style="color: #658b00">len</span>(x), d))
<span style="color: #8B008B; font-weight: bold">for</span> p <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d):     
    X[:, p] = x ** (p) 


<span style="color: #228B22">#Split data, no scaling is used and we include the intercept</span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span style="color: #B452CD">0.2</span>)


<span style="color: #228B22">#Calculate beta, own code</span>
beta_OLS = OLS_fit_beta(X_train, y_train)
beta_Ridge = Ridge_fit_beta(X_train, y_train,Lambda,d)
<span style="color: #658b00">print</span>(beta_OLS)
<span style="color: #658b00">print</span>(beta_Ridge)
<span style="color: #228B22">#predict value</span>
ytilde_test_OLS = X_test @ beta_OLS
ytilde_test_Ridge = X_test @ beta_Ridge

<span style="color: #228B22">#Calculate MSE</span>
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;  &quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;test MSE of OLS:&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ytilde_test_OLS))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;  &quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;test MSE of Ridge&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ytilde_test_Ridge))

plt.scatter(x,y,label=<span style="color: #CD5555">&#39;Data&#39;</span>)
plt.plot(x, X @ beta_OLS,<span style="color: #CD5555">&#39;*&#39;</span>, label=<span style="color: #CD5555">&quot;OLS_Fit&quot;</span>)
plt.plot(x, X @ beta_Ridge, label=<span style="color: #CD5555">&quot;Ridge_Fit&quot;</span>)
plt.grid()
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>In this example we do not include the intercept and we scale the data by subtracting the mean values. This follows the discussion in the <a href="https://compphysics.github.io/MachineLearning/doc/LectureNotes/_build/html/chapter3.html#more-on-rescaling-data" target="_blank">lecture material</a>.
see also the weekly slides <a href="https://compphysics.github.io/MachineLearning/doc/pub/week36/html/._week36-bs029.html" target="_blank">for week 36</a>.
It is recommended whrn we use Ridge and Lasso regression to not include the intercept in the optimization process.
</p>

<p>Before we discuss the code, we repeat some of the basic math from the slides of week 36.</p>

<p>Let us try to understand what this may imply mathematically when we
subtract the mean values, also known as <em>zero centering</em> or simply <em>centering</em>. For
simplicity, we will focus on  ordinary regression, as done in the above example.
</p>

<p>The cost/loss function  for regression is</p>
<p>&nbsp;<br>
$$
C(\beta_0, \beta_1, ... , \beta_{p-1}) = \frac{1}{n}\sum_{i=0}^{n} \left(y_i - \beta_0 - \sum_{j=1}^{p-1} X_{ij}\beta_j\right)^2,.
$$
<p>&nbsp;<br>

<p>Recall also that we use the squared value. This expression can lead to an
increased penalty for higher differences between predicted and
output/target values.
</p>

<p>What we have done is to single out the \( \beta_0 \) term in the
definition of the mean squared error (MSE).  The design matrix \( X \)
does in this case not contain any intercept column.  When we take the
derivative with respect to \( \beta_0 \), we want the derivative to obey
</p>

<p>&nbsp;<br>
$$
\frac{\partial C}{\partial \beta_j} = 0,
$$
<p>&nbsp;<br>

<p>for all \( j \). For \( \beta_0 \) we have</p>

<p>&nbsp;<br>
$$
\frac{\partial C}{\partial \beta_0} = -\frac{2}{n}\sum_{i=0}^{n-1} \left(y_i - \beta_0 - \sum_{j=1}^{p-1} X_{ij} \beta_j\right).
$$
<p>&nbsp;<br>

<p>Multiplying away the constant \( 2/n \), we obtain</p>
<p>&nbsp;<br>
$$
\sum_{i=0}^{n-1} \beta_0 = \sum_{i=0}^{n-1}y_i - \sum_{i=0}^{n-1} \sum_{j=1}^{p-1} X_{ij} \beta_j.
$$
<p>&nbsp;<br>

<p>Let us specialize first to the case where we have only two parameters \( \beta_0 \) and \( \beta_1 \).
Our result for \( \beta_0 \) simplifies then to
</p>
<p>&nbsp;<br>
$$
n\beta_0 = \sum_{i=0}^{n-1}y_i - \sum_{i=0}^{n-1} X_{i1} \beta_1.
$$
<p>&nbsp;<br>

<p>We obtain then</p>
<p>&nbsp;<br>
$$
\beta_0 = \frac{1}{n}\sum_{i=0}^{n-1}y_i - \beta_1\frac{1}{n}\sum_{i=0}^{n-1} X_{i1}.
$$
<p>&nbsp;<br>

<p>If we define</p>
<p>&nbsp;<br>
$$
\mu_{\boldsymbol{x}_1}=\frac{1}{n}\sum_{i=0}^{n-1} X_{i1},
$$
<p>&nbsp;<br>

<p>and the mean value of the outputs as</p>
<p>&nbsp;<br>
$$
\mu_y=\frac{1}{n}\sum_{i=0}^{n-1}y_i,
$$
<p>&nbsp;<br>

<p>we have</p>
<p>&nbsp;<br>
$$
\beta_0 = \mu_y - \beta_1\mu_{\boldsymbol{x}_1}.
$$
<p>&nbsp;<br>

<p>In the general case with more parameters than \( \beta_0 \) and \( \beta_1 \), we have</p>
<p>&nbsp;<br>
$$
\beta_0 = \frac{1}{n}\sum_{i=0}^{n-1}y_i - \frac{1}{n}\sum_{i=0}^{n-1}\sum_{j=1}^{p-1} X_{ij}\beta_j.
$$
<p>&nbsp;<br>

<p>We can rewrite the latter equation as</p>
<p>&nbsp;<br>
$$
\beta_0 = \frac{1}{n}\sum_{i=0}^{n-1}y_i - \sum_{j=1}^{p-1} \mu_{\boldsymbol{x}_j}\beta_j,
$$
<p>&nbsp;<br>

<p>where we have defined</p>
<p>&nbsp;<br>
$$
\mu_{\boldsymbol{x}_j}=\frac{1}{n}\sum_{i=0}^{n-1} X_{ij},
$$
<p>&nbsp;<br>

<p>the mean value for all elements of the column vector \( \boldsymbol{x}_j \).</p>

<p>Replacing \( y_i \) with \( y_i - y_i - \overline{\boldsymbol{y}} \) and centering also our design matrix results in a cost function (in vector-matrix disguise)</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{\beta}) = (\boldsymbol{\tilde{y}} - \tilde{X}\boldsymbol{\beta})^T(\boldsymbol{\tilde{y}} - \tilde{X}\boldsymbol{\beta}). 
$$
<p>&nbsp;<br>

<p>If we minimize with respect to \( \boldsymbol{\beta} \) we have then</p>

<p>&nbsp;<br>
$$
\hat{\boldsymbol{\beta}} = (\tilde{X}^T\tilde{X})^{-1}\tilde{X}^T\boldsymbol{\tilde{y}},
$$
<p>&nbsp;<br>

<p>where \( \boldsymbol{\tilde{y}} = \boldsymbol{y} - \overline{\boldsymbol{y}} \)
and \( \tilde{X}_{ij} = X_{ij} - \frac{1}{n}\sum_{k=0}^{n-1}X_{kj} \).
</p>

<p>For Ridge regression we need to add \( \lambda \boldsymbol{\beta}^T\boldsymbol{\beta} \) to the cost function and get then</p>
<p>&nbsp;<br>
$$
\hat{\boldsymbol{\beta}} = (\tilde{X}^T\tilde{X} + \lambda I)^{-1}\tilde{X}^T\boldsymbol{\tilde{y}}.
$$
<p>&nbsp;<br>

<p>Now we try to implement this.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">np.random.seed(<span style="color: #B452CD">2018</span>)
n = <span style="color: #B452CD">100</span>
<span style="color: #228B22"># we do not include the intercept</span>
d = <span style="color: #B452CD">2</span>
Lambda = <span style="color: #B452CD">0.01</span>

<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n)
y = <span style="color: #B452CD">2.0</span> + <span style="color: #B452CD">0.5</span>*x + <span style="color: #B452CD">5.0</span>*(x**<span style="color: #B452CD">2</span>)+ np.random.randn(n)

<span style="color: #228B22">#Design matrix X does not include the intercept. </span>
X = np.zeros((<span style="color: #658b00">len</span>(x), d))
<span style="color: #8B008B; font-weight: bold">for</span> p <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d):     
    X[:, p] = x ** (p+<span style="color: #B452CD">1</span>)


<span style="color: #228B22">#Split data in train and test</span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span style="color: #B452CD">0.2</span>)

<span style="color: #228B22"># Scale data by subtracting mean value,own implementation</span>
<span style="color: #228B22">#For our own implementation, we will need to deal with the intercept by centering the design matrix and the target variable</span>
X_train_mean = np.mean(X_train,axis=<span style="color: #B452CD">0</span>)
<span style="color: #228B22">#Center by removing mean from each feature</span>
X_train_scaled = X_train - X_train_mean
X_test_scaled = X_test - X_train_mean
<span style="color: #228B22">#The model intercept (called y_scaler) is given by the mean of the target variable (IF X is centered, note)</span>
y_scaler = np.mean(y_train)
y_train_scaled = y_train - y_scaler


<span style="color: #228B22">#Calculate beta</span>
beta_OLS = OLS_fit_beta(X_train_scaled, y_train_scaled)
beta_Ridge = Ridge_fit_beta(X_train_scaled, y_train_scaled,Lambda,d)
<span style="color: #658b00">print</span>(beta_OLS)
<span style="color: #658b00">print</span>(beta_Ridge)
<span style="color: #228B22"># calculate intercepts and print them</span>
interceptOLS = y_scaler - X_train_mean @ beta_OLS
interceptRidge = y_scaler - X_train_mean @ beta_Ridge
<span style="color: #658b00">print</span>(interceptOLS)
<span style="color: #658b00">print</span>(interceptRidge)

<span style="color: #228B22">#predict value with intercept</span>
ytilde_test_OLS = X_test_scaled @ beta_OLS+y_scaler
ytilde_test_Ridge = X_test_scaled @ beta_Ridge+y_scaler


<span style="color: #228B22">#Calculate MSE</span>

<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;  &quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;test MSE of OLS:&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ytilde_test_OLS))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;  &quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;test MSE of Ridge&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ytilde_test_Ridge))

plt.scatter(x,y,label=<span style="color: #CD5555">&#39;Data&#39;</span>)
plt.plot(x, X @ beta_OLS+interceptOLS,<span style="color: #CD5555">&#39;*&#39;</span>, label=<span style="color: #CD5555">&quot;OLS_Fit&quot;</span>)
plt.plot(x, X @ beta_Ridge+interceptRidge, label=<span style="color: #CD5555">&quot;Ridge_Fit&quot;</span>)
plt.grid()
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Finally, instead of using our own function we repeat the same example
using the <b>standardscaler</b> functionality of the library
<b>Scikit-Learn</b>.  Here we limit ourselves to Ridge regression only. 
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn</span> <span style="color: #8B008B; font-weight: bold">import</span> linear_model
np.random.seed(<span style="color: #B452CD">2018</span>)
n = <span style="color: #B452CD">10</span>
d = <span style="color: #B452CD">2</span>
Lambda = <span style="color: #B452CD">0.01</span>

<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n)
y = <span style="color: #B452CD">2.0</span> + <span style="color: #B452CD">0.5</span>*x + <span style="color: #B452CD">5.0</span>*(x**<span style="color: #B452CD">2</span>)+ np.random.randn(n)

<span style="color: #228B22"># Design matrix X does not include the intercept. </span>
X = np.zeros((n, d))
<span style="color: #8B008B; font-weight: bold">for</span> p <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d):     
    X[:, p] = x ** (p+<span style="color: #B452CD">1</span>)

<span style="color: #228B22">#Split data in train and test</span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span style="color: #B452CD">0.2</span>)
<span style="color: #228B22"># Scale data by subtracting mean value of the input using scikit-learn</span>
scaler = StandardScaler(with_std=<span style="color: #8B008B; font-weight: bold">False</span>)
scaler.fit(X_train)
X_train_mean = np.mean(X_train,axis=<span style="color: #B452CD">0</span>)
X_train_scaled = scaler.transform(X_train)
X_test_scaled = scaler.transform(X_test)
<span style="color: #228B22"># We scale also the output, here by our own code</span>
y_scaler = np.mean(y_train)
y_train_scaled = y_train - y_scaler
y_test_scaled = y_test- y_scaler

<span style="color: #228B22">#Calculate beta</span>
OLS = LinearRegression()
betaOLS=OLS.fit(X_train_scaled,y_train_scaled)
ypredictOLS = OLS.predict(X_test_scaled)
linear_model.Ridge(Lambda)
RegRidge.fit(X_train_scaled,y_train_scaled)
ypredictRidge = RegRidge.predict(X_test_scaled)
betaOLS = OLS.coef_
betaRidge = RegRidge.coef_
<span style="color: #658b00">print</span>(betaOLS)
<span style="color: #658b00">print</span>(betaRidge)
interceptOLS = np.mean(y_train) - X_train_mean @ betaOLS
interceptRidge = y_scaler - X_train_mean @ betaRidge
<span style="color: #658b00">print</span>(interceptOLS)
<span style="color: #658b00">print</span>(interceptRidge)
<span style="color: #228B22">#predict value </span>
ytilde_test_Ridge = X_test_scaled @ betaRidge+y_scaler
ytilde_test_OLS = X_test_scaled @ betaOLS+y_scaler

<span style="color: #228B22">#Calculate MSE</span>
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;  &quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;test MSE of OLS&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ytilde_test_OLS))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;  &quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;test MSE of Ridge&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ytilde_test_Ridge))
plt.scatter(x,y,label=<span style="color: #CD5555">&#39;Data&#39;</span>)
plt.plot(x, X @ RegRidge.coef_ + RegRidge.intercept_ , label=<span style="color: #CD5555">&quot;Ridge_Fit&quot;</span>)
plt.grid()
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>
