<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week35.do.txt --pygments_html_style=perldoc --html_style=solarized3 --html_links_in_new_window --html_output=week35-solarized --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Week 35: From Ordinary Linear Regression to Ridge and Lasso Regression">
<title>Week 35: From Ordinary Linear Regression to Ridge and Lasso Regression</title>
<link href="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link href="https://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Plans for week 35', 2, None, 'plans-for-week-35'),
              ('Reading recommendations:', 3, None, 'reading-recommendations'),
              ('For exercise sessions: Why Linear Regression (aka Ordinary '
               'Least Squares and family), repeat from last week',
               2,
               None,
               'for-exercise-sessions-why-linear-regression-aka-ordinary-least-squares-and-family-repeat-from-last-week'),
              ('The equations for ordinary least squares',
               2,
               None,
               'the-equations-for-ordinary-least-squares'),
              ('The cost/loss function', 2, None, 'the-cost-loss-function'),
              ('Interpretations and optimizing our parameters',
               2,
               None,
               'interpretations-and-optimizing-our-parameters'),
              ('Interpretations and optimizing our parameters',
               2,
               None,
               'interpretations-and-optimizing-our-parameters'),
              ('Some useful matrix and vector expressions',
               2,
               None,
               'some-useful-matrix-and-vector-expressions'),
              ('The Jacobian', 2, None, 'the-jacobian'),
              ('Derivatives, example 1', 2, None, 'derivatives-example-1'),
              ('Example 2', 2, None, 'example-2'),
              ('Example 3', 2, None, 'example-3'),
              ('Example 4', 2, None, 'example-4'),
              ('The mean squared error and its derivative',
               2,
               None,
               'the-mean-squared-error-and-its-derivative'),
              ('Other useful relations', 2, None, 'other-useful-relations'),
              ('Meet the Hessian Matrix', 2, None, 'meet-the-hessian-matrix'),
              ('Interpretations and optimizing our parameters',
               2,
               None,
               'interpretations-and-optimizing-our-parameters'),
              ('Example relevant for the exercises',
               2,
               None,
               'example-relevant-for-the-exercises'),
              ('Own code for Ordinary Least Squares',
               2,
               None,
               'own-code-for-ordinary-least-squares'),
              ('Adding error analysis and training set up',
               2,
               None,
               'adding-error-analysis-and-training-set-up'),
              ('Splitting our Data in Training and Test data',
               2,
               None,
               'splitting-our-data-in-training-and-test-data'),
              ('The complete code with a simple data set',
               2,
               None,
               'the-complete-code-with-a-simple-data-set'),
              ('Making your own test-train splitting',
               2,
               None,
               'making-your-own-test-train-splitting'),
              ('Reducing the number of degrees of freedom, overarching view',
               2,
               None,
               'reducing-the-number-of-degrees-of-freedom-overarching-view'),
              ('Preprocessing our data', 2, None, 'preprocessing-our-data'),
              ('Functionality in Scikit-Learn',
               2,
               None,
               'functionality-in-scikit-learn'),
              ('More preprocessing', 2, None, 'more-preprocessing'),
              ('Frequently used scaling functions',
               2,
               None,
               'frequently-used-scaling-functions'),
              ('Example of own Standard scaling',
               2,
               None,
               'example-of-own-standard-scaling'),
              ('Min-Max Scaling', 2, None, 'min-max-scaling'),
              ('Testing the Means Squared Error as function of Complexity',
               2,
               None,
               'testing-the-means-squared-error-as-function-of-complexity'),
              ('More preprocessing examples, two-dimensional example, the '
               'Franke function',
               2,
               None,
               'more-preprocessing-examples-two-dimensional-example-the-franke-function'),
              ('To think about, first part',
               2,
               None,
               'to-think-about-first-part'),
              ('More thinking', 2, None, 'more-thinking'),
              ('Still thinking', 2, None, 'still-thinking'),
              ('What does centering (subtracting the mean values) mean '
               'mathematically?',
               2,
               None,
               'what-does-centering-subtracting-the-mean-values-mean-mathematically'),
              ('Further Manipulations', 2, None, 'further-manipulations'),
              ('Wrapping it up', 2, None, 'wrapping-it-up'),
              ('Linear Regression code, Intercept handling first',
               2,
               None,
               'linear-regression-code-intercept-handling-first'),
              ('Material for lecture Monday, August 26',
               2,
               None,
               'material-for-lecture-monday-august-26'),
              ('Mathematical Interpretation of Ordinary Least Squares',
               2,
               None,
               'mathematical-interpretation-of-ordinary-least-squares'),
              ('Residual Error', 2, None, 'residual-error'),
              ('Simple case', 2, None, 'simple-case'),
              ('The singular value decomposition',
               2,
               None,
               'the-singular-value-decomposition'),
              ('Linear Regression Problems',
               2,
               None,
               'linear-regression-problems'),
              ('Fixing the singularity', 2, None, 'fixing-the-singularity'),
              ('Basic math of the SVD', 2, None, 'basic-math-of-the-svd'),
              ('The SVD, a Fantastic Algorithm',
               2,
               None,
               'the-svd-a-fantastic-algorithm'),
              ('Economy-size SVD', 2, None, 'economy-size-svd'),
              ('Codes for the SVD', 2, None, 'codes-for-the-svd'),
              ('Note about SVD Calculations',
               2,
               None,
               'note-about-svd-calculations'),
              ('Mathematics of the SVD and implications',
               2,
               None,
               'mathematics-of-the-svd-and-implications'),
              ('Example Matrix', 2, None, 'example-matrix'),
              ('Setting up the Matrix to be inverted',
               2,
               None,
               'setting-up-the-matrix-to-be-inverted'),
              ('Further properties (important for our analyses later)',
               2,
               None,
               'further-properties-important-for-our-analyses-later'),
              ('Meet the Covariance Matrix',
               2,
               None,
               'meet-the-covariance-matrix'),
              ('Introducing the Covariance and Correlation functions',
               2,
               None,
               'introducing-the-covariance-and-correlation-functions'),
              ('Covariance and Correlation Matrix',
               2,
               None,
               'covariance-and-correlation-matrix'),
              ('Correlation Function and Design/Feature Matrix',
               2,
               None,
               'correlation-function-and-design-feature-matrix'),
              ('Covariance Matrix Examples',
               2,
               None,
               'covariance-matrix-examples'),
              ('Correlation Matrix', 2, None, 'correlation-matrix'),
              ('Correlation Matrix with Pandas',
               2,
               None,
               'correlation-matrix-with-pandas'),
              ('Correlation Matrix with Pandas and the Franke function',
               2,
               None,
               'correlation-matrix-with-pandas-and-the-franke-function'),
              ('Rewriting the Covariance and/or Correlation Matrix',
               2,
               None,
               'rewriting-the-covariance-and-or-correlation-matrix'),
              ('Linking with the SVD', 2, None, 'linking-with-the-svd'),
              ('What does it mean?', 2, None, 'what-does-it-mean'),
              ('And finally  $\\boldsymbol{X}\\boldsymbol{X}^T$',
               2,
               None,
               'and-finally-boldsymbol-x-boldsymbol-x-t'),
              ('Ridge and LASSO Regression',
               2,
               None,
               'ridge-and-lasso-regression'),
              ('Deriving the  Ridge Regression Equations',
               2,
               None,
               'deriving-the-ridge-regression-equations'),
              ('Interpreting the Ridge results',
               2,
               None,
               'interpreting-the-ridge-results'),
              ('More interpretations', 2, None, 'more-interpretations'),
              ('Deriving the  Lasso Regression Equations',
               2,
               None,
               'deriving-the-lasso-regression-equations')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>Week 35: From Ordinary Linear Regression to Ridge and Lasso Regression</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics, University of Oslo</b>
</center>
<br>
<center>
<h4>August 26-30, 2024</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plans-for-week-35">Plans for week 35 </h2>

<p>The main topics are:</p>

<ol>
<li> Brief repetition from last week</li>
<li> Discussions  of the equations for ordinary least squares</li>
<li> Discussion on how to prepare data and examples of applications of linear regression</li>
<li> Material for the lecture on Monday: Mathematical interpretations of linear regression</li>
<li> Monday: Ridge and Lasso regression and Singular Value Decomposition</li>
</ol>
<h3 id="reading-recommendations">Reading recommendations: </h3>

<ol>
 <li> These lecture notes</li>
 <li> <a href="https://youtu.be/VKakN-e4aUA" target="_blank">Video of lecture</a></li>
 <li> Goodfellow, Bengio and Courville, Deep Learning, chapter 2 on linear algebra and sections 3.1-3.10 on elements of statistics (background)</li>
 <li> Raschka et al on preprocessing of data, relevant for exercise 3 this week, see chapter 4.</li>
 <li> For exercise 1 of week 35, the book by A. Aldo Faisal, Cheng Soon Ong, and Marc Peter Deisenroth on the Mathematics of Machine Learning, may be very relevant. In particular chapter 5 at URL"https://mml-book.github.io/" (section 5.5 on derivatives) is very useful for exercise 1 this coming week.</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="for-exercise-sessions-why-linear-regression-aka-ordinary-least-squares-and-family-repeat-from-last-week">For exercise sessions: Why Linear Regression (aka Ordinary Least Squares and family), repeat from last week </h2>

<p>We need first a reminder from last week about linear regression. </p>

<p>Fitting a continuous function with linear parameterization in terms of the parameters  \( \boldsymbol{\beta} \).</p>
<ul>
<li> Method of choice for fitting a continuous function!</li>
<li> Gives an excellent introduction to central Machine Learning features with <b>understandable pedagogical</b> links to other methods like <b>Neural Networks</b>, <b>Support Vector Machines</b> etc</li>
<li> Analytical expression for the fitting parameters \( \boldsymbol{\beta} \)</li>
<li> Analytical expressions for statistical propertiers like mean values, variances, confidence intervals and more</li>
<li> Analytical relation with probabilistic interpretations</li> 
<li> Easy to introduce basic concepts like bias-variance tradeoff, cross-validation, resampling and regularization techniques and many other ML topics</li>
<li> Easy to code! And links well with classification problems and logistic regression and neural networks</li>
<li> Allows for <b>easy</b> hands-on understanding of gradient descent methods</li>
<li> and many more features</li>
</ul>
<p>For more discussions of Ridge and Lasso regression, <a href="https://arxiv.org/abs/1509.09169" target="_blank">Wessel van Wieringen's</a> article is highly recommended.
Similarly, <a href="https://arxiv.org/abs/1803.08823" target="_blank">Mehta et al's article</a> is also recommended.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-equations-for-ordinary-least-squares">The equations for ordinary least squares  </h2>

<p>Our data which we want to apply a machine learning method on, consist
of a set of inputs \( \boldsymbol{x}^T=[x_0,x_1,x_2,\dots,x_{n-1}] \) and the
outputs we want to model \( \boldsymbol{y}^T=[y_0,y_1,y_2,\dots,y_{n-1}] \).
We assume  that the output data can be represented (for a regression case) by a continuous function \( f \)
through
</p>
$$
y_i=f(x_i)+\epsilon_i,
$$

<p>or in general</p>
$$
\boldsymbol{y}=f(\boldsymbol{x})+\boldsymbol{\epsilon},
$$

<p>where \( \boldsymbol{\epsilon} \) represents some noise which is normally assumed to
be distributed via a normal probability distribution with zero mean
value and a variance \( \sigma^2 \).
</p>

<p>In linear regression we approximate the unknown function with another
continuous function \( \tilde{\boldsymbol{y}}(\boldsymbol{x}) \) which depends linearly on
some unknown parameters
\( \boldsymbol{\beta}^T=[\beta_0,\beta_1,\beta_2,\dots,\beta_{p-1}] \).
</p>

<p>Last week we introduced the so-called design matrix in order to define
the approximation \( \boldsymbol{\tilde{y}} \) via the unknown quantity
\( \boldsymbol{\beta} \) as
</p>

$$
\boldsymbol{\tilde{y}}= \boldsymbol{X}\boldsymbol{\beta},
$$

<p>and in order to find the optimal parameters \( \beta_i \) we defined a function which
gives a measure of the spread between the values \( y_i \) (which
represent the output values we want to reproduce) and the parametrized
values \( \tilde{y}_i \), namely the so-called cost/loss function.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-cost-loss-function">The cost/loss function </h2>

<p>We used the mean squared error to define the way we measure the quality of our model</p>
$$
C(\boldsymbol{\beta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)^T\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)\right\},
$$

<p>or using the matrix \( \boldsymbol{X} \) and in a more compact matrix-vector notation as</p>
$$
C(\boldsymbol{\beta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)\right\}.
$$

<p>This function represents one of many possible ways to define the so-called cost function.</p>

<p>It is also common to define
the function \( C \) as
</p>

$$
C(\boldsymbol{\beta})=\frac{1}{2n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2,
$$

<p>since when taking the first derivative with respect to the unknown parameters \( \beta \), the factor of \( 2 \) cancels out. </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="interpretations-and-optimizing-our-parameters">Interpretations and optimizing our parameters  </h2>

<p>The function </p>
$$
C(\boldsymbol{\beta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)\right\},
$$

<p>can be linked to the variance of the quantity \( y_i \) if we interpret the latter as the mean value. 
When linking (see the discussions next week) with the maximum likelihood approach below, we will indeed interpret \( y_i \) as a mean value
</p>
$$
y_{i}=\langle y_i \rangle = \beta_0x_{i,0}+\beta_1x_{i,1}+\beta_2x_{i,2}+\dots+\beta_{n-1}x_{i,n-1}+\epsilon_i,
$$

<p>where \( \langle y_i \rangle \) is the mean value. Keep in mind also that
till now we have treated \( y_i \) as the exact value. Normally, the
response (dependent or outcome) variable \( y_i \) is the outcome of a
numerical experiment or another type of experiment and could thus be treated itself as an
approximation to the true value. It is then always accompanied by an
error estimate, often limited to a statistical error estimate given by
the standard deviation discussed earlier. In the discussion here we
will treat \( y_i \) as our exact value for the response variable.
</p>

<p>In order to find the parameters \( \beta_i \) we will then minimize the spread of \( C(\boldsymbol{\beta}) \), that is we are going to solve the problem</p>
$$
{\displaystyle \min_{\boldsymbol{\beta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)\right\}.
$$

<p>In practical terms it means we will require</p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \beta_j} = \frac{\partial }{\partial \beta_j}\left[ \frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\beta_0x_{i,0}-\beta_1x_{i,1}-\beta_2x_{i,2}-\dots-\beta_{n-1}x_{i,n-1}\right)^2\right]=0, 
$$

<p>which results in</p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \beta_j} = -\frac{2}{n}\left[ \sum_{i=0}^{n-1}x_{ij}\left(y_i-\beta_0x_{i,0}-\beta_1x_{i,1}-\beta_2x_{i,2}-\dots-\beta_{n-1}x_{i,n-1}\right)\right]=0, 
$$

<p>or in a matrix-vector form as (multiplying away the factor \( -2/n \), see derivation below)</p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}^T} = 0 = \boldsymbol{X}^T\left( \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right).  
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="interpretations-and-optimizing-our-parameters">Interpretations and optimizing our parameters  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>We can rewrite, see the derivations below, </p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}^T} = 0 = \boldsymbol{X}^T\left( \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right),  
$$

<p>as</p>
$$
\boldsymbol{X}^T\boldsymbol{y} = \boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\beta},  
$$

<p>and if the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) is invertible we have the solution</p>
$$
\boldsymbol{\beta} =\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>We note also that since our design matrix is defined as \( \boldsymbol{X}\in
{\mathbb{R}}^{n\times p} \), the product \( \boldsymbol{X}^T\boldsymbol{X} \in
{\mathbb{R}}^{p\times p} \).  In most cases we have that \( p \ll n \). In our example case below we have \( p=5 \) meaning. We end up with inverting a small
\( 5\times 5 \) matrix. This is a rather common situation, in many cases we end up with low-dimensional
matrices to invert. The methods discussed here and for many other
supervised learning algorithms like classification with logistic
regression or support vector machines, exhibit dimensionalities which
allow for the usage of direct linear algebra methods such as <b>LU</b> decomposition or <b>Singular Value Decomposition</b> (SVD) for finding the inverse of the matrix
\( \boldsymbol{X}^T\boldsymbol{X} \).  This is discussed on Thursday this week.
</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p><b>Small question</b>: Do you think the example we have at hand here (the nuclear binding energies) can lead to problems in inverting the matrix  \( \boldsymbol{X}^T\boldsymbol{X} \)? What kind of problems can we expect? </p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="some-useful-matrix-and-vector-expressions">Some useful matrix and vector expressions </h2>

<p>The following matrix and vector relation will be useful here and for
the rest of the course. Vectors are always written as boldfaced lower
case letters and matrices as upper case boldfaced letters.  In the
following we will discuss how to calculate derivatives of various
matrices relevant for machine learning. We will often represent our
data in terms of matrices and vectors.
</p>

<p>Let us introduce first some conventions. We assume that \( \boldsymbol{y} \) is a
vector of length \( m \), that is it has \( m \) elements \( y_0,y_1,\dots,
y_{m-1} \). By convention we start labeling vectors with the zeroth
element, as are arrays in Python and C++/C, for example. Similarly, we
have a vector \( \boldsymbol{x} \) of length \( n \), that is
\( \boldsymbol{x}^T=[x_0,x_1,\dots, x_{n-1}] \).
</p>

<p>We assume also that \( \boldsymbol{y} \) is a function of \( \boldsymbol{x} \) through some
given function \( f \)
</p>

$$
\boldsymbol{y}=f(\boldsymbol{x}).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-jacobian">The Jacobian </h2>

<p>We define the partial derivatives of the various components of \( \boldsymbol{y} \) as functions of \( x_i \) in terms of the so-called <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant" target="_blank">Jacobian matrix</a></p>

$$
\boldsymbol{J}=\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}=\begin{bmatrix} \frac{\partial y_0}{\partial x_0} & \frac{\partial y_0}{\partial x_1} & \frac{\partial y_0}{\partial x_2} & \dots & \dots & \frac{\partial y_0}{\partial x_{n-1}} \\ \frac{\partial y_1}{\partial x_0} & \frac{\partial y_1}{\partial x_1} & \frac{\partial y_1}{\partial x_2} & \dots & \dots & \frac{\partial y_1}{\partial x_{n-1}} \\
\frac{\partial y_2}{\partial x_0} & \frac{\partial y_2}{\partial x_1} & \frac{\partial y_2}{\partial x_2} & \dots & \dots & \frac{\partial y_2}{\partial x_{n-1}} \\
\dots & \dots & \dots & \dots & \dots & \dots \\
\dots & \dots & \dots & \dots & \dots & \dots \\
\frac{\partial y_{m-1}}{\partial x_0} & \frac{\partial y_{m-1}}{\partial x_1} & \frac{\partial y_{m-1}}{\partial x_2} & \dots & \dots & \frac{\partial y_{m-1}}{\partial x_{n-1}} \end{bmatrix},
$$

<p>which is an \( m\times n \) matrix. If \( \boldsymbol{x} \) is a scalar, then the
Jacobian is only a single-column vector, or an \( m\times 1 \) matrix. If
on the other hand \( \boldsymbol{y} \) is a scalar, the Jacobian becomes a
\( 1\times n \) matrix.
</p>

<p>When this matrix is a square matrix \( m=n \), its determinant is often referred to as the Jacobian
determinant. Both the matrix and (if \( m=n \)) the determinant are
often referred to simply as the Jacobian. The Jacobian matrix represents the differential of \( \boldsymbol{y} \) at every point where the
vector is differentiable. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="derivatives-example-1">Derivatives, example 1 </h2>

<p>Let now \( \boldsymbol{y}=\boldsymbol{A}\boldsymbol{x} \), where \( \boldsymbol{A} \) is an \( m\times n \) matrix and the matrix does not depend on \( \boldsymbol{x} \). If we write out the vector \( \boldsymbol{y} \) compoment by component we have</p>

$$
y_i = \sum_{j=0}^{n-1}a_{ij}x_j,
$$

<p>with \( \forall i=0,1,2,\dots,m-1 \). The individual matrix elements of \( \boldsymbol{A} \) are given by the symbol \( a_{ij} \).
It follows that the partial derivatives of \( y_i \) with respect to \( x_k \) 
</p>
$$
\frac{\partial y_i }{\partial x_k}= a_{ik} \forall i=0,1,2,\dots,m-1.
$$

<p>From this we have, using the definition of the Jacobian</p>

$$
\frac{\partial \boldsymbol{y} }{\partial \boldsymbol{x}}= \boldsymbol{A}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-2">Example 2 </h2>

<p>We define a scalar (our cost/loss functions are in general also scalars,
just think of the mean squared error) as the result of some matrix vector
multiplications
</p>

$$
\alpha = \boldsymbol{y}^T\boldsymbol{A}\boldsymbol{x},
$$

<p>with \( \boldsymbol{y} \) a vector of length \( m \), \( \boldsymbol{A} \) an \( m\times n \) matrix and \( \boldsymbol{x} \) a vector of length \( n \). We assume also that \( \boldsymbol{A} \) does not depend on any of the two vectors.
In order to find the derivative of \( \alpha \) with respect to the two vectors, we define an intermediate vector \( \boldsymbol{z} \). We define first
\( \boldsymbol{z}^T=\boldsymbol{y}^T\boldsymbol{A} \), a vector of length \( n \). We have then, using the definition of the Jacobian,
</p>
$$
\alpha = \boldsymbol{z}^T\boldsymbol{x},
$$

<p>which means that (using our previous example and keeping track of our definition of the derivative of a scalar) we have</p>
$$
\frac{\partial \alpha}{\partial \boldsymbol{x}} = \frac{\partial \boldsymbol{z}^T\boldsymbol{x}}{\partial \boldsymbol{x}}=\boldsymbol{z}^T.
$$

<p>Note that the resulting vector elements are the same for \( \boldsymbol{z}^T \) and \( \boldsymbol{z} \), the only difference is that one is just the transpose of the other. We have the transposed here since we have used that the inner product of two vectors is a scalar.</p>

<p>Since \( \alpha \) is a scalar we have \( \alpha =\alpha^T=\boldsymbol{x}^T\boldsymbol{A}^T\boldsymbol{y} \). Defining now \( \boldsymbol{z}^T=\boldsymbol{x}^T\boldsymbol{A}^T \) we find that</p>
$$
\frac{\partial \alpha}{\partial \boldsymbol{y}} = \boldsymbol{z}^T=\boldsymbol{x}^T\boldsymbol{A}^T.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-3">Example 3 </h2>

<p>We start with a new scalar but where now the vector \( \boldsymbol{y} \) is
replaced by a vector \( \boldsymbol{x} \) and the matrix \( \boldsymbol{A} \) is a square
matrix with dimension \( n\times n \).
</p>

$$
\alpha = \boldsymbol{x}^T\boldsymbol{A}\boldsymbol{x},
$$

<p>with \( \boldsymbol{x} \) a vector of length \( n \).</p>

<p>We write out the specific sums involved in the calculation of \( \alpha \)</p>
$$
\alpha = \sum_{i=0}^{n-1}\sum_{j=0}^{n-1}x_i a_{ij}x_j, 
$$

<p>taking the derivative of \( \alpha \) with respect to a given component \( x_k \) we get the two sums</p>
$$
\frac{\partial \alpha}{\partial x_k}  = \sum_{i=0}^{n-1}a_{ik}x_i+\sum_{j=0}^{n-1}a_{kj}x_j, 
$$

<p>for \( \forall k =0,1,2,\dots,n-1 \). We identify these sums as</p>
$$
\frac{\partial \alpha}{\partial \boldsymbol{x}}  = \boldsymbol{x}^T\left(\boldsymbol{A}^T+\boldsymbol{A}\right).
$$

<p>If the matrix \( \boldsymbol{A} \) is symmetric, that is \( \boldsymbol{A}=\boldsymbol{A}^T \), we have </p>
$$
\frac{\partial \alpha}{\partial \boldsymbol{x}}  = 2\boldsymbol{x}^T\boldsymbol{A}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-4">Example 4 </h2>

<p>We let the scalar \( \alpha \) be defined by</p>
$$
\alpha = \boldsymbol{y}^T\boldsymbol{x},
$$

<p>where both \( \boldsymbol{y} \) and \( \boldsymbol{x} \) have the same length \( n \), or if we
wish to think of them as column vectors, they have dimensions \( n\times
1 \). We assume that both \( \boldsymbol{y} \) and \( \boldsymbol{x} \) depend on a vector
\( \boldsymbol{z} \) of the same length. To calculate the derivative of \( \alpha \)
with respect to a given component \( z_k \) we need first to write out the
inner product that defines \( \alpha \) as
</p>
$$
\alpha  = \sum_{i=0}^{n-1}y_ix_i,
$$

<p>and the partial derivative</p>

$$
\frac{\partial \alpha}{\partial z_k}  = \sum_{i=0}^{n-1}\left(x_i\frac{\partial y_i}{\partial z_k}+y_i\frac{\partial x_i}{\partial z_k}\right),
$$

<p>for \( \forall k =0,1,2,\dots,n-1 \). We can rewrite the partial derivative in a more compact form as</p>
$$
\frac{\partial \alpha}{\partial \boldsymbol{z}}  = \boldsymbol{x}^T\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{z}}+\boldsymbol{y}^T\frac{\partial \boldsymbol{x}}{\partial \boldsymbol{z}},
$$

<p>and if \( \boldsymbol{y}=\boldsymbol{x} \) we have</p>
$$
\frac{\partial \alpha}{\partial \boldsymbol{z}}  = 2\boldsymbol{x}^T\frac{\partial \boldsymbol{x}}{\partial \boldsymbol{z}}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-mean-squared-error-and-its-derivative">The mean squared error and its derivative </h2>

<p>We defined earlier a possible cost function using the mean squared error</p>
$$
C(\boldsymbol{\beta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)^T\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)\right\},
$$

<p>or using the design/feature matrix \( \boldsymbol{X} \) we have the more compact matrix-vector</p>
$$
C(\boldsymbol{\beta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)\right\}.
$$

<p>We note that the design matrix \( \boldsymbol{X} \) does not depend on the unknown parameters defined by the vector \( \boldsymbol{\beta} \).
We are now interested in minimizing the cost function with respect to the unknown parameters \( \boldsymbol{\beta} \).
</p>

<p>The mean squared error is a scalar and if we use the results from example three above, we can define a new vector</p>
$$
\boldsymbol{w}=\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta},
$$

<p>which depends on \( \boldsymbol{\beta} \). We rewrite the cost function as</p>
$$
C(\boldsymbol{\beta})=\frac{1}{n}\boldsymbol{w}^T\boldsymbol{w},
$$

<p>with partial derivative</p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}}=\frac{2}{n}\boldsymbol{w}^T\frac{\partial \boldsymbol{w}}{\partial \boldsymbol{\beta}},
$$

<p>and using that</p>
$$
\frac{\partial \boldsymbol{w}}{\partial \boldsymbol{\beta}}=-\boldsymbol{X},
$$

<p>where we used the result from example two above. Inserting the last expression we obtain</p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}}=-\frac{2}{n}\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)^T\boldsymbol{X},
$$

<p>or as</p>
$$
\frac{\partial C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}^T}=-\frac{2}{n}\boldsymbol{X}^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="other-useful-relations">Other useful relations </h2>

<p>We list here some other useful relations we may encounter (recall that vectors are defined by boldfaced low-key letters)</p>
$$
\frac{\partial (\boldsymbol{x}^T\boldsymbol{a})}{\partial \boldsymbol{x}} = \boldsymbol{a}^T,
$$

$$
\frac{\partial (\boldsymbol{a}^T\boldsymbol{x})}{\partial \boldsymbol{x}} = \boldsymbol{a}^T,
$$


$$
\frac{\partial tr(\boldsymbol{B}\boldsymbol{A})}{\partial \boldsymbol{A}} = \boldsymbol{B}^T,
$$

$$
\frac{\partial \log{\vert\boldsymbol{A}\vert}}{\partial \boldsymbol{A}} = (\boldsymbol{A}^{-1})^T.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="meet-the-hessian-matrix">Meet the Hessian Matrix </h2>

<p>A very important matrix we will meet again and again in machine
learning is the Hessian.  It is given by the second derivative of the
cost function with respect to the parameters \( \boldsymbol{\beta} \). Using the above
expression for derivatives of vectors and matrices, we find that the
second derivative of the mean squared error as cost function is,
</p>

$$
\frac{\partial}{\partial \boldsymbol{\beta}}\frac{\partial C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}^T} =\frac{\partial}{\partial \boldsymbol{\beta}}\left[-\frac{2}{n}\boldsymbol{X}^T\left( \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)\right]=\frac{2}{n}\boldsymbol{X}^T\boldsymbol{X}.  
$$

<p>The Hessian matrix plays an important role and is defined here as</p>

$$
\boldsymbol{H}=\boldsymbol{X}^T\boldsymbol{X}.
$$

<p>For ordinary least squares, it is inversely proportional (derivation
next week) with the variance of the optimal parameters
\( \hat{\boldsymbol{\beta}} \). Furthermore, we will see later this week that it is
(aside the factor \( 1/n \)) equal to the covariance matrix. It plays also a very
important role in optmization algorithms and Principal Component
Analysis as a way to reduce the dimensionality of a machine learning/data analysis
problem.
</p>

<p><b>Linear algebra question:</b>  Can we use the Hessian matrix to say something about properties of the cost function (our optmization  problem)? (hint: think about convex or concave problems and how to relate these to a matrix!). </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="interpretations-and-optimizing-our-parameters">Interpretations and optimizing our parameters  </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The residuals \( \boldsymbol{\epsilon} \) are in turn given by</p>
$$
\boldsymbol{\epsilon} = \boldsymbol{y}-\boldsymbol{\tilde{y}} = \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta},
$$

<p>and with </p>
$$
\boldsymbol{X}^T\left( \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)= 0, 
$$

<p>we have</p>
$$
\boldsymbol{X}^T\boldsymbol{\epsilon}=\boldsymbol{X}^T\left( \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)= 0, 
$$

<p>meaning that the solution for \( \boldsymbol{\beta} \) is the one which minimizes the residuals.  </p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-relevant-for-the-exercises">Example relevant for the exercises  </h2>

<p>In order to understand the relation among the predictors \( p \), the set of data \( n \) and the target (outcome, output etc) \( \boldsymbol{y} \),
we condiser a simple polynomial fit.
We assume our data can represented by a fourth-order polynomial. For the $i$th component we have 
</p>
$$
\tilde{y}_i = \beta_0+\beta_1x_i+\beta_2x_i^2+\beta_3x_i^3+\beta_4x_i^4.
$$

<p>we have five predictors/features. The first is the intercept \( \beta_0 \). The other terms are \( \beta_i \) with \( i=1,2,3,4 \). Furthermore we have \( n \) entries for each predictor. It means that our design matrix is an 
\( n\times p \) matrix \( \boldsymbol{X} \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="own-code-for-ordinary-least-squares">Own code for Ordinary Least Squares </h2>

<p>It is rather straightforward to implement the matrix inversion and obtain the parameters \( \boldsymbol{\beta} \). After having defined the matrix \( \boldsymbol{X} \) and the outputs \( \boldsymbol{y} \) we have </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># matrix inversion to find beta</span>
<span style="color: #228B22"># First we set up the data</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
x = np.random.rand(<span style="color: #B452CD">100</span>)
y = <span style="color: #B452CD">2.0</span>+<span style="color: #B452CD">5</span>*x*x+<span style="color: #B452CD">0.1</span>*np.random.randn(<span style="color: #B452CD">100</span>)
<span style="color: #228B22"># and then the design matrix X including the intercept</span>
<span style="color: #228B22">#  The design matrix now as function of a fourth-order polynomial</span>
X = np.zeros((<span style="color: #658b00">len</span>(x),<span style="color: #B452CD">5</span>))
X[:,<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1.0</span>
X[:,<span style="color: #B452CD">1</span>] = x
X[:,<span style="color: #B452CD">2</span>] = x**<span style="color: #B452CD">2</span>
X[:,<span style="color: #B452CD">3</span>] = x**<span style="color: #B452CD">3</span>
X[:,<span style="color: #B452CD">4</span>] = x**<span style="color: #B452CD">4</span>
beta = (np.linalg.inv(X.T @ X) @ X.T ) @ y
<span style="color: #228B22"># and then make the prediction</span>
ytilde = X @ beta
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Alternatively, you can use the least squares functionality in <b>Numpy</b> as</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">fit = np.linalg.lstsq(X, y, rcond =<span style="color: #8B008B; font-weight: bold">None</span>)[<span style="color: #B452CD">0</span>]
ytildenp = np.dot(fit,X.T)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="adding-error-analysis-and-training-set-up">Adding error analysis and training set up </h2>

<p>We can easily test our fit by computing the \( R2 \) score that we discussed in connection with the functionality of <b>Scikit-Learn</b> in the introductory slides.
Since we are not using <b>Scikit-Learn</b> here we can define our own \( R2 \) function as
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">R2</span>(y_data, y_model):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span> - np.sum((y_data - y_model) ** <span style="color: #B452CD">2</span>) / np.sum((y_data - np.mean(y_data)) ** <span style="color: #B452CD">2</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>and we would be using it as </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #658b00">print</span>(R2(y,ytilde))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We can easily add our <b>MSE</b> score as</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">MSE</span>(y_data,y_model):
    n = np.size(y_model)
    <span style="color: #8B008B; font-weight: bold">return</span> np.sum((y_data-y_model)**<span style="color: #B452CD">2</span>)/n

<span style="color: #658b00">print</span>(MSE(y,ytilde))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>and finally the relative error as</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">RelativeError</span>(y_data,y_model):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">abs</span>((y_data-y_model)/y_data)
<span style="color: #658b00">print</span>(RelativeError(y, ytilde))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="splitting-our-data-in-training-and-test-data">Splitting our Data in Training and Test data </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>It is normal in essentially all Machine Learning studies to split the
data in a training set and a test set (sometimes also an additional
validation set).  <b>Scikit-Learn</b> has an own function for this. There
is no explicit recipe for how much data should be included as training
data and say test data.  An accepted rule of thumb is to use
approximately \( 2/3 \) to \( 4/5 \) of the data as training data. We will
postpone a discussion of this splitting to the end of these notes and
our discussion of the so-called <b>bias-variance</b> tradeoff. Here we
limit ourselves to repeat the above equation of state fitting example
but now splitting the data into a training set and a test set.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-complete-code-with-a-simple-data-set">The complete code with a simple data set </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">R2</span>(y_data, y_model):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span> - np.sum((y_data - y_model) ** <span style="color: #B452CD">2</span>) / np.sum((y_data - np.mean(y_data)) ** <span style="color: #B452CD">2</span>)
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">MSE</span>(y_data,y_model):
    n = np.size(y_model)
    <span style="color: #8B008B; font-weight: bold">return</span> np.sum((y_data-y_model)**<span style="color: #B452CD">2</span>)/n

x = np.random.rand(<span style="color: #B452CD">100</span>)
y = <span style="color: #B452CD">2.0</span>+<span style="color: #B452CD">5</span>*x*x+<span style="color: #B452CD">0.1</span>*np.random.randn(<span style="color: #B452CD">100</span>)


<span style="color: #228B22">#  The design matrix now as function of a fourth-order polynomial</span>
X = np.zeros((<span style="color: #658b00">len</span>(x),<span style="color: #B452CD">5</span>))
X[:,<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1.0</span>
X[:,<span style="color: #B452CD">1</span>] = x
X[:,<span style="color: #B452CD">2</span>] = x**<span style="color: #B452CD">2</span>
X[:,<span style="color: #B452CD">3</span>] = x**<span style="color: #B452CD">3</span>
X[:,<span style="color: #B452CD">4</span>] = x**<span style="color: #B452CD">4</span>
<span style="color: #228B22"># We split the data in test and training data</span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span style="color: #B452CD">0.2</span>)
<span style="color: #228B22"># matrix inversion to find beta</span>
beta = np.linalg.inv(X_train.T @ X_train) @ X_train.T @ y_train
<span style="color: #658b00">print</span>(beta)
<span style="color: #228B22"># and then make the prediction</span>
ytilde = X_train @ beta
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Training R2&quot;</span>)
<span style="color: #658b00">print</span>(R2(y_train,ytilde))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Training MSE&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_train,ytilde))
ypredict = X_test @ beta
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Test R2&quot;</span>)
<span style="color: #658b00">print</span>(R2(y_test,ypredict))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Test MSE&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y_test,ypredict))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="making-your-own-test-train-splitting">Making your own test-train splitting </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># equivalently in numpy</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">train_test_split_numpy</span>(inputs, labels, train_size, test_size):
    n_inputs = <span style="color: #658b00">len</span>(inputs)
    inputs_shuffled = inputs.copy()
    labels_shuffled = labels.copy()

    np.random.shuffle(inputs_shuffled)
    np.random.shuffle(labels_shuffled)

    train_end = <span style="color: #658b00">int</span>(n_inputs*train_size)
    X_train, X_test = inputs_shuffled[:train_end], inputs_shuffled[train_end:]
    Y_train, Y_test = labels_shuffled[:train_end], labels_shuffled[train_end:]

    <span style="color: #8B008B; font-weight: bold">return</span> X_train, X_test, Y_train, Y_test
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>But since <b>scikit-learn</b> has its own function for doing this and since
it interfaces easily with <b>tensorflow</b> and other libraries, we
normally recommend using the latter functionality.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="reducing-the-number-of-degrees-of-freedom-overarching-view">Reducing the number of degrees of freedom, overarching view  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>Many Machine Learning problems involve thousands or even millions of
features for each training instance. Not only does this make training
extremely slow, it can also make it much harder to find a good
solution, as we will see. This problem is often referred to as the
curse of dimensionality.  Fortunately, in real-world problems, it is
often possible to reduce the number of features considerably, turning
an intractable problem into a tractable one.
</p>

<p>Later  we will discuss some of the most popular dimensionality reduction
techniques: the principal component analysis (PCA), Kernel PCA, and
Locally Linear Embedding (LLE).  
</p>

<p>Principal component analysis and its various variants deal with the
problem of fitting a low-dimensional <a href="https://en.wikipedia.org/wiki/Affine_space" target="_blank">affine
subspace</a> to a set of of
data points in a high-dimensional space. With its family of methods it
is one of the most used tools in data modeling, compression and
visualization.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="preprocessing-our-data">Preprocessing our data  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>Before we proceed however, we will discuss how to preprocess our
data. Till now and in connection with our previous examples we have
not met so many cases where we are too sensitive to the scaling of our
data. Normally the data may need a rescaling and/or may be sensitive
to extreme values. Scaling the data renders our inputs much more
suitable for the algorithms we want to employ.
</p>

<p>For data sets gathered for real world applications, it is rather normal that
different features have very different units and
numerical scales. For example, a data set detailing health habits may include
features such as <b>age</b> in the range \( 0-80 \), and <b>caloric intake</b> of order \( 2000 \).
Many machine learning methods sensitive to the scales of the features and may perform poorly if they
are very different scales. Therefore, it is typical to scale
the features in a way to avoid such outlier values.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="functionality-in-scikit-learn">Functionality in Scikit-Learn </h2>

<p><b>Scikit-Learn</b> has several functions which allow us to rescale the
data, normally resulting in much better results in terms of various
accuracy scores.  The <b>StandardScaler</b> function in <b>Scikit-Learn</b>
ensures that for each feature/predictor we study the mean value is
zero and the variance is one (every column in the design/feature
matrix).  This scaling has the drawback that it does not ensure that
we have a particular maximum or minimum in our data set. Another
function included in <b>Scikit-Learn</b> is the <b>MinMaxScaler</b> which
ensures that all features are exactly between \( 0 \) and \( 1 \). The
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-preprocessing">More preprocessing </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The <b>Normalizer</b> scales each data
point such that the feature vector has a euclidean length of one. In other words, it
projects a data point on the circle (or sphere in the case of higher dimensions) with a
radius of 1. This means every data point is scaled by a different number (by the
inverse of it&#8217;s length).
This normalization is often used when only the direction (or angle) of the data matters,
not the length of the feature vector.
</p>

<p>The <b>RobustScaler</b> works similarly to the StandardScaler in that it
ensures statistical properties for each feature that guarantee that
they are on the same scale. However, the RobustScaler uses the median
and quartiles, instead of mean and variance. This makes the
RobustScaler ignore data points that are very different from the rest
(like measurement errors). These odd data points are also called
outliers, and might often lead to trouble for other scaling
techniques.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="frequently-used-scaling-functions">Frequently used scaling functions </h2>

<p>Many features are often scaled using standardization to improve performance. In <b>Scikit-Learn</b> this is given by the <b>StandardScaler</b> function as discussed above. It is easy however to write your own. 
Mathematically, this involves subtracting the mean and divide by the standard deviation over the data set, for each feature:
</p>

$$
    x_j^{(i)} \rightarrow \frac{x_j^{(i)} - \overline{x}_j}{\sigma(x_j)},
$$

<p>where \( \overline{x}_j \) and \( \sigma(x_j) \) are the mean and standard deviation, respectively,  of the feature \( x_j \).
This ensures that each feature has zero mean and unit standard deviation.  For data sets where  we do not have the standard deviation or don't wish to calculate it,  it is then common to simply set it to one.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-of-own-standard-scaling">Example of own Standard scaling </h2>

<p>Let us consider the following vanilla example where we use both
<b>Scikit-Learn</b> and write our own function as well.  We produce a
simple test design matrix with random numbers. Each column could then
represent a specific feature whose mean value is subracted.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">skl</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span>  train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> MinMaxScaler, StandardScaler, Normalizer
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">IPython.display</span> <span style="color: #8B008B; font-weight: bold">import</span> display
np.random.seed(<span style="color: #B452CD">100</span>)
<span style="color: #228B22"># setting up a 10 x 5 matrix</span>
rows = <span style="color: #B452CD">10</span>
cols = <span style="color: #B452CD">5</span>
X = np.random.randn(rows,cols)
XPandas = pd.DataFrame(X)
display(XPandas)
<span style="color: #658b00">print</span>(XPandas.mean())
<span style="color: #658b00">print</span>(XPandas.std())
XPandas = (XPandas -XPandas.mean())
display(XPandas)
<span style="color: #228B22">#  This option does not include the standard deviation</span>
scaler = StandardScaler(with_std=<span style="color: #8B008B; font-weight: bold">False</span>)
scaler.fit(X)
Xscaled = scaler.transform(X)
display(XPandas-Xscaled)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Small exercise: perform the standard scaling by including the standard deviation and compare with what Scikit-Learn gives.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="min-max-scaling">Min-Max Scaling </h2>

<p>Another commonly used scaling method is min-max scaling. This is very
useful for when we want the features to lie in a certain interval. To
scale the feature \( x_j \) to the interval \( [a, b] \), we can apply the
transformation
</p>

$$
x_j^{(i)} \rightarrow (b-a)\frac{x_j^{(i)} - \min(x_j)}{\max(x_j) - \min(x_j)} - a
$$

<p>where \( \min(x_j) \) and \( \max(x_j) \) return the minimum and maximum value of \( x_j \) over the data set, respectively.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="testing-the-means-squared-error-as-function-of-complexity">Testing the Means Squared Error as function of Complexity </h2>

<p>One of 
the aims is to reproduce Figure 2.11 of <a href="https://github.com/CompPhysics/MLErasmus/blob/master/doc/Textbooks/elementsstat.pdf" target="_blank">Hastie et al</a>.
</p>

<p>Our data is defined by \( x\in [-3,3] \) with a total of for example \( 100 \) data points.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">np.random.seed()
n = <span style="color: #B452CD">100</span>
maxdegree = <span style="color: #B452CD">14</span>
<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n).reshape(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
y = np.exp(-x**<span style="color: #B452CD">2</span>) + <span style="color: #B452CD">1.5</span> * np.exp(-(x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>)+ np.random.normal(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.1</span>, x.shape)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>where \( y \) is the function we want to fit with a given polynomial.</p>

<p>Write a first code which sets up a design matrix \( X \) defined by a fourth-order polynomial.  Scale your data and split it in training and test data. </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> PolynomialFeatures
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span> train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.pipeline</span> <span style="color: #8B008B; font-weight: bold">import</span> make_pipeline


np.random.seed(<span style="color: #B452CD">2018</span>)
n = <span style="color: #B452CD">50</span>
maxdegree = <span style="color: #B452CD">5</span>
<span style="color: #228B22"># Make data set.</span>
x = np.linspace(-<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, n).reshape(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
y = np.exp(-x**<span style="color: #B452CD">2</span>) + <span style="color: #B452CD">1.5</span> * np.exp(-(x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>)+ np.random.normal(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.1</span>, x.shape)
TestError = np.zeros(maxdegree)
TrainError = np.zeros(maxdegree)
polydegree = np.zeros(maxdegree)
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span style="color: #B452CD">0.2</span>)
scaler = StandardScaler()
scaler.fit(x_train)
x_train_scaled = scaler.transform(x_train)
x_test_scaled = scaler.transform(x_test)

<span style="color: #8B008B; font-weight: bold">for</span> degree <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(maxdegree):
    model = make_pipeline(PolynomialFeatures(degree=degree), LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>))
    clf = model.fit(x_train_scaled,y_train)
    y_fit = clf.predict(x_train_scaled)
    y_pred = clf.predict(x_test_scaled) 
    polydegree[degree] = degree
    TestError[degree] = np.mean( np.mean((y_test - y_pred)**<span style="color: #B452CD">2</span>) )
    TrainError[degree] = np.mean( np.mean((y_train - y_fit)**<span style="color: #B452CD">2</span>) )

plt.plot(polydegree, TestError, label=<span style="color: #CD5555">&#39;Test Error&#39;</span>)
plt.plot(polydegree, TrainError, label=<span style="color: #CD5555">&#39;Train Error&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-preprocessing-examples-two-dimensional-example-the-franke-function">More preprocessing examples, two-dimensional example, the Franke function </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">skl</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.metrics</span> <span style="color: #8B008B; font-weight: bold">import</span> mean_squared_error
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.model_selection</span> <span style="color: #8B008B; font-weight: bold">import</span>  train_test_split
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.preprocessing</span> <span style="color: #8B008B; font-weight: bold">import</span> MinMaxScaler, StandardScaler, Normalizer

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">FrankeFunction</span>(x,y):
	term1 = <span style="color: #B452CD">0.75</span>*np.exp(-(<span style="color: #B452CD">0.25</span>*(<span style="color: #B452CD">9</span>*x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>) - <span style="color: #B452CD">0.25</span>*((<span style="color: #B452CD">9</span>*y-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>))
	term2 = <span style="color: #B452CD">0.75</span>*np.exp(-((<span style="color: #B452CD">9</span>*x+<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">49.0</span> - <span style="color: #B452CD">0.1</span>*(<span style="color: #B452CD">9</span>*y+<span style="color: #B452CD">1</span>))
	term3 = <span style="color: #B452CD">0.5</span>*np.exp(-(<span style="color: #B452CD">9</span>*x-<span style="color: #B452CD">7</span>)**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">4.0</span> - <span style="color: #B452CD">0.25</span>*((<span style="color: #B452CD">9</span>*y-<span style="color: #B452CD">3</span>)**<span style="color: #B452CD">2</span>))
	term4 = -<span style="color: #B452CD">0.2</span>*np.exp(-(<span style="color: #B452CD">9</span>*x-<span style="color: #B452CD">4</span>)**<span style="color: #B452CD">2</span> - (<span style="color: #B452CD">9</span>*y-<span style="color: #B452CD">7</span>)**<span style="color: #B452CD">2</span>)
	<span style="color: #8B008B; font-weight: bold">return</span> term1 + term2 + term3 + term4


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">create_X</span>(x, y, n ):
	<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(x.shape) &gt; <span style="color: #B452CD">1</span>:
		x = np.ravel(x)
		y = np.ravel(y)

	N = <span style="color: #658b00">len</span>(x)
	l = <span style="color: #658b00">int</span>((n+<span style="color: #B452CD">1</span>)*(n+<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">2</span>)		<span style="color: #228B22"># Number of elements in beta</span>
	X = np.ones((N,l))

	<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,n+<span style="color: #B452CD">1</span>):
		q = <span style="color: #658b00">int</span>((i)*(i+<span style="color: #B452CD">1</span>)/<span style="color: #B452CD">2</span>)
		<span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i+<span style="color: #B452CD">1</span>):
			X[:,q+k] = (x**(i-k))*(y**k)

	<span style="color: #8B008B; font-weight: bold">return</span> X


<span style="color: #228B22"># Making meshgrid of datapoints and compute Franke&#39;s function</span>
n = <span style="color: #B452CD">5</span>
N = <span style="color: #B452CD">1000</span>
x = np.sort(np.random.uniform(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, N))
y = np.sort(np.random.uniform(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, N))
z = FrankeFunction(x, y)
X = create_X(x, y, n=n)    
<span style="color: #228B22"># split in training and test data</span>
X_train, X_test, y_train, y_test = train_test_split(X,z,test_size=<span style="color: #B452CD">0.2</span>)


clf = skl.LinearRegression().fit(X_train, y_train)

<span style="color: #228B22"># The mean squared error and R2 score</span>
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;MSE before scaling: {:.2f}&quot;</span>.format(mean_squared_error(clf.predict(X_test), y_test)))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;R2 score before scaling {:.2f}&quot;</span>.format(clf.score(X_test,y_test)))

scaler = StandardScaler()
scaler.fit(X_train)
X_train_scaled = scaler.transform(X_train)
X_test_scaled = scaler.transform(X_test)

<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Feature min values before scaling:\n {}&quot;</span>.format(X_train.min(axis=<span style="color: #B452CD">0</span>)))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Feature max values before scaling:\n {}&quot;</span>.format(X_train.max(axis=<span style="color: #B452CD">0</span>)))

<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Feature min values after scaling:\n {}&quot;</span>.format(X_train_scaled.min(axis=<span style="color: #B452CD">0</span>)))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Feature max values after scaling:\n {}&quot;</span>.format(X_train_scaled.max(axis=<span style="color: #B452CD">0</span>)))

clf = skl.LinearRegression().fit(X_train_scaled, y_train)


<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;MSE after  scaling: {:.2f}&quot;</span>.format(mean_squared_error(clf.predict(X_test_scaled), y_test)))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;R2 score for  scaled data: {:.2f}&quot;</span>.format(clf.score(X_test_scaled,y_test)))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="to-think-about-first-part">To think about, first part </h2>

<p>When you are comparing your own code with for example <b>Scikit-Learn</b>'s
library, there are some technicalities to keep in mind.  The examples
here demonstrate some of these aspects with potential pitfalls.
</p>

<p>The discussion here focuses on the role of the intercept, how we can
set up the design matrix, what scaling we should use and other topics
which tend  confuse us.
</p>

<p>The intercept can be interpreted as the expected value of our
target/output variables when all other predictors are set to zero.
Thus, if we cannot assume that the expected outputs/targets are zero
when all predictors are zero (the columns in the design matrix), it
may be a bad idea to implement a model which penalizes the intercept.
Furthermore, in for example Ridge and Lasso regression (to be discussed in moe detail next week), the default solutions
from the library <b>Scikit-Learn</b> (when not shrinking \( \beta_0 \)) for the unknown parameters
\( \boldsymbol{\beta} \), are derived&#160;under the assumption that both \( \boldsymbol{y} \) and
\( \boldsymbol{X} \) are zero centered, that is we subtract the mean values.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-thinking">More thinking </h2>

<p>If our predictors&#160;represent different&#160;scales, then it is important to
standardize the design matrix \( \boldsymbol{X} \) by subtracting the mean of each
column from the corresponding column and dividing the column with its
standard deviation. Most machine learning libraries do this as a default. This means that if you compare your code with the results from a given library,
the results may differ. 
</p>

<p>The
<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" target="_blank">Standadscaler</a>
function in <b>Scikit-Learn</b> does this for us.  For the data sets we
have been studying in our various examples, the data are in many cases
already scaled and there is no need to scale them. You as a user of different machine learning algorithms, should always perform  a
survey of your data, with a critical assessment of them in case you need to scale the data.
</p>

<p>If you need to scale the data, not doing so will give an <em>unfair</em>
penalization of the parameters since their magnitude&#160;depends on the
scale of their corresponding&#160;predictor.
</p>

<p>Suppose as an example that you 
you have an input&#160;variable given by the heights of different persons.
Human height might be measured in inches or meters or
kilometers. If measured in kilometers, a&#160;standard linear regression
model with this predictor would probably give a much bigger
coefficient term, than if measured in millimeters.
This can clearly lead to problems in evaluating the cost/loss functions.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="still-thinking">Still thinking </h2>

<p>Keep in mind that when you transform your data set before training a model, the same transformation needs to be done
on your eventual new data set  before making a prediction. If we translate this into a Python code, it would could be implemented as follows
(note that the lines are commented since the model function has not been defined)
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22">#Model training, we compute the mean value of y and X</span>
y_train_mean = np.mean(y_train)
X_train_mean = np.mean(X_train,axis=<span style="color: #B452CD">0</span>)
X_train = X_train - X_train_mean
y_train = y_train - y_train_mean

<span style="color: #228B22"># The we fit our model with the training data</span>
<span style="color: #228B22">#trained_model = some_model.fit(X_train,y_train)</span>


<span style="color: #228B22">#Model prediction, we need also to transform our data set used for the prediction.</span>
X_test = X_test - X_train_mean <span style="color: #228B22">#Use mean from training data</span>
<span style="color: #228B22">#y_pred = trained_model(X_test)</span>
y_pred = y_pred + y_train_mean
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="what-does-centering-subtracting-the-mean-values-mean-mathematically">What does centering (subtracting the mean values) mean mathematically? </h2>

<p>Let us try to understand what this may imply mathematically when we
subtract the mean values, also known as <em>zero centering</em>. For
simplicity, we will focus on  ordinary regression, as done in the above example.
</p>

<p>The cost/loss function  for regression is</p>
$$
C(\beta_0, \beta_1, ... , \beta_{p-1}) = \frac{1}{n}\sum_{i=0}^{n} \left(y_i - \beta_0 - \sum_{j=1}^{p-1} X_{ij}\beta_j\right)^2,.
$$

<p>Recall also that we use the squared value since this leads to an increase of the penalty for higher differences between predicted and output/target values.</p>

<p>What we have done is to single out the \( \beta_0 \) term in the definition of the mean squared error (MSE).
The design matrix
\( X \) does in this case not contain any intercept column.
When we take the derivative with respect to \( \beta_0 \), we want the derivative to obey
</p>
$$
\frac{\partial C}{\partial \beta_j} = 0,
$$

<p>for all \( j \). For \( \beta_0 \) we have</p>

$$
\frac{\partial C}{\partial \beta_0} = -\frac{2}{n}\sum_{i=0}^{n-1} \left(y_i - \beta_0 - \sum_{j=1}^{p-1} X_{ij} \beta_j\right).
$$

<p>Multiplying away the constant \( 2/n \), we obtain</p>
$$
\sum_{i=0}^{n-1} \beta_0 = \sum_{i=0}^{n-1}y_i - \sum_{i=0}^{n-1} \sum_{j=1}^{p-1} X_{ij} \beta_j.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="further-manipulations">Further Manipulations </h2>

<p>Let us special first to the case where we have only two parameters \( \beta_0 \) and \( \beta_1 \).
Our result for \( \beta_0 \) simplifies then to
</p>
$$
n\beta_0 = \sum_{i=0}^{n-1}y_i - \sum_{i=0}^{n-1} X_{i1} \beta_1.
$$

<p>We obtain then</p>
$$
\beta_0 = \frac{1}{n}\sum_{i=0}^{n-1}y_i - \beta_1\frac{1}{n}\sum_{i=0}^{n-1} X_{i1}.
$$

<p>If we define</p>
$$
\mu_1=\frac{1}{n}\sum_{i=0}^{n-1} (X_{i1},
$$

<p>and if we define the mean value of the outputs as</p>
$$
\mu_y=\frac{1}{n}\sum_{i=0}^{n-1}y_i,
$$

<p>we have</p>
$$
\beta_0 = \mu_y - \beta_1\mu_{1}.
$$

<p>In the general case, that is we have more parameters than \( \beta_0 \) and \( \beta_1 \), we have</p>
$$
\beta_0 = \frac{1}{n}\sum_{i=0}^{n-1}y_i - \frac{1}{n}\sum_{i=0}^{n-1}\sum_{j=1}^{p-1} X_{ij}\beta_j.
$$

<p>Replacing \( y_i \) with \( y_i - y_i - \overline{\boldsymbol{y}} \) and centering also our design matrix results in a cost function (in vector-matrix disguise)</p>
$$
C(\boldsymbol{\beta}) = (\boldsymbol{\tilde{y}} - \tilde{X}\boldsymbol{\beta})^T(\boldsymbol{\tilde{y}} - \tilde{X}\boldsymbol{\beta}). 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="wrapping-it-up">Wrapping it up </h2>

<p>If we minimize with respect to \( \boldsymbol{\beta} \) we have then</p>

$$
\hat{\boldsymbol{\beta}} = (\tilde{X}^T\tilde{X})^{-1}\tilde{X}^T\boldsymbol{\tilde{y}},
$$

<p>where \( \boldsymbol{\tilde{y}} = \boldsymbol{y} - \overline{\boldsymbol{y}} \)
and \( \tilde{X}_{ij} = X_{ij} - \frac{1}{n}\sum_{k=0}^{n-1}X_{kj} \).
</p>

<p>For Ridge regression we need to add \( \lambda \boldsymbol{\beta}^T\boldsymbol{\beta} \) to the cost function and get then</p>
$$
\hat{\boldsymbol{\beta}} = (\tilde{X}^T\tilde{X} + \lambda I)^{-1}\tilde{X}^T\boldsymbol{\tilde{y}}.
$$

<p>What does this mean? And why do we insist on all this? Let us look at some examples.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="linear-regression-code-intercept-handling-first">Linear Regression code, Intercept handling first </h2>

<p>This code shows a simple first-order fit to a data set using the above transformed data, where we consider the role of the intercept first, by either excluding it or including it (<em>code example thanks to  &#216;yvind Sigmundson Sch&#248;yen</em>). Here our scaling of the data is done by subtracting the mean values only.
Note also that we do not split the data into training and test.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.linear_model</span> <span style="color: #8B008B; font-weight: bold">import</span> LinearRegression


np.random.seed(<span style="color: #B452CD">2021</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">MSE</span>(y_data,y_model):
    n = np.size(y_model)
    <span style="color: #8B008B; font-weight: bold">return</span> np.sum((y_data-y_model)**<span style="color: #B452CD">2</span>)/n


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">fit_beta</span>(X, y):
    <span style="color: #8B008B; font-weight: bold">return</span> np.linalg.pinv(X.T @ X) @ X.T @ y


true_beta = [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">3.7</span>]

x = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">11</span>)
y = np.sum(
    np.asarray([x ** p * b <span style="color: #8B008B; font-weight: bold">for</span> p, b <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(true_beta)]), axis=<span style="color: #B452CD">0</span>
) + <span style="color: #B452CD">0.1</span> * np.random.normal(size=<span style="color: #658b00">len</span>(x))

degree = <span style="color: #B452CD">3</span>
X = np.zeros((<span style="color: #658b00">len</span>(x), degree))

<span style="color: #228B22"># Include the intercept in the design matrix</span>
<span style="color: #8B008B; font-weight: bold">for</span> p <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(degree):
    X[:, p] = x ** p

beta = fit_beta(X, y)

<span style="color: #228B22"># Intercept is included in the design matrix</span>
skl = LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">False</span>).fit(X, y)

<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;True beta: {</span>true_beta<span style="color: #CD5555">}&quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Fitted beta: {</span>beta<span style="color: #CD5555">}&quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Sklearn fitted beta: {</span>skl.coef_<span style="color: #CD5555">}&quot;</span>)
ypredictOwn = X @ beta
ypredictSKL = skl.predict(X)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;MSE with intercept column&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y,ypredictOwn))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;MSE with intercept column from SKL&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y,ypredictSKL))


plt.figure()
plt.scatter(x, y, label=<span style="color: #CD5555">&quot;Data&quot;</span>)
plt.plot(x, X @ beta, label=<span style="color: #CD5555">&quot;Fit&quot;</span>)
plt.plot(x, skl.predict(X), label=<span style="color: #CD5555">&quot;Sklearn (fit_intercept=False)&quot;</span>)


<span style="color: #228B22"># Do not include the intercept in the design matrix</span>
X = np.zeros((<span style="color: #658b00">len</span>(x), degree - <span style="color: #B452CD">1</span>))

<span style="color: #8B008B; font-weight: bold">for</span> p <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(degree - <span style="color: #B452CD">1</span>):
    X[:, p] = x ** (p + <span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Intercept is not included in the design matrix</span>
skl = LinearRegression(fit_intercept=<span style="color: #8B008B; font-weight: bold">True</span>).fit(X, y)

<span style="color: #228B22"># Use centered values for X and y when computing coefficients</span>
y_offset = np.average(y, axis=<span style="color: #B452CD">0</span>)
X_offset = np.average(X, axis=<span style="color: #B452CD">0</span>)

beta = fit_beta(X - X_offset, y - y_offset)
intercept = np.mean(y_offset - X_offset @ beta)

<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Manual intercept: {</span>intercept<span style="color: #CD5555">}&quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Fitted beta (wiothout intercept): {</span>beta<span style="color: #CD5555">}&quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Sklearn intercept: {</span>skl.intercept_<span style="color: #CD5555">}&quot;</span>)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;Sklearn fitted beta (without intercept): {</span>skl.coef_<span style="color: #CD5555">}&quot;</span>)
ypredictOwn = X @ beta
ypredictSKL = skl.predict(X)
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;MSE with Manual intercept&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y,ypredictOwn+intercept))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">f&quot;MSE with Sklearn intercept&quot;</span>)
<span style="color: #658b00">print</span>(MSE(y,ypredictSKL))

plt.plot(x, X @ beta + intercept, <span style="color: #CD5555">&quot;--&quot;</span>, label=<span style="color: #CD5555">&quot;Fit (manual intercept)&quot;</span>)
plt.plot(x, skl.predict(X), <span style="color: #CD5555">&quot;--&quot;</span>, label=<span style="color: #CD5555">&quot;Sklearn (fit_intercept=True)&quot;</span>)
plt.grid()
plt.legend()

plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The intercept is the value of our output/target variable
when all our features are zero and our function crosses the \( y \)-axis (for a one-dimensional case). 
</p>

<p>Printing the MSE, we see first that both methods give the same MSE, as
they should.  However, when we move to for example Ridge regression (discussed next week),
the way we treat the intercept may give a larger or smaller MSE,
meaning that the MSE can be penalized by the value of the
intercept. Not including the intercept in the fit, means that the
regularization term does not include \( \beta_0 \). For different values
of \( \lambda \), this may lead to differing MSE values. 
</p>

<p>To remind the reader, the regularization term, with the intercept in Ridge regression is given by</p>
$$
\lambda \vert\vert \boldsymbol{\beta} \vert\vert_2^2 = \lambda \sum_{j=0}^{p-1}\beta_j^2,
$$

<p>but when we take out the intercept, this equation becomes</p>
$$
\lambda \vert\vert \boldsymbol{\beta} \vert\vert_2^2 = \lambda \sum_{j=1}^{p-1}\beta_j^2.
$$

<p>For Lasso regression we have</p>
$$
\lambda \vert\vert \boldsymbol{\beta} \vert\vert_1 = \lambda \sum_{j=1}^{p-1}\vert\beta_j\vert.
$$

<p>It means that, when scaling the design matrix and the outputs/targets,
by subtracting the mean values, we have an optimization problem which
is not penalized by the intercept. The MSE value can then be smaller
since it focuses only on the remaining quantities. If we however bring
back the intercept, we will get an MSE which then contains the
intercept. This becomes more important when we discuss Ridge and Lasso
regression next week.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="material-for-lecture-monday-august-26">Material for lecture Monday, August 26 </h2>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="mathematical-interpretation-of-ordinary-least-squares">Mathematical Interpretation of Ordinary Least Squares </h2>

<p>What is presented here is a mathematical analysis of various regression algorithms (ordinary least  squares, Ridge and Lasso Regression). The analysis is based on an important algorithm in linear algebra, the so-called Singular Value Decomposition (SVD). </p>

<p>We have shown that in ordinary least squares the optimal parameters \( \beta \) are given by</p>

$$
\hat{\boldsymbol{\beta}} = \left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>The <b>hat</b> over \( \boldsymbol{\beta} \) means we have the optimal parameters after minimization of the cost function.</p>

<p>This means that our best model is defined as</p>

$$
\tilde{\boldsymbol{y}}=\boldsymbol{X}\hat{\boldsymbol{\beta}} = \boldsymbol{X}\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>We now define a matrix</p>
$$
\boldsymbol{A}=\boldsymbol{X}\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T.
$$

<p>We can rewrite</p>
$$
\tilde{\boldsymbol{y}}=\boldsymbol{X}\hat{\boldsymbol{\beta}} = \boldsymbol{A}\boldsymbol{y}.
$$

<p>The matrix \( \boldsymbol{A} \) has the important property that \( \boldsymbol{A}^2=\boldsymbol{A} \). This is the definition of a projection matrix.
We can then interpret our optimal model \( \tilde{\boldsymbol{y}} \) as being represented  by an orthogonal  projection of \( \boldsymbol{y} \) onto a space defined by the column vectors of \( \boldsymbol{X} \).  In our case here the matrix \( \boldsymbol{A} \) is a square matrix. If it is a general rectangular matrix we have an oblique projection matrix.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="residual-error">Residual Error </h2>

<p>We have defined the residual error as</p>
$$
\boldsymbol{\epsilon}=\boldsymbol{y}-\tilde{\boldsymbol{y}}=\left[\boldsymbol{I}-\boldsymbol{X}\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\right]\boldsymbol{y}.
$$

<p>The residual errors are then the projections of \( \boldsymbol{y} \) onto the orthogonal component of the space defined by the column vectors of \( \boldsymbol{X} \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="simple-case">Simple case </h2>

<p>If the matrix \( \boldsymbol{X} \) is an orthogonal (or unitary in case of complex values) matrix, we have</p>

$$
\boldsymbol{X}^T\boldsymbol{X}=\boldsymbol{X}\boldsymbol{X}^T = \boldsymbol{I}.
$$

<p>In this case the matrix \( \boldsymbol{A} \) becomes</p>
$$
\boldsymbol{A}=\boldsymbol{X}\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T)=\boldsymbol{I},
$$

<p>and we have the obvious case</p>
$$
\boldsymbol{\epsilon}=\boldsymbol{y}-\tilde{\boldsymbol{y}}=0.
$$

<p>This serves also as a useful test of our codes. </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-singular-value-decomposition">The singular value decomposition  </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>The examples we have looked at so far are cases where we normally can
invert the matrix \( \boldsymbol{X}^T\boldsymbol{X} \). Using a polynomial expansion where we fit of various functions leads to
row vectors of the design matrix which are essentially orthogonal due
to the polynomial character of our model. Obtaining the inverse of the
design matrix is then often done via a so-called LU, QR or Cholesky
decomposition.
</p>

<p>As we will also see in the first project, 
this may
however not the be case in general and a standard matrix inversion
algorithm based on say LU, QR or Cholesky decomposition may lead to singularities. We will see examples of this below.
</p>

<p>There is however a way to circumvent this problem and also
gain some insights about the ordinary least squares approach, and
later shrinkage methods like Ridge and Lasso regressions.
</p>

<p>This is given by the <b>Singular Value Decomposition</b> (SVD) algorithm,
perhaps the most powerful linear algebra algorithm.  The SVD provides
a numerically stable matrix decomposition that is used in a large
swath oc applications and the decomposition is always stable
numerically.
</p>

<p>In machine learning it plays a central role in dealing with for
example design matrices that may be near singular or singular.
Furthermore, as we will see here, the singular values can be related
to the covariance matrix (and thereby the correlation matrix) and in
turn the variance of a given quantity. It plays also an important role
in the principal component analysis where high-dimensional data can be
reduced to the statistically relevant features.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="linear-regression-problems">Linear Regression Problems </h2>

<p>One of the typical problems we encounter with linear regression, in particular 
when the matrix \( \boldsymbol{X} \) (our so-called design matrix) is high-dimensional, 
are problems with near singular or singular matrices. The column vectors of \( \boldsymbol{X} \) 
may be linearly dependent, normally referred to as super-collinearity.  
This means that the matrix may be rank deficient and it is basically impossible to 
to model the data using linear regression. As an example, consider the matrix
</p>
$$
\begin{align*}
\mathbf{X} & =  \left[
\begin{array}{rrr}
1 & -1 & 2
\\
1 & 0 & 1
\\
1 & 2  & -1
\\
1 & 1  & 0
\end{array} \right]
\end{align*}
$$

<p>The columns of \( \boldsymbol{X} \) are linearly dependent. We see this easily since the 
the first column is the row-wise sum of the other two columns. The rank (more correct,
the column rank) of a matrix is the dimension of the space spanned by the
column vectors. Hence, the rank of \( \mathbf{X} \) is equal to the number
of linearly independent columns. In this particular case the matrix has rank 2.
</p>

<p>Super-collinearity of an \( (n \times p) \)-dimensional design matrix \( \mathbf{X} \) implies
that the inverse of the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) (the matrix we need to invert to solve the linear regression equations) is non-invertible. If we have a square matrix that does not have an inverse, we say this matrix singular. The example here demonstrates this
</p>
$$
\begin{align*}
\boldsymbol{X} & =  \left[
\begin{array}{rr}
1 & -1
\\
1 & -1
\end{array} \right].
\end{align*}
$$

<p>We see easily that  \( \mbox{det}(\boldsymbol{X}) = x_{11} x_{22} - x_{12} x_{21} = 1 \times (-1) - 1 \times (-1) = 0 \). Hence, \( \mathbf{X} \) is singular and its inverse is undefined.
This is equivalent to saying that the matrix \( \boldsymbol{X} \) has at least an eigenvalue which is zero.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="fixing-the-singularity">Fixing the singularity </h2>

<p>If our design matrix \( \boldsymbol{X} \) which enters the linear regression problem</p>
$$
\begin{align}
\boldsymbol{\beta} & =  (\boldsymbol{X}^{T} \boldsymbol{X})^{-1} \boldsymbol{X}^{T} \boldsymbol{y},
\label{_auto1}
\end{align}
$$

<p>has linearly dependent column vectors, we will not be able to compute the inverse
of \( \boldsymbol{X}^T\boldsymbol{X} \) and we cannot find the parameters (estimators) \( \beta_i \). 
The estimators are only well-defined if \( (\boldsymbol{X}^{T}\boldsymbol{X})^{-1} \) exits. 
This is more likely to happen when the matrix \( \boldsymbol{X} \) is high-dimensional. In this case it is likely to encounter a situation where 
the regression parameters \( \beta_i \) cannot be estimated.
</p>

<p>A cheap  <em>ad hoc</em> approach is  simply to add a small diagonal component to the matrix to invert, that is we change</p>
$$
\boldsymbol{X}^{T} \boldsymbol{X} \rightarrow \boldsymbol{X}^{T} \boldsymbol{X}+\lambda \boldsymbol{I},
$$

<p>where \( \boldsymbol{I} \) is the identity matrix.  When we discuss <b>Ridge</b> regression this is actually what we end up evaluating. The parameter \( \lambda \) is called a hyperparameter. More about this later. </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="basic-math-of-the-svd">Basic math of the SVD </h2>

<p>From standard linear algebra we know that a square matrix \( \boldsymbol{X} \) can be diagonalized if and only it is 
a so-called <a href="https://en.wikipedia.org/wiki/Normal_matrix" target="_blank">normal matrix</a>, that is if \( \boldsymbol{X}\in {\mathbb{R}}^{n\times n} \)
we have \( \boldsymbol{X}\boldsymbol{X}^T=\boldsymbol{X}^T\boldsymbol{X} \) or if \( \boldsymbol{X}\in {\mathbb{C}}^{n\times n} \) we have \( \boldsymbol{X}\boldsymbol{X}^{\dagger}=\boldsymbol{X}^{\dagger}\boldsymbol{X} \).
The matrix has then a set of eigenpairs 
</p>

$$
(\lambda_1,\boldsymbol{u}_1),\dots, (\lambda_n,\boldsymbol{u}_n),
$$

<p>and the eigenvalues are given by the diagonal matrix</p>
$$
\boldsymbol{\Sigma}=\mathrm{Diag}(\lambda_1, \dots,\lambda_n).
$$

<p>The matrix \( \boldsymbol{X} \) can be written in terms of an orthogonal/unitary transformation \( \boldsymbol{U} \)</p>
$$
\boldsymbol{X} = \boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T,
$$

<p>with \( \boldsymbol{U}\boldsymbol{U}^T=\boldsymbol{I} \) or \( \boldsymbol{U}\boldsymbol{U}^{\dagger}=\boldsymbol{I} \).</p>

<p>Not all square matrices are diagonalizable. A matrix like the one discussed above</p>
$$
\boldsymbol{X} = \begin{bmatrix} 
1&  -1 \\
1& -1\\
\end{bmatrix} 
$$

<p>is not diagonalizable, it is a so-called <a href="https://en.wikipedia.org/wiki/Defective_matrix" target="_blank">defective matrix</a>. It is easy to see that the condition
\( \boldsymbol{X}\boldsymbol{X}^T=\boldsymbol{X}^T\boldsymbol{X} \) is not fulfilled. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-svd-a-fantastic-algorithm">The SVD, a Fantastic Algorithm </h2>

<p>However, and this is the strength of the SVD algorithm, any general
matrix \( \boldsymbol{X} \) can be decomposed in terms of a diagonal matrix and
two orthogonal/unitary matrices.  The <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank">Singular Value Decompostion
(SVD) theorem</a>
states that a general \( m\times n \) matrix \( \boldsymbol{X} \) can be written in
terms of a diagonal matrix \( \boldsymbol{\Sigma} \) of dimensionality \( m\times n \)
and two orthognal matrices \( \boldsymbol{U} \) and \( \boldsymbol{V} \), where the first has
dimensionality \( m \times m \) and the last dimensionality \( n\times n \).
We have then
</p>

$$ 
\boldsymbol{X} = \boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T 
$$

<p>As an example, the above defective matrix can be decomposed as</p>

$$
\boldsymbol{X} = \frac{1}{\sqrt{2}}\begin{bmatrix}  1&  1 \\ 1& -1\\ \end{bmatrix} \begin{bmatrix}  2&  0 \\ 0& 0\\ \end{bmatrix}    \frac{1}{\sqrt{2}}\begin{bmatrix}  1&  -1 \\ 1& 1\\ \end{bmatrix}=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T, 
$$

<p>with eigenvalues \( \sigma_1=2 \) and \( \sigma_2=0 \). 
The SVD exits always! 
</p>

<p>The SVD
decomposition (singular values) gives eigenvalues 
\( \sigma_i\geq\sigma_{i+1} \) for all \( i \) and for dimensions larger than \( i=p \), the
eigenvalues (singular values) are zero.
</p>

<p>In the general case, where our design matrix \( \boldsymbol{X} \) has dimension
\( n\times p \), the matrix is thus decomposed into an \( n\times n \)
orthogonal matrix \( \boldsymbol{U} \), a \( p\times p \) orthogonal matrix \( \boldsymbol{V} \)
and a diagonal matrix \( \boldsymbol{\Sigma} \) with \( r=\mathrm{min}(n,p) \)
singular values \( \sigma_i\geq 0 \) on the main diagonal and zeros filling
the rest of the matrix.  There are at most \( p \) singular values
assuming that \( n > p \). In our regression examples for the nuclear
masses and the equation of state this is indeed the case, while for
the Ising model we have \( p > n \). These are often cases that lead to
near singular or singular matrices.
</p>

<p>The columns of \( \boldsymbol{U} \) are called the left singular vectors while the columns of \( \boldsymbol{V} \) are the right singular vectors.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="economy-size-svd">Economy-size SVD </h2>

<p>If we assume that \( n > p \), then our matrix \( \boldsymbol{U} \) has dimension \( n
\times n \). The last \( n-p \) columns of \( \boldsymbol{U} \) become however
irrelevant in our calculations since they are multiplied with the
zeros in \( \boldsymbol{\Sigma} \).
</p>

<p>The economy-size decomposition removes extra rows or columns of zeros
from the diagonal matrix of singular values, \( \boldsymbol{\Sigma} \), along with the columns
in either \( \boldsymbol{U} \) or \( \boldsymbol{V} \) that multiply those zeros in the expression. 
Removing these zeros and columns can improve execution time
and reduce storage requirements without compromising the accuracy of
the decomposition.
</p>

<p>If \( n > p \), we keep only the first \( p \) columns of \( \boldsymbol{U} \) and \( \boldsymbol{\Sigma} \) has dimension \( p\times p \). 
If \( p > n \), then only the first \( n \) columns of \( \boldsymbol{V} \) are computed and \( \boldsymbol{\Sigma} \) has dimension \( n\times n \).
The \( n=p \) case is obvious, we retain the full SVD. 
In general the economy-size SVD leads to less FLOPS and still conserving the desired accuracy.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="codes-for-the-svd">Codes for the SVD </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #228B22"># SVD inversion</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">SVD</span>(A):
    <span style="color: #CD5555">&#39;&#39;&#39; Takes as input a numpy matrix A and returns inv(A) based on singular value decomposition (SVD).</span>
<span style="color: #CD5555">    SVD is numerically more stable than the inversion algorithms provided by</span>
<span style="color: #CD5555">    numpy and scipy.linalg at the cost of being slower.</span>
<span style="color: #CD5555">    &#39;&#39;&#39;</span>
    U, S, VT = np.linalg.svd(A,full_matrices=<span style="color: #8B008B; font-weight: bold">True</span>)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;test U&#39;</span>)
    <span style="color: #658b00">print</span>( (np.transpose(U) @ U - U <span style="color: #707a7c">@np</span>.transpose(U)))
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;test VT&#39;</span>)
    <span style="color: #658b00">print</span>( (np.transpose(VT) @ VT - VT <span style="color: #707a7c">@np</span>.transpose(VT)))
    <span style="color: #658b00">print</span>(U)
    <span style="color: #658b00">print</span>(S)
    <span style="color: #658b00">print</span>(VT)

    D = np.zeros((<span style="color: #658b00">len</span>(U),<span style="color: #658b00">len</span>(VT)))
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,<span style="color: #658b00">len</span>(VT)):
        D[i,i]=S[i]
    <span style="color: #8B008B; font-weight: bold">return</span> U @ D @ VT


X = np.array([ [<span style="color: #B452CD">1.0</span>,-<span style="color: #B452CD">1.0</span>], [<span style="color: #B452CD">1.0</span>,-<span style="color: #B452CD">1.0</span>]])
<span style="color: #228B22">#X = np.array([[1, 2], [3, 4], [5, 6]])</span>

<span style="color: #658b00">print</span>(X)
C = SVD(X)
<span style="color: #228B22"># Print the difference between the original matrix and the SVD one</span>
<span style="color: #658b00">print</span>(C-X)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The matrix \( \boldsymbol{X} \) has columns that are linearly dependent. The first
column is the row-wise sum of the other two columns. The rank of a
matrix (the column rank) is the dimension of space spanned by the
column vectors. The rank of the matrix is the number of linearly
independent columns, in this case just \( 2 \). We see this from the
singular values when running the above code. Running the standard
inversion algorithm for matrix inversion with \( \boldsymbol{X}^T\boldsymbol{X} \) results
in the program terminating due to a singular matrix.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="note-about-svd-calculations">Note about SVD Calculations </h2>

<p>The \( U \), \( S \), and \( V \) matrices returned from the <b>svd()</b> function
cannot be multiplied directly.
</p>

<p>As you can see from the code, the \( S \) vector must be converted into a
diagonal matrix. This may cause a problem as the size of the matrices
do not fit the rules of matrix multiplication, where the number of
columns in a matrix must match the number of rows in the subsequent
matrix.
</p>

<p>If you wish to include the zero singular values, you will need to
resize the matrices and set up a diagonal matrix as done in the above
example
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="mathematics-of-the-svd-and-implications">Mathematics of the SVD and implications </h2>

<p>Let us take a closer look at the mathematics of the SVD and the various implications for machine learning studies.</p>

<p>Our starting point is our design matrix \( \boldsymbol{X} \) of dimension \( n\times p \)</p>
$$
\boldsymbol{X}=\begin{bmatrix}
x_{0,0} & x_{0,1} & x_{0,2}& \dots & \dots x_{0,p-1}\\
x_{1,0} & x_{1,1} & x_{1,2}& \dots & \dots x_{1,p-1}\\
x_{2,0} & x_{2,1} & x_{2,2}& \dots & \dots x_{2,p-1}\\
\dots & \dots & \dots & \dots \dots & \dots \\
x_{n-2,0} & x_{n-2,1} & x_{n-2,2}& \dots & \dots x_{n-2,p-1}\\
x_{n-1,0} & x_{n-1,1} & x_{n-1,2}& \dots & \dots x_{n-1,p-1}\\
\end{bmatrix}.
$$

<p>We can SVD decompose our matrix as</p>
$$
\boldsymbol{X}=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T,
$$

<p>where \( \boldsymbol{U} \) is an orthogonal matrix of dimension \( n\times n \), meaning that \( \boldsymbol{U}\boldsymbol{U}^T=\boldsymbol{U}^T\boldsymbol{U}=\boldsymbol{I}_n \). Here \( \boldsymbol{I}_n \) is the unit matrix of dimension \( n \times n \).</p>

<p>Similarly, \( \boldsymbol{V} \) is an orthogonal matrix of dimension \( p\times p \), meaning that \( \boldsymbol{V}\boldsymbol{V}^T=\boldsymbol{V}^T\boldsymbol{V}=\boldsymbol{I}_p \). Here \( \boldsymbol{I}_n \) is the unit matrix of dimension \( p \times p \).</p>

<p>Finally \( \boldsymbol{\Sigma} \) contains the singular values \( \sigma_i \). This matrix has dimension \( n\times p \) and the singular values \( \sigma_i \) are all positive. The non-zero values are ordered in descending order, that is</p>

$$
\sigma_0 > \sigma_1 > \sigma_2 > \dots > \sigma_{p-1} > 0. 
$$

<p>All values beyond \( p-1 \) are all zero.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-matrix">Example Matrix </h2>

<p>As an example, consider the following \( 3\times 2 \) example for the matrix \( \boldsymbol{\Sigma} \)</p>

$$
\boldsymbol{\Sigma}=
\begin{bmatrix}
2& 0 \\
0 & 1 \\
0 & 0 \\
\end{bmatrix}
$$

<p>The singular values are \( \sigma_0=2 \) and \( \sigma_1=1 \). It is common to rewrite the matrix \( \boldsymbol{\Sigma} \) as</p>

$$
\boldsymbol{\Sigma}=
\begin{bmatrix}
\boldsymbol{\tilde{\Sigma}}\\
\boldsymbol{0}\\
\end{bmatrix},
$$

<p>where</p>
$$
\boldsymbol{\tilde{\Sigma}}=
\begin{bmatrix}
2& 0 \\
0 & 1 \\
\end{bmatrix},
$$

<p>contains only the singular values.   Note also (and we will use this below) that</p>

$$
\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}=
\begin{bmatrix}
4& 0 \\
0 & 1 \\
\end{bmatrix},
$$

<p>which is a \( 2\times 2  \) matrix while</p>
$$
\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T=
\begin{bmatrix}
4& 0 & 0\\
0 & 1 & 0\\
0 & 0 & 0\\
\end{bmatrix},
$$

<p>is a \( 3\times 3  \) matrix. The last row and column of this last matrix
contain only zeros. This will have important consequences for our SVD
decomposition of the design matrix.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="setting-up-the-matrix-to-be-inverted">Setting up the Matrix to be inverted </h2>

<p>The matrix that may cause problems for us is \( \boldsymbol{X}^T\boldsymbol{X} \). Using the SVD we can rewrite this matrix as</p>

$$
\boldsymbol{X}^T\boldsymbol{X}=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{U}^T\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T,
$$

<p>and using the orthogonality of the matrix \( \boldsymbol{U} \) we have</p>

$$
\boldsymbol{X}^T\boldsymbol{X}=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\boldsymbol{V}^T.
$$

<p>We define \( \boldsymbol{\Sigma}^T\boldsymbol{\Sigma}=\tilde{\boldsymbol{\Sigma}}^2 \) which is  a diagonal matrix containing only the singular values squared. It has dimensionality \( p \times p \).</p>

<p>We can now insert the result for the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) into our equation for ordinary least squares where</p>

$$
\tilde{y}_{\mathrm{OLS}}=\boldsymbol{X}\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y},
$$

<p>and using our SVD decomposition of \( \boldsymbol{X} \) we have</p>

$$
\tilde{y}_{\mathrm{OLS}}=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T\left(\boldsymbol{V}\tilde{\boldsymbol{\Sigma}}^{2}(\boldsymbol{V}^T\right)^{-1}\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{U}^T\boldsymbol{y},
$$

<p>which gives us, using the orthogonality of the matrix \( \boldsymbol{V} \),</p>

$$
\tilde{y}_{\mathrm{OLS}}=\boldsymbol{U}\boldsymbol{U}^T\boldsymbol{y}=\sum_{i=0}^{p-1}\boldsymbol{u}_i\boldsymbol{u}^T_i\boldsymbol{y},
$$

<p>It means that the ordinary least square model (with the optimal
parameters) \( \boldsymbol{\tilde{y}} \), corresponds to an orthogonal
transformation of the output (or target) vector \( \boldsymbol{y} \) by the
vectors of the matrix \( \boldsymbol{U} \). <b>Note that the summation ends at</b>
\( p-1 \), that is \( \boldsymbol{\tilde{y}}\ne \boldsymbol{y} \). We can thus not use the
orthogonality relation for the matrix \( \boldsymbol{U} \). This can already be
when we multiply the matrices \( \boldsymbol{\Sigma}^T\boldsymbol{U}^T \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="further-properties-important-for-our-analyses-later">Further properties (important for our analyses later) </h2>

<p>Let us study again \( \boldsymbol{X}^T\boldsymbol{X} \) in terms of our SVD,</p>
$$
\boldsymbol{X}^T\boldsymbol{X}=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{U}^T\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\boldsymbol{V}^T. 
$$

<p>If we now multiply from the right with \( \boldsymbol{V} \) (using the orthogonality of \( \boldsymbol{V} \)) we get</p>
$$
\left(\boldsymbol{X}^T\boldsymbol{X}\right)\boldsymbol{V}=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}. 
$$

<p>This means the vectors \( \boldsymbol{v}_i \) of the orthogonal matrix \( \boldsymbol{V} \) are the eigenvectors of the matrix \( \boldsymbol{X}^T\boldsymbol{X} \)
with eigenvalues given by the singular values squared, that is
</p>
$$
\left(\boldsymbol{X}^T\boldsymbol{X}\right)\boldsymbol{v}_i=\boldsymbol{v}_i\sigma_i^2. 
$$

<p>Similarly, if we use the SVD decomposition for the matrix \( \boldsymbol{X}\boldsymbol{X}^T \), we have</p>
$$
\boldsymbol{X}\boldsymbol{X}^T=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{U}^T=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T\boldsymbol{U}^T. 
$$

<p>If we now multiply from the right with \( \boldsymbol{U} \) (using the orthogonality of \( \boldsymbol{U} \)) we get</p>
$$
\left(\boldsymbol{X}\boldsymbol{X}^T\right)\boldsymbol{U}=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T. 
$$

<p>This means the vectors \( \boldsymbol{u}_i \) of the orthogonal matrix \( \boldsymbol{U} \) are the eigenvectors of the matrix \( \boldsymbol{X}\boldsymbol{X}^T \)
with eigenvalues given by the singular values squared, that is
</p>
$$
\left(\boldsymbol{X}\boldsymbol{X}^T\right)\boldsymbol{u}_i=\boldsymbol{u}_i\sigma_i^2. 
$$

<p><b>Important note</b>: we have defined our design matrix \( \boldsymbol{X} \) to be an
\( n\times p \) matrix. In most supervised learning cases we have that \( n
\ge p \), and quite often we have \( n >> p \). For linear algebra based methods like ordinary least squares or Ridge regression, this leads to a matrix \( \boldsymbol{X}^T\boldsymbol{X} \) which is small and thereby easier to handle from a computational point of view (in terms of number of floating point operations).
</p>

<p>In our lectures, the number of columns will
always refer to the number of features in our data set, while the
number of rows represents the number of data inputs. Note that in
other texts you may find the opposite notation. This has consequences
for the definition of for example the covariance matrix and its relation to the SVD.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="meet-the-covariance-matrix">Meet the Covariance Matrix </h2>

<p>Before we move on to a discussion of Ridge and Lasso regression, we want to show an important example of the above.</p>

<p>We have already noted that the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) in ordinary
least squares is proportional to the second derivative of the cost
function, that is we have
</p>

$$
\frac{\partial^2 C(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}\partial \boldsymbol{\beta}^T} =\frac{2}{n}\boldsymbol{X}^T\boldsymbol{X}.  
$$

<p>This quantity defines was what is called the Hessian matrix (the second derivative of a function we want to optimize).</p>

<p>The Hessian matrix plays an important role and is defined in this course as</p>

$$
\boldsymbol{H}=\boldsymbol{X}^T\boldsymbol{X}.
$$

<p>The Hessian matrix for ordinary least squares is also proportional to
the covariance matrix. This means also that we can use the SVD to find
the eigenvalues of the covariance matrix and the Hessian matrix in
terms of the singular values.   Let us develop these arguments, as they will play an important role in our machine learning studies.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="introducing-the-covariance-and-correlation-functions">Introducing the Covariance and Correlation functions  </h2>

<p>Before we discuss the link between for example Ridge regression and the singular value decomposition, we need to remind ourselves about
the definition of the covariance and the correlation function. These are quantities that play a central role in machine learning methods.
</p>

<p>Suppose we have defined two vectors
\( \hat{x} \) and \( \hat{y} \) with \( n \) elements each. The covariance matrix \( \boldsymbol{C} \) is defined as 
</p>
$$
\boldsymbol{C}[\boldsymbol{x},\boldsymbol{y}] = \begin{bmatrix} \mathrm{cov}[\boldsymbol{x},\boldsymbol{x}] & \mathrm{cov}[\boldsymbol{x},\boldsymbol{y}] \\
                              \mathrm{cov}[\boldsymbol{y},\boldsymbol{x}] & \mathrm{cov}[\boldsymbol{y},\boldsymbol{y}] \\
             \end{bmatrix},
$$

<p>where for example</p>
$$
\mathrm{cov}[\boldsymbol{x},\boldsymbol{y}] =\frac{1}{n} \sum_{i=0}^{n-1}(x_i- \overline{x})(y_i- \overline{y}).
$$

<p>With this definition and recalling that the variance is defined as</p>
$$
\mathrm{var}[\boldsymbol{x}]=\frac{1}{n} \sum_{i=0}^{n-1}(x_i- \overline{x})^2,
$$

<p>we can rewrite the covariance matrix as </p>
$$
\boldsymbol{C}[\boldsymbol{x},\boldsymbol{y}] = \begin{bmatrix} \mathrm{var}[\boldsymbol{x}] & \mathrm{cov}[\boldsymbol{x},\boldsymbol{y}] \\
                              \mathrm{cov}[\boldsymbol{x},\boldsymbol{y}] & \mathrm{var}[\boldsymbol{y}] \\
             \end{bmatrix}.
$$

<p><b>Note:</b> we have used \( 1/n \) in the above definitions of the <em>sample</em> variance and covariance. We assume then that we can calculate the exact mean value. 
What you will find in essentially all statistics texts are equations
with a factor \( 1/(n-1) \). This is called <a href="https://mathworld.wolfram.com/BesselsCorrection.html" target="_blank">Bessel's correction</a>. This
method corrects the bias in the estimation of the population variance
and covariance. It also partially corrects the bias in the estimation
of the population standard deviation. If you use a library like
<b>Scikit-Learn</b> or <b>nunmpy's</b> function to calculate the covariance, this
quantity will be computed with a factor \( 1/(n-1) \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="covariance-and-correlation-matrix">Covariance and Correlation Matrix </h2>

<p>The covariance takes values between zero and infinity and may thus
lead to problems with loss of numerical precision for particularly
large values. It is common to scale the covariance matrix by
introducing instead the correlation matrix defined via the so-called
correlation function
</p>

$$
\mathrm{corr}[\boldsymbol{x},\boldsymbol{y}]=\frac{\mathrm{cov}[\boldsymbol{x},\boldsymbol{y}]}{\sqrt{\mathrm{var}[\boldsymbol{x}] \mathrm{var}[\boldsymbol{y}]}}.
$$

<p>The correlation function is then given by values \( \mathrm{corr}[\boldsymbol{x},\boldsymbol{y}]
\in [-1,1] \). This avoids eventual problems with too large values. We
can then define the correlation matrix for the two vectors \( \boldsymbol{x} \)
and \( \boldsymbol{y} \) as
</p>

$$
\boldsymbol{K}[\boldsymbol{x},\boldsymbol{y}] = \begin{bmatrix} 1 & \mathrm{corr}[\boldsymbol{x},\boldsymbol{y}] \\
                              \mathrm{corr}[\boldsymbol{y},\boldsymbol{x}] & 1 \\
             \end{bmatrix},
$$

<p>In the above example this is the function we constructed using <b>pandas</b>.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="correlation-function-and-design-feature-matrix">Correlation Function and Design/Feature Matrix </h2>

<p>In our derivation of the various regression algorithms like <b>Ordinary Least Squares</b> or <b>Ridge regression</b>
we defined the design/feature matrix \( \boldsymbol{X} \) as
</p>

$$
\boldsymbol{X}=\begin{bmatrix}
x_{0,0} & x_{0,1} & x_{0,2}& \dots & \dots x_{0,p-1}\\
x_{1,0} & x_{1,1} & x_{1,2}& \dots & \dots x_{1,p-1}\\
x_{2,0} & x_{2,1} & x_{2,2}& \dots & \dots x_{2,p-1}\\
\dots & \dots & \dots & \dots \dots & \dots \\
x_{n-2,0} & x_{n-2,1} & x_{n-2,2}& \dots & \dots x_{n-2,p-1}\\
x_{n-1,0} & x_{n-1,1} & x_{n-1,2}& \dots & \dots x_{n-1,p-1}\\
\end{bmatrix},
$$

<p>with \( \boldsymbol{X}\in {\mathbb{R}}^{n\times p} \), with the predictors/features \( p \)  refering to the column numbers and the
entries \( n \) being the row elements.
We can rewrite the design/feature matrix in terms of its column vectors as
</p>
$$
\boldsymbol{X}=\begin{bmatrix} \boldsymbol{x}_0 & \boldsymbol{x}_1 & \boldsymbol{x}_2 & \dots & \dots & \boldsymbol{x}_{p-1}\end{bmatrix},
$$

<p>with a given vector</p>
$$
\boldsymbol{x}_i^T = \begin{bmatrix}x_{0,i} & x_{1,i} & x_{2,i}& \dots & \dots x_{n-1,i}\end{bmatrix}.
$$

<p>With these definitions, we can now rewrite our \( 2\times 2 \)
correlation/covariance matrix in terms of a moe general design/feature
matrix \( \boldsymbol{X}\in {\mathbb{R}}^{n\times p} \). This leads to a \( p\times p \)
covariance matrix for the vectors \( \boldsymbol{x}_i \) with \( i=0,1,\dots,p-1 \)
</p>

$$
\boldsymbol{C}[\boldsymbol{x}] = \begin{bmatrix}
\mathrm{var}[\boldsymbol{x}_0] & \mathrm{cov}[\boldsymbol{x}_0,\boldsymbol{x}_1]  & \mathrm{cov}[\boldsymbol{x}_0,\boldsymbol{x}_2] & \dots & \dots & \mathrm{cov}[\boldsymbol{x}_0,\boldsymbol{x}_{p-1}]\\
\mathrm{cov}[\boldsymbol{x}_1,\boldsymbol{x}_0] & \mathrm{var}[\boldsymbol{x}_1]  & \mathrm{cov}[\boldsymbol{x}_1,\boldsymbol{x}_2] & \dots & \dots & \mathrm{cov}[\boldsymbol{x}_1,\boldsymbol{x}_{p-1}]\\
\mathrm{cov}[\boldsymbol{x}_2,\boldsymbol{x}_0]   & \mathrm{cov}[\boldsymbol{x}_2,\boldsymbol{x}_1] & \mathrm{var}[\boldsymbol{x}_2] & \dots & \dots & \mathrm{cov}[\boldsymbol{x}_2,\boldsymbol{x}_{p-1}]\\
\dots & \dots & \dots & \dots & \dots & \dots \\
\dots & \dots & \dots & \dots & \dots & \dots \\
\mathrm{cov}[\boldsymbol{x}_{p-1},\boldsymbol{x}_0]   & \mathrm{cov}[\boldsymbol{x}_{p-1},\boldsymbol{x}_1] & \mathrm{cov}[\boldsymbol{x}_{p-1},\boldsymbol{x}_{2}]  & \dots & \dots  & \mathrm{var}[\boldsymbol{x}_{p-1}]\\
\end{bmatrix},
$$

<p>and the correlation matrix</p>
$$
\boldsymbol{K}[\boldsymbol{x}] = \begin{bmatrix}
1 & \mathrm{corr}[\boldsymbol{x}_0,\boldsymbol{x}_1]  & \mathrm{corr}[\boldsymbol{x}_0,\boldsymbol{x}_2] & \dots & \dots & \mathrm{corr}[\boldsymbol{x}_0,\boldsymbol{x}_{p-1}]\\
\mathrm{corr}[\boldsymbol{x}_1,\boldsymbol{x}_0] & 1  & \mathrm{corr}[\boldsymbol{x}_1,\boldsymbol{x}_2] & \dots & \dots & \mathrm{corr}[\boldsymbol{x}_1,\boldsymbol{x}_{p-1}]\\
\mathrm{corr}[\boldsymbol{x}_2,\boldsymbol{x}_0]   & \mathrm{corr}[\boldsymbol{x}_2,\boldsymbol{x}_1] & 1 & \dots & \dots & \mathrm{corr}[\boldsymbol{x}_2,\boldsymbol{x}_{p-1}]\\
\dots & \dots & \dots & \dots & \dots & \dots \\
\dots & \dots & \dots & \dots & \dots & \dots \\
\mathrm{corr}[\boldsymbol{x}_{p-1},\boldsymbol{x}_0]   & \mathrm{corr}[\boldsymbol{x}_{p-1},\boldsymbol{x}_1] & \mathrm{corr}[\boldsymbol{x}_{p-1},\boldsymbol{x}_{2}]  & \dots & \dots  & 1\\
\end{bmatrix},
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="covariance-matrix-examples">Covariance Matrix Examples </h2>

<p>The Numpy function <b>np.cov</b> calculates the covariance elements using
the factor \( 1/(n-1) \) instead of \( 1/n \) since it assumes we do not have
the exact mean values.  The following simple function uses the
<b>np.vstack</b> function which takes each vector of dimension \( 1\times n \)
and produces a \( 2\times n \) matrix \( \boldsymbol{W} \)
</p>

<p>Note that this assumes you have the features as the rows, and the inputs as columns, that is</p>
$$
\boldsymbol{W} = \begin{bmatrix} x_0 & x_1 & x_2 & \dots & x_{n-2} & x_{n-1} \\
                     y_0 & y_1 & y_2 & \dots & y_{n-2} & y_{n-1} \\
             \end{bmatrix},
$$

<p>which in turn is converted into into the \( 2\times 2 \) covariance matrix
\( \boldsymbol{C} \) via the Numpy function <b>np.cov()</b>. We note that we can also calculate
the mean value of each set of samples \( \boldsymbol{x} \) etc using the Numpy
function <b>np.mean(x)</b>. We can also extract the eigenvalues of the
covariance matrix through the <b>np.linalg.eig()</b> function.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Importing various packages</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
n = <span style="color: #B452CD">100</span>
x = np.random.normal(size=n)
<span style="color: #658b00">print</span>(np.mean(x))
y = <span style="color: #B452CD">4</span>+<span style="color: #B452CD">3</span>*x+np.random.normal(size=n)
<span style="color: #658b00">print</span>(np.mean(y))
W = np.vstack((x, y))
C = np.cov(W)
<span style="color: #658b00">print</span>(C)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="correlation-matrix">Correlation Matrix  </h2>

<p>The previous example can be converted into the correlation matrix by
simply scaling the matrix elements with the variances.  We should also
subtract the mean values for each column. This leads to the following
code which sets up the correlations matrix for the previous example in
a more brute force way. Here we scale the mean values for each column of the design matrix, calculate the relevant mean values and variances and then finally set up the \( 2\times 2 \) correlation matrix (since we have only two vectors). 
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
n = <span style="color: #B452CD">100</span>
<span style="color: #228B22"># define two vectors                                                                                           </span>
x = np.random.random(size=n)
y = <span style="color: #B452CD">4</span>+<span style="color: #B452CD">3</span>*x+np.random.normal(size=n)
<span style="color: #228B22">#scaling the x and y vectors                                                                                   </span>
x = x - np.mean(x)
y = y - np.mean(y)
variance_x = np.sum(x<span style="color: #707a7c">@x</span>)/n
variance_y = np.sum(y<span style="color: #707a7c">@y</span>)/n
<span style="color: #658b00">print</span>(variance_x)
<span style="color: #658b00">print</span>(variance_y)
cov_xy = np.sum(x<span style="color: #707a7c">@y</span>)/n
cov_xx = np.sum(x<span style="color: #707a7c">@x</span>)/n
cov_yy = np.sum(y<span style="color: #707a7c">@y</span>)/n
C = np.zeros((<span style="color: #B452CD">2</span>,<span style="color: #B452CD">2</span>))
C[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>]= cov_xx/variance_x
C[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>]= cov_yy/variance_y
C[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]= cov_xy/np.sqrt(variance_y*variance_x)
C[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>]= C[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]
<span style="color: #658b00">print</span>(C)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We see that the matrix elements along the diagonal are one as they
should be and that the matrix is symmetric. Furthermore, diagonalizing
this matrix we easily see that it is a positive definite matrix.
</p>

<p>The above procedure with <b>numpy</b> can be made more compact if we use <b>pandas</b>.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="correlation-matrix-with-pandas">Correlation Matrix with Pandas </h2>

<p>We whow here how we can set up the correlation matrix using <b>pandas</b>, as done in this simple code</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
n = <span style="color: #B452CD">10</span>
x = np.random.normal(size=n)
x = x - np.mean(x)
y = <span style="color: #B452CD">4</span>+<span style="color: #B452CD">3</span>*x+np.random.normal(size=n)
y = y - np.mean(y)
<span style="color: #228B22"># Note that we transpose the matrix in order to stay with our ordering n x p</span>
X = (np.vstack((x, y))).T
<span style="color: #658b00">print</span>(X)
Xpd = pd.DataFrame(X)
<span style="color: #658b00">print</span>(Xpd)
correlation_matrix = Xpd.corr()
<span style="color: #658b00">print</span>(correlation_matrix)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We expand this model to the Franke function discussed above.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="correlation-matrix-with-pandas-and-the-franke-function">Correlation Matrix with Pandas and the Franke function </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">FrankeFunction</span>(x,y):
	term1 = <span style="color: #B452CD">0.75</span>*np.exp(-(<span style="color: #B452CD">0.25</span>*(<span style="color: #B452CD">9</span>*x-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>) - <span style="color: #B452CD">0.25</span>*((<span style="color: #B452CD">9</span>*y-<span style="color: #B452CD">2</span>)**<span style="color: #B452CD">2</span>))
	term2 = <span style="color: #B452CD">0.75</span>*np.exp(-((<span style="color: #B452CD">9</span>*x+<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">49.0</span> - <span style="color: #B452CD">0.1</span>*(<span style="color: #B452CD">9</span>*y+<span style="color: #B452CD">1</span>))
	term3 = <span style="color: #B452CD">0.5</span>*np.exp(-(<span style="color: #B452CD">9</span>*x-<span style="color: #B452CD">7</span>)**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">4.0</span> - <span style="color: #B452CD">0.25</span>*((<span style="color: #B452CD">9</span>*y-<span style="color: #B452CD">3</span>)**<span style="color: #B452CD">2</span>))
	term4 = -<span style="color: #B452CD">0.2</span>*np.exp(-(<span style="color: #B452CD">9</span>*x-<span style="color: #B452CD">4</span>)**<span style="color: #B452CD">2</span> - (<span style="color: #B452CD">9</span>*y-<span style="color: #B452CD">7</span>)**<span style="color: #B452CD">2</span>)
	<span style="color: #8B008B; font-weight: bold">return</span> term1 + term2 + term3 + term4


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">create_X</span>(x, y, n ):
	<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(x.shape) &gt; <span style="color: #B452CD">1</span>:
		x = np.ravel(x)
		y = np.ravel(y)

	N = <span style="color: #658b00">len</span>(x)
	l = <span style="color: #658b00">int</span>((n+<span style="color: #B452CD">1</span>)*(n+<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">2</span>)		<span style="color: #228B22"># Number of elements in beta</span>
	X = np.ones((N,l))

	<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,n+<span style="color: #B452CD">1</span>):
		q = <span style="color: #658b00">int</span>((i)*(i+<span style="color: #B452CD">1</span>)/<span style="color: #B452CD">2</span>)
		<span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i+<span style="color: #B452CD">1</span>):
			X[:,q+k] = (x**(i-k))*(y**k)

	<span style="color: #8B008B; font-weight: bold">return</span> X


<span style="color: #228B22"># Making meshgrid of datapoints and compute Franke&#39;s function</span>
n = <span style="color: #B452CD">4</span>
N = <span style="color: #B452CD">100</span>
x = np.sort(np.random.uniform(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, N))
y = np.sort(np.random.uniform(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, N))
z = FrankeFunction(x, y)
X = create_X(x, y, n=n)    

Xpd = pd.DataFrame(X)
<span style="color: #228B22"># subtract the mean values and set up the covariance matrix</span>
Xpd = Xpd - Xpd.mean()
covariance_matrix = Xpd.cov()
<span style="color: #658b00">print</span>(covariance_matrix)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We note here that the covariance is zero for the first rows and
columns since all matrix elements in the design matrix were set to one
(we are fitting the function in terms of a polynomial of degree \( n \)).
</p>

<p>This means that the variance for these elements will be zero and will
cause problems when we set up the correlation matrix.  We can simply
drop these elements and construct a correlation
matrix without these elements. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rewriting-the-covariance-and-or-correlation-matrix">Rewriting the Covariance and/or Correlation Matrix </h2>

<p>We can rewrite the covariance matrix in a more compact form in terms of the design/feature matrix \( \boldsymbol{X} \) as </p>
$$
\boldsymbol{C}[\boldsymbol{x}] = \frac{1}{n}\boldsymbol{X}^T\boldsymbol{X}= \mathbb{E}[\boldsymbol{X}^T\boldsymbol{X}].
$$

<p>To see this let us simply look at a design matrix \( \boldsymbol{X}\in {\mathbb{R}}^{2\times 2} \)</p>
$$
\boldsymbol{X}=\begin{bmatrix}
x_{00} & x_{01}\\
x_{10} & x_{11}\\
\end{bmatrix}=\begin{bmatrix}
\boldsymbol{x}_{0} & \boldsymbol{x}_{1}\\
\end{bmatrix}.
$$

<p>If we then compute the expectation value (note the \( 1/n \) factor instead of \( 1/(n-1) \))</p>
$$
\mathbb{E}[\boldsymbol{X}^T\boldsymbol{X}] = \frac{1}{n}\boldsymbol{X}^T\boldsymbol{X}=\frac{1}{n}\begin{bmatrix}
x_{00}^2+x_{10}^2 & x_{00}x_{01}+x_{10}x_{11}\\
x_{01}x_{00}+x_{11}x_{10} & x_{01}^2+x_{11}^2\\
\end{bmatrix},
$$

<p>which is just </p>
$$
\boldsymbol{C}[\boldsymbol{x}_0,\boldsymbol{x}_1] = \boldsymbol{C}[\boldsymbol{x}]=\begin{bmatrix} \mathrm{var}[\boldsymbol{x}_0] & \mathrm{cov}[\boldsymbol{x}_0,\boldsymbol{x}_1] \\
                              \mathrm{cov}[\boldsymbol{x}_1,\boldsymbol{x}_0] & \mathrm{var}[\boldsymbol{x}_1] \\
             \end{bmatrix},
$$

<p>where we wrote $$\boldsymbol{C}[\boldsymbol{x}_0,\boldsymbol{x}_1] = \boldsymbol{C}[\boldsymbol{x}]$$ to indicate that this is the covariance of the vectors \( \boldsymbol{x} \) of the design/feature matrix \( \boldsymbol{X} \).</p>

<p>It is easy to generalize this to a matrix \( \boldsymbol{X}\in {\mathbb{R}}^{n\times p} \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="linking-with-the-svd">Linking with the SVD </h2>

<p>We saw earlier that </p>
$$
\boldsymbol{X}^T\boldsymbol{X}=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{U}^T\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T=\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\boldsymbol{V}^T. 
$$

<p>Since the matrices here have dimension \( p\times p \), with \( p \) corresponding to the singular values, we defined earlier the matrix</p>
$$
\boldsymbol{\Sigma}^T\boldsymbol{\Sigma} = \begin{bmatrix} \tilde{\boldsymbol{\Sigma}} & \boldsymbol{0}\\ \end{bmatrix}\begin{bmatrix} \tilde{\boldsymbol{\Sigma}} \\ \boldsymbol{0}\\ \end{bmatrix},
$$

<p>where the tilde-matrix \( \tilde{\boldsymbol{\Sigma}} \) is a matrix of dimension \( p\times p \) containing only the singular values \( \sigma_i \), that is</p>

$$
\tilde{\boldsymbol{\Sigma}}=\begin{bmatrix} \sigma_0 & 0 & 0 & \dots & 0 & 0 \\
                                    0 & \sigma_1 & 0 & \dots & 0 & 0 \\
				    0 & 0 & \sigma_2 & \dots & 0 & 0 \\
				    0 & 0 & 0 & \dots & \sigma_{p-2} & 0 \\
				    0 & 0 & 0 & \dots & 0 & \sigma_{p-1} \\
\end{bmatrix},
$$

<p>meaning we can write</p>
$$
\boldsymbol{X}^T\boldsymbol{X}=\boldsymbol{V}\tilde{\boldsymbol{\Sigma}}^2\boldsymbol{V}^T. 
$$

<p>Multiplying from the right with \( \boldsymbol{V} \) (using the orthogonality of \( \boldsymbol{V} \)) we get</p>
$$
\left(\boldsymbol{X}^T\boldsymbol{X}\right)\boldsymbol{V}=\boldsymbol{V}\tilde{\boldsymbol{\Sigma}}^2. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="what-does-it-mean">What does it mean? </h2>

<p>This means the vectors \( \boldsymbol{v}_i \) of the orthogonal matrix \( \boldsymbol{V} \)
are the eigenvectors of the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) with eigenvalues
given by the singular values squared, that is
</p>

$$
\left(\boldsymbol{X}^T\boldsymbol{X}\right)\boldsymbol{v}_i=\boldsymbol{v}_i\sigma_i^2. 
$$

<p>In other words, each non-zero singular value of \( \boldsymbol{X} \) is a positive
square root of an eigenvalue of \( \boldsymbol{X}^T\boldsymbol{X} \).  It means also that
the columns of \( \boldsymbol{V} \) are the eigenvectors of
\( \boldsymbol{X}^T\boldsymbol{X} \). Since we have ordered the singular values of
\( \boldsymbol{X} \) in a descending order, it means that the column vectors
\( \boldsymbol{v}_i \) are hierarchically ordered by how much correlation they
encode from the columns of \( \boldsymbol{X} \). 
</p>

<p>Note that these are also the eigenvectors and eigenvalues of the
Hessian matrix. Note also that the Hessian matrix we are discussing here is from a cost function defined by the  mean squared error only.
</p>

<p>If we now recall the definition of the covariance matrix (not using
Bessel's correction) we have
</p>

$$
\boldsymbol{C}[\boldsymbol{X}]=\frac{1}{n}\boldsymbol{X}^T\boldsymbol{X},
$$

<p>meaning that every squared non-singular value of \( \boldsymbol{X} \) divided by \( n \) (
the number of samples) are the eigenvalues of the covariance
matrix. Every singular value of \( \boldsymbol{X} \) is thus a positive square
root of an eigenvalue of \( \boldsymbol{X}^T\boldsymbol{X} \). If the matrix \( \boldsymbol{X} \) is
self-adjoint, the singular values of \( \boldsymbol{X} \) are equal to the
absolute value of the eigenvalues of \( \boldsymbol{X} \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="and-finally-boldsymbol-x-boldsymbol-x-t">And finally  \( \boldsymbol{X}\boldsymbol{X}^T \) </h2>

<p>For \( \boldsymbol{X}\boldsymbol{X}^T \) we found</p>

$$
\boldsymbol{X}\boldsymbol{X}^T=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T\boldsymbol{V}\boldsymbol{\Sigma}^T\boldsymbol{U}^T=\boldsymbol{U}\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\boldsymbol{U}^T. 
$$

<p>Since the matrices here have dimension \( n\times n \), we have</p>
$$
\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T = \begin{bmatrix} \tilde{\boldsymbol{\Sigma}} \\ \boldsymbol{0}\\ \end{bmatrix}\begin{bmatrix} \tilde{\boldsymbol{\Sigma}}  \boldsymbol{0}\\ \end{bmatrix}=\begin{bmatrix} \tilde{\boldsymbol{\Sigma}} & \boldsymbol{0} \\ \boldsymbol{0} & \boldsymbol{0}\\ \end{bmatrix}, 
$$

<p>leading to</p>
$$
\boldsymbol{X}\boldsymbol{X}^T=\boldsymbol{U}\begin{bmatrix} \tilde{\boldsymbol{\Sigma}} & \boldsymbol{0} \\ \boldsymbol{0} & \boldsymbol{0}\\ \end{bmatrix}\boldsymbol{U}^T. 
$$

<p>Multiplying with \( \boldsymbol{U} \) from the right gives us the eigenvalue problem</p>
$$
(\boldsymbol{X}\boldsymbol{X}^T)\boldsymbol{U}=\boldsymbol{U}\begin{bmatrix} \tilde{\boldsymbol{\Sigma}} & \boldsymbol{0} \\ \boldsymbol{0} & \boldsymbol{0}\\ \end{bmatrix}. 
$$

<p>It means that the eigenvalues of \( \boldsymbol{X}\boldsymbol{X}^T \) are again given by
the non-zero singular values plus now a series of zeros.  The column
vectors of \( \boldsymbol{U} \) are the eigenvectors of \( \boldsymbol{X}\boldsymbol{X}^T \) and
measure how much correlations are contained in the rows of \( \boldsymbol{X} \).
</p>

<p>Since we will mainly be interested in the correlations among the features
of our data (the columns of \( \boldsymbol{X} \), the quantity of interest for us are the non-zero singular
values and the column vectors of \( \boldsymbol{V} \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ridge-and-lasso-regression">Ridge and LASSO Regression </h2>

<p>Let us remind ourselves about the expression for the standard Mean Squared Error (MSE) which we used to define our cost function and the equations for the ordinary least squares (OLS) method, that is 
our optimization problem is
</p>
$$
{\displaystyle \min_{\boldsymbol{\beta}\in {\mathbb{R}}^{p}}}\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\right)\right\}.
$$

<p>or we can state it as</p>
$$
{\displaystyle \min_{\boldsymbol{\beta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\vert\vert_2^2,
$$

<p>where we have used the definition of  a norm-2 vector, that is</p>
$$
\vert\vert \boldsymbol{x}\vert\vert_2 = \sqrt{\sum_i x_i^2}. 
$$

<p>By minimizing the above equation with respect to the parameters
\( \boldsymbol{\beta} \) we could then obtain an analytical expression for the
parameters \( \boldsymbol{\beta} \).  We can add a regularization parameter \( \lambda \) by
defining a new cost function to be optimized, that is
</p>

$$
{\displaystyle \min_{\boldsymbol{\beta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\beta}\vert\vert_2^2
$$

<p>which leads to the Ridge regression minimization problem where we
require that \( \vert\vert \boldsymbol{\beta}\vert\vert_2^2\le t \), where \( t \) is
a finite number larger than zero. By defining
</p>

$$
C(\boldsymbol{X},\boldsymbol{\beta})=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\beta}\vert\vert_1,
$$

<p>we have a new optimization equation</p>
$$
{\displaystyle \min_{\boldsymbol{\beta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\beta}\vert\vert_1
$$

<p>which leads to Lasso regression. Lasso stands for least absolute shrinkage and selection operator. </p>

<p>Here we have defined the norm-1 as </p>
$$
\vert\vert \boldsymbol{x}\vert\vert_1 = \sum_i \vert x_i\vert. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="deriving-the-ridge-regression-equations">Deriving the  Ridge Regression Equations </h2>

<p>Using the matrix-vector expression for Ridge regression and dropping the parameter \( 1/n \) in front of the standard means squared error equation, we have</p>

$$
C(\boldsymbol{X},\boldsymbol{\beta})=\left\{(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\right\}+\lambda\boldsymbol{\beta}^T\boldsymbol{\beta},
$$

<p>and 
taking the derivatives with respect to \( \boldsymbol{\beta} \) we obtain then
a slightly modified matrix inversion problem which for finite values
of \( \lambda \) does not suffer from singularity problems. We obtain
the optimal parameters
</p>
$$
\hat{\boldsymbol{\beta}}_{\mathrm{Ridge}} = \left(\boldsymbol{X}^T\boldsymbol{X}+\lambda\boldsymbol{I}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y},
$$

<p>with \( \boldsymbol{I} \) being a \( p\times p \) identity matrix with the constraint that</p>

$$
\sum_{i=0}^{p-1} \beta_i^2 \leq t,
$$

<p>with \( t \) a finite positive number. </p>

<p>If we keep the \( 1/n \) factor, the equation for the optimal \( \beta \) changes to</p>
$$
\hat{\boldsymbol{\beta}}_{\mathrm{Ridge}} = \left(\boldsymbol{X}^T\boldsymbol{X}+n\lambda\boldsymbol{I}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>In many textbooks the \( 1/n \) term is often omitted. Note that a library like <b>Scikit-Learn</b> does not include the \( 1/n \) factor in the setup of the cost function.</p>

<p>When we compare this with the ordinary least squares result we have</p>
$$
\hat{\boldsymbol{\beta}}_{\mathrm{OLS}} = \left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y},
$$

<p>which can lead to singular matrices. However, with the SVD, we can always compute the inverse of the matrix \( \boldsymbol{X}^T\boldsymbol{X} \).</p>

<p>We see that Ridge regression is nothing but the standard OLS with a
modified diagonal term added to \( \boldsymbol{X}^T\boldsymbol{X} \). The consequences, in
particular for our discussion of the bias-variance tradeoff are rather
interesting. We will see that for specific values of \( \lambda \), we may
even reduce the variance of the optimal parameters \( \boldsymbol{\beta} \). These topics and other related ones, will be discussed after the more linear algebra oriented analysis here.
</p>

<p>Using our insights about the SVD of the design matrix \( \boldsymbol{X} \) 
We have already analyzed the OLS solutions in terms of the eigenvectors (the columns) of the right singular value matrix \( \boldsymbol{U} \) as
</p>
$$
\tilde{\boldsymbol{y}}_{\mathrm{OLS}}=\boldsymbol{X}\boldsymbol{\beta}  =\boldsymbol{U}\boldsymbol{U}^T\boldsymbol{y}.
$$

<p>For Ridge regression this becomes</p>

$$
\tilde{\boldsymbol{y}}_{\mathrm{Ridge}}=\boldsymbol{X}\boldsymbol{\beta}_{\mathrm{Ridge}} = \boldsymbol{U\Sigma V^T}\left(\boldsymbol{V}\boldsymbol{\Sigma}^2\boldsymbol{V}^T+\lambda\boldsymbol{I} \right)^{-1}(\boldsymbol{U\Sigma V^T})^T\boldsymbol{y}=\sum_{j=0}^{p-1}\boldsymbol{u}_j\boldsymbol{u}_j^T\frac{\sigma_j^2}{\sigma_j^2+\lambda}\boldsymbol{y},
$$

<p>with the vectors \( \boldsymbol{u}_j \) being the columns of \( \boldsymbol{U} \) from the SVD of the matrix \( \boldsymbol{X} \). </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="interpreting-the-ridge-results">Interpreting the Ridge results </h2>

<p>Since \( \lambda \geq 0 \), it means that compared to OLS, we have </p>

$$
\frac{\sigma_j^2}{\sigma_j^2+\lambda} \leq 1. 
$$

<p>Ridge regression finds the coordinates of \( \boldsymbol{y} \) with respect to the
orthonormal basis \( \boldsymbol{U} \), it then shrinks the coordinates by
\( \frac{\sigma_j^2}{\sigma_j^2+\lambda} \). Recall that the SVD has
eigenvalues ordered in a descending way, that is \( \sigma_i \geq
\sigma_{i+1} \).
</p>

<p>For small eigenvalues \( \sigma_i \) it means that their contributions become less important, a fact which can be used to reduce the number of degrees of freedom. More about this when we have covered the material on a statistical interpretation of various linear regression methods.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-interpretations">More interpretations </h2>

<p>For the sake of simplicity, let us assume that the design matrix is orthonormal, that is </p>

$$
\boldsymbol{X}^T\boldsymbol{X}=(\boldsymbol{X}^T\boldsymbol{X})^{-1} =\boldsymbol{I}. 
$$

<p>In this case the standard OLS results in </p>
$$
\boldsymbol{\beta}^{\mathrm{OLS}} = \boldsymbol{X}^T\boldsymbol{y}=\sum_{i=0}^{n-1}\boldsymbol{u}_i\boldsymbol{u}_i^T\boldsymbol{y},
$$

<p>and</p>

$$
\boldsymbol{\beta}^{\mathrm{Ridge}} = \left(\boldsymbol{I}+\lambda\boldsymbol{I}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}=\left(1+\lambda\right)^{-1}\boldsymbol{\beta}^{\mathrm{OLS}},
$$

<p>that is the Ridge estimator scales the OLS estimator by the inverse of a factor \( 1+\lambda \), and
the Ridge estimator converges to zero when the hyperparameter goes to
infinity.
</p>

<p>We will come back to more interpreations after we have gone through some of the statistical analysis part. </p>

<p>For more discussions of Ridge and Lasso regression, <a href="https://arxiv.org/abs/1509.09169" target="_blank">Wessel van Wieringen's</a> article is highly recommended.
Similarly, <a href="https://arxiv.org/abs/1803.08823" target="_blank">Mehta et al's article</a> is also recommended.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="deriving-the-lasso-regression-equations">Deriving the  Lasso Regression Equations </h2>

<p>Using the matrix-vector expression for Lasso regression, we have the following <b>cost</b> function</p>

$$
C(\boldsymbol{X},\boldsymbol{\beta})=\frac{1}{n}\left\{(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})\right\}+\lambda\vert\vert\boldsymbol{\beta}\vert\vert_1,
$$

<p>Taking the derivative with respect to \( \boldsymbol{\beta} \) and recalling that the derivative of the absolute value is (we drop the boldfaced vector symbol for simplicty)</p>
$$
\frac{d \vert \beta\vert}{d \beta}=\mathrm{sgn}(\beta)=\left\{\begin{array}{cc} 1 & \beta > 0 \\-1 & \beta < 0, \end{array}\right.
$$

<p>we have that the derivative of the cost function is</p>

$$
\frac{\partial C(\boldsymbol{X},\boldsymbol{\beta})}{\partial \boldsymbol{\beta}}=-\frac{2}{n}\boldsymbol{X}^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\beta})+\lambda sgn(\boldsymbol{\beta})=0,
$$

<p>and reordering we have</p>
$$
\boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\beta}+\frac{n}{2}\lambda sgn(\boldsymbol{\beta})=2\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>We can redefine \( \lambda \) to absorb the constant \( n/2 \) and we rewrite the last equation as</p>
$$
\boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\beta}+\lambda sgn(\boldsymbol{\beta})=2\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>This equation does not lead to a nice analytical equation as in either Ridge regression or ordinary least squares. This equation can however be solved by using standard convex optimization algorithms using for example the Python package <a href="https://cvxopt.org/" target="_blank">CVXOPT</a>. We will discuss this later. </p>

<!-- ------------------- end of main content --------------- -->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2024, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

