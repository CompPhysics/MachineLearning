
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>9. Decision trees, overarching aims &#8212; Applied Data Analysis and Machine Learning</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapter6';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Ensemble Methods: From a Single Tree to Many Trees and Extreme Boosting, Meet the Jungle of Methods" href="chapter7.html" />
    <link rel="prev" title="8. Support Vector Machines, overarching aims" href="chapter5.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="Applied Data Analysis and Machine Learning - Home"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="Applied Data Analysis and Machine Learning - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Applied Data Analysis and Machine Learning
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">About the course</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="schedule.html">Course setting</a></li>
<li class="toctree-l1"><a class="reference internal" href="teachers.html">Teachers and Grading</a></li>
<li class="toctree-l1"><a class="reference internal" href="textbooks.html">Textbooks</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Review of Statistics with Resampling Techniques and Linear Algebra</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="statistics.html">1. Elements of Probability Theory and Statistical Data Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">2. Linear Algebra, Handling of Arrays and more Python Features</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">From Regression to Support Vector Machines</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="chapter1.html">3. Linear Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter2.html">4. Ridge and Lasso Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter3.html">5. Resampling Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter4.html">6. Logistic Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapteroptimization.html">7. Optimization, the central part of any Machine Learning algortithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter5.html">8. Support Vector Machines, overarching aims</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Decision Trees, Ensemble Methods and Boosting</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">9. Decision trees, overarching aims</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter7.html">10. Ensemble Methods: From a Single Tree to Many Trees and Extreme Boosting, Meet the Jungle of Methods</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Dimensionality Reduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="chapter8.html">11. Basic ideas of the Principal Component Analysis (PCA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="clustering.html">12. Clustering and Unsupervised Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Deep Learning Methods</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="chapter9.html">13. Neural networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter10.html">14. Building a Feed Forward Neural Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter11.html">15. Solving Differential Equations  with Deep Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter12.html">16. Convolutional Neural Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter13.html">17. Recurrent neural networks: Overarching view</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Weekly material, notes and exercises</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="exercisesweek34.html">Exercises week 34</a></li>
<li class="toctree-l1"><a class="reference internal" href="week34.html">Week 34: Introduction to the course, Logistics and Practicalities</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercisesweek35.html">Exercises week 35</a></li>
<li class="toctree-l1"><a class="reference internal" href="week35.html">Week 35: From Ordinary Linear Regression to Ridge and Lasso Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercisesweek36.html">Exercises week 36</a></li>
<li class="toctree-l1"><a class="reference internal" href="week36.html">Week 36: Linear Regression and Gradient descent</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercisesweek37.html">Exercises week 37</a></li>
<li class="toctree-l1"><a class="reference internal" href="week37.html">Week 37: Gradient descent methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercisesweek38.html">Exercises week 38</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercisesweek39.html">Exercises week 39</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Projects</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="project1.html">Project 1 on Machine Learning, deadline October 6 (midnight), 2025</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/chapter6.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Decision trees, overarching aims</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basics-of-a-tree">9.1. Basics of a tree</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#general-features">9.2. General Features</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#building-a-tree-regression">9.3. Building a tree, regression</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-a-tree">9.3.1. Making a tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schematic-regression-procedure">9.3.2. Schematic Regression Procedure</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-classification-tree">9.4. A Classification Tree</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizing-the-tree-classification">9.4.1. Visualizing the Tree, Classification</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#other-ways-of-visualizing-the-trees">9.4.2. Other ways of visualizing the trees</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms-for-setting-up-decision-trees">9.5. Algorithms for Setting up Decision Trees</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-cart-algorithm-for-classification">9.5.1. The CART algorithm for Classification</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-cart-algorithm-for-regression">9.5.2. The CART algorithm for Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-the-gini-index">9.5.3. Computing the Gini index</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simple-python-code-to-read-in-data-and-perform-classification">9.5.4. Simple Python Code to read in Data and perform Classification</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-and-the-id3-algorithm">9.6. Entropy and the ID3 algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cancer-data-again-now-with-decision-trees-and-other-methods">9.6.1. Cancer Data again now with Decision Trees and other Methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#another-example-the-moons-again">9.6.2. Another example, the moons again</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pros-and-cons-of-trees-pros">9.7. Pros and cons of trees, pros</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#disadvantages">9.7.1. Disadvantages</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="decision-trees-overarching-aims">
<h1><span class="section-number">9. </span>Decision trees, overarching aims<a class="headerlink" href="#decision-trees-overarching-aims" title="Link to this heading">#</a></h1>
<p>We start here with the most basic algorithm, the so-called decision
tree. With this basic algorithm we can in turn build more complex
networks, spanning from homogeneous and heterogenous forests (bagging,
random forests and more) to one of the most popular supervised
algorithms nowadays, the extreme gradient boosting, or just
XGBoost. But let us start with the simplest possible ingredient.</p>
<p>Decision trees are supervised learning algorithms used for both,
classification and regression tasks.</p>
<p>The main idea of decision trees
is to find those descriptive features which contain the most
<strong>information</strong> regarding the target feature and then split the dataset
along the values of these features such that the target feature values
for the resulting underlying datasets are as pure as possible.</p>
<p>The descriptive features which reproduce best the target/output features are normally  said
to be the most informative ones. The process of finding the <strong>most
informative</strong> feature is done until we accomplish a stopping criteria
where we then finally end up in so called <strong>leaf nodes</strong>.</p>
<section id="basics-of-a-tree">
<h2><span class="section-number">9.1. </span>Basics of a tree<a class="headerlink" href="#basics-of-a-tree" title="Link to this heading">#</a></h2>
<p>A decision tree is typically divided into a <strong>root node</strong>, the <strong>interior nodes</strong>,
and the final <strong>leaf nodes</strong> or just <strong>leaves</strong>. These entities are then connected by so-called <strong>branches</strong>.</p>
<p>The leaf nodes
contain the predictions we will make for new query instances presented
to our trained model. This is possible since the model has
learned the underlying structure of the training data and hence can,
given some assumptions, make predictions about the target feature value
(class) of unseen query instances.</p>
</section>
<section id="general-features">
<h2><span class="section-number">9.2. </span>General Features<a class="headerlink" href="#general-features" title="Link to this heading">#</a></h2>
<p>The overarching approach to decision trees is a top-down approach.</p>
<ul class="simple">
<li><p>A leaf provides the classification of a given instance.</p></li>
<li><p>A node specifies a test of some attribute of the instance.</p></li>
<li><p>A branch corresponds to a possible values of an attribute.</p></li>
<li><p>An instance is classified by starting at the root node of the tree, testing the attribute specified by this node, then moving down the tree branch corresponding to the value of the attribute in the given example.</p></li>
</ul>
<p>This process is then repeated for the subtree rooted at the new
node.</p>
<p>In simplified terms, the process of training a decision tree and
predicting the target features of query instances is as follows:</p>
<ol class="arabic simple">
<li><p>Present a dataset containing of a number of training instances characterized by a number of descriptive features and a target feature</p></li>
<li><p>Train the decision tree model by continuously splitting the target feature along the values of the descriptive features using a measure of information gain during the training process</p></li>
<li><p>Grow the tree until we accomplish a stopping criteria create leaf nodes which represent the <em>predictions</em> we want to make for new query instances</p></li>
<li><p>Show query instances to the tree and run down the tree until we arrive at leaf nodes</p></li>
</ol>
<p>Then we are essentially done!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%matplotlib inline

import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

steps=250

distance=0
x=0
distance_list=[]
steps_list=[]
while x&lt;steps:
    distance+=np.random.randint(-1,2)
    distance_list.append(distance)
    x+=1
    steps_list.append(x)
plt.plot(steps_list,distance_list, color=&#39;green&#39;, label=&quot;Random Walk Data&quot;)

steps_list=np.asarray(steps_list)
distance_list=np.asarray(distance_list)

X=steps_list[:,np.newaxis]

#Polynomial fits

#Degree 2
poly_features=PolynomialFeatures(degree=2, include_bias=False)
X_poly=poly_features.fit_transform(X)

lin_reg=LinearRegression()
poly_fit=lin_reg.fit(X_poly,distance_list)
b=lin_reg.coef_
c=lin_reg.intercept_
print (&quot;2nd degree coefficients:&quot;)
print (&quot;zero power: &quot;,c)
print (&quot;first power: &quot;, b[0])
print (&quot;second power: &quot;,b[1])

z = np.arange(0, steps, .01)
z_mod=b[1]*z**2+b[0]*z+c

fit_mod=b[1]*X**2+b[0]*X+c
plt.plot(z, z_mod, color=&#39;r&#39;, label=&quot;2nd Degree Fit&quot;)
plt.title(&quot;Polynomial Regression&quot;)

plt.xlabel(&quot;Steps&quot;)
plt.ylabel(&quot;Distance&quot;)

#Degree 10
poly_features10=PolynomialFeatures(degree=10, include_bias=False)
X_poly10=poly_features10.fit_transform(X)

poly_fit10=lin_reg.fit(X_poly10,distance_list)

y_plot=poly_fit10.predict(X_poly10)
plt.plot(X, y_plot, color=&#39;black&#39;, label=&quot;10th Degree Fit&quot;)

plt.legend()
plt.show()


#Decision Tree Regression
from sklearn.tree import DecisionTreeRegressor
regr_1=DecisionTreeRegressor(max_depth=2)
regr_2=DecisionTreeRegressor(max_depth=5)
regr_3=DecisionTreeRegressor(max_depth=7)
regr_1.fit(X, distance_list)
regr_2.fit(X, distance_list)
regr_3.fit(X, distance_list)

X_test = np.arange(0.0, steps, 0.01)[:, np.newaxis]
y_1 = regr_1.predict(X_test)
y_2 = regr_2.predict(X_test)
y_3=regr_3.predict(X_test)

# Plot the results
plt.figure()
plt.scatter(X, distance_list, s=2.5, c=&quot;black&quot;, label=&quot;data&quot;)
plt.plot(X_test, y_1, color=&quot;red&quot;,
         label=&quot;max_depth=2&quot;, linewidth=2)
plt.plot(X_test, y_2, color=&quot;green&quot;, label=&quot;max_depth=5&quot;, linewidth=2)
plt.plot(X_test, y_3, color=&quot;m&quot;, label=&quot;max_depth=7&quot;, linewidth=2)

plt.xlabel(&quot;Data&quot;)
plt.ylabel(&quot;Darget&quot;)
plt.title(&quot;Decision Tree Regression&quot;)
plt.legend()
plt.show()
</pre></div>
</div>
</div>
</div>
</section>
<section id="building-a-tree-regression">
<h2><span class="section-number">9.3. </span>Building a tree, regression<a class="headerlink" href="#building-a-tree-regression" title="Link to this heading">#</a></h2>
<p>There are mainly two steps</p>
<ol class="arabic simple">
<li><p>We split the predictor space (the set of possible values <span class="math notranslate nohighlight">\(x_1,x_2,\dots, x_p\)</span>) into <span class="math notranslate nohighlight">\(J\)</span> distinct and non-non-overlapping regions, <span class="math notranslate nohighlight">\(R_1,R_2,\dots,R_J\)</span>.</p></li>
<li><p>For every observation that falls into the region <span class="math notranslate nohighlight">\(R_j\)</span> , we make the same prediction, which is simply the mean of the response values for the training observations in <span class="math notranslate nohighlight">\(R_j\)</span>.</p></li>
</ol>
<p>How do we construct the regions <span class="math notranslate nohighlight">\(R_1,\dots,R_J\)</span>?  In theory, the
regions could have any shape. However, we choose to divide the
predictor space into high-dimensional rectangles, or boxes, for
simplicity and for ease of interpretation of the resulting predictive
model. The goal is to find boxes <span class="math notranslate nohighlight">\(R_1,\dots,R_J\)</span> that minimize the
MSE, given by</p>
<div class="math notranslate nohighlight">
\[
\sum_{j=1}^J\sum_{i\in R_j}(y_i-\overline{y}_{R_j})^2,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\overline{y}_{R_j}\)</span>  is the mean response for the training observations
within box <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>Unfortunately, it is computationally infeasible to consider every
possible partition of the feature space into <span class="math notranslate nohighlight">\(J\)</span> boxes.  The common
strategy is to take a top-down approach</p>
<p>The approach is top-down because it begins at the top of the tree (all
observations belong to a single region) and then successively splits
the predictor space; each split is indicated via two new branches
further down on the tree. It is greedy because at each step of the
tree-building process, the best split is made at that particular step,
rather than looking ahead and picking a split that will lead to a
better tree in some future step.</p>
<section id="making-a-tree">
<h3><span class="section-number">9.3.1. </span>Making a tree<a class="headerlink" href="#making-a-tree" title="Link to this heading">#</a></h3>
<p>In order to implement the recursive binary splitting we start by selecting
the predictor <span class="math notranslate nohighlight">\(x_j\)</span> and a cutpoint <span class="math notranslate nohighlight">\(s\)</span> that splits the predictor space into two regions <span class="math notranslate nohighlight">\(R_1\)</span> and <span class="math notranslate nohighlight">\(R_2\)</span></p>
<div class="math notranslate nohighlight">
\[
\left\{X\vert x_j &lt; s\right\},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\left\{X\vert x_j \geq s\right\},
\]</div>
<p>so that we obtain the lowest MSE, that is</p>
<div class="math notranslate nohighlight">
\[
\sum_{i:x_i\in R_j}(y_i-\overline{y}_{R_1})^2+\sum_{i:x_i\in R_2}(y_i-\overline{y}_{R_2})^2,
\]</div>
<p>which we want to minimize by considering all predictors
<span class="math notranslate nohighlight">\(x_1,x_2,\dots,x_p\)</span>.  We consider also all possible values of <span class="math notranslate nohighlight">\(s\)</span> for
each predictor. These values could be determined by randomly assigned
numbers or by starting at the midpoint and then proceed till we find
an optimal value.</p>
<p>For any <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(s\)</span>, we define the pair of half-planes where
<span class="math notranslate nohighlight">\(\overline{y}_{R_1}\)</span> is the mean response for the training
observations in <span class="math notranslate nohighlight">\(R_1(j,s)\)</span>, and <span class="math notranslate nohighlight">\(\overline{y}_{R_2}\)</span> is the mean
response for the training observations in <span class="math notranslate nohighlight">\(R_2(j,s)\)</span>.</p>
<p>Finding the values of <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(s\)</span> that minimize the above equation can be
done quite quickly, especially when the number of features <span class="math notranslate nohighlight">\(p\)</span> is not
too large.</p>
<p>Next, we repeat the process, looking
for the best predictor and best cutpoint in order to split the data
further so as to minimize the MSE within each of the resulting
regions. However, this time, instead of splitting the entire predictor
space, we split one of the two previously identified regions. We now
have three regions. Again, we look to split one of these three regions
further, so as to minimize the MSE. The process continues until a
stopping criterion is reached; for instance, we may continue until no
region contains more than five observations.</p>
<p>The above procedure is rather straightforward, but leads often to
overfitting and unnecessarily large and complicated trees. The basic
idea is to grow a large tree <span class="math notranslate nohighlight">\(T_0\)</span> and then prune it back in order to
obtain a subtree. A smaller tree with fewer splits (fewer regions) can
lead to smaller variance and better interpretation at the cost of a
little more bias.</p>
<p>The so-called Cost complexity pruning algorithm gives us a
way to do just this. Rather than considering every possible subtree,
we consider a sequence of trees indexed by a nonnegative tuning
parameter <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>Read more at the following <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/tree/plot_cost_complexity_pruning.html#sphx-glr-auto-examples-tree-plot-cost-complexity-pruning-py">Scikit-Learn link on pruning</a>.</p>
<p>For each value of <span class="math notranslate nohighlight">\(\alpha\)</span>  there corresponds a subtree <span class="math notranslate nohighlight">\(T \in T_0\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
\sum_{m=1}^{\overline{T}}\sum_{i:x_i\in R_m}(y_i-\overline{y}_{R_m})^2+\alpha\overline{T},
\]</div>
<p>is as small as possible. Here <span class="math notranslate nohighlight">\(\overline{T}\)</span> is
the number of terminal nodes of the tree <span class="math notranslate nohighlight">\(T\)</span> , <span class="math notranslate nohighlight">\(R_m\)</span> is the
rectangle (i.e. the subset of predictor space)  corresponding to the <span class="math notranslate nohighlight">\(m\)</span>-th terminal node.</p>
<p>The tuning parameter <span class="math notranslate nohighlight">\(\alpha\)</span> controls a trade-off between the subtree’s
complexity and its fit to the training data. When <span class="math notranslate nohighlight">\(\alpha = 0\)</span>, then the
subtree <span class="math notranslate nohighlight">\(T\)</span> will simply equal <span class="math notranslate nohighlight">\(T_0\)</span>,
because then the above equation just measures the
training error.
However, as <span class="math notranslate nohighlight">\(\alpha\)</span> increases, there is a price to pay for
having a tree with many terminal nodes. The above equation will
tend to be minimized for a smaller subtree.</p>
<p>It turns out that as we increase <span class="math notranslate nohighlight">\(\alpha\)</span> from zero
branches get pruned from the tree in a nested and predictable fashion,
so obtaining the whole sequence of subtrees as a function of <span class="math notranslate nohighlight">\(\alpha\)</span> is
easy. We can select a value of <span class="math notranslate nohighlight">\(\alpha\)</span> using a validation set or using
cross-validation. We then return to the full data set and obtain the
subtree corresponding to <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
</section>
<section id="schematic-regression-procedure">
<h3><span class="section-number">9.3.2. </span>Schematic Regression Procedure<a class="headerlink" href="#schematic-regression-procedure" title="Link to this heading">#</a></h3>
<p>Building a Regression Tree</p>
<ol class="arabic simple">
<li><p>Use recursive binary splitting to grow a large tree on the training data, stopping only when each terminal node has fewer than some minimum number of observations.</p></li>
<li><p>Apply cost complexity pruning to the large tree in order to obtain a sequence of best subtrees, as a function of <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p>Use for example <span class="math notranslate nohighlight">\(K\)</span>-fold cross-validation to choose <span class="math notranslate nohighlight">\(\alpha\)</span>. Divide the training observations into <span class="math notranslate nohighlight">\(K\)</span> folds. For each <span class="math notranslate nohighlight">\(k=1,2,\dots,K\)</span> we:</p></li>
</ol>
<ul class="simple">
<li><p>repeat steps 1 and 2 on all but the <span class="math notranslate nohighlight">\(k\)</span>-th fold of the training data.</p></li>
<li><p>Then we valuate the mean squared prediction error on the data in the left-out <span class="math notranslate nohighlight">\(k\)</span>-th fold, as a function of <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p>Finally  we average the results for each value of <span class="math notranslate nohighlight">\(\alpha\)</span>, and pick <span class="math notranslate nohighlight">\(\alpha\)</span> to minimize the average error.</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>Return the subtree from Step 2 that corresponds to the chosen value of <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
</ol>
<p>!eblock</p>
</section>
</section>
<section id="a-classification-tree">
<h2><span class="section-number">9.4. </span>A Classification Tree<a class="headerlink" href="#a-classification-tree" title="Link to this heading">#</a></h2>
<p>A classification tree is very similar to a regression tree, except
that it is used to predict a qualitative response rather than a
quantitative one. Recall that for a regression tree, the predicted
response for an observation is given by the mean response of the
training observations that belong to the same terminal node. In
contrast, for a classification tree, we predict that each observation
belongs to the most commonly occurring class of training observations
in the region to which it belongs. In interpreting the results of a
classification tree, we are often interested not only in the class
prediction corresponding to a particular terminal node region, but
also in the class proportions among the training observations that
fall into that region.</p>
<p>The task of growing a
classification tree is quite similar to the task of growing a
regression tree. Just as in the regression setting, we use recursive
binary splitting to grow a classification tree. However, in the
classification setting, the MSE cannot be used as a criterion for making
the binary splits.  A natural alternative to MSE is the <strong>classification
error rate</strong>. Since we plan to assign an observation in a given region
to the most commonly occurring error rate class of training
observations in that region, the classification error rate is simply
the fraction of the training observations in that region that do not
belong to the most common class.</p>
<p>When building a classification tree, either the Gini index or the
entropy are typically used to evaluate the quality of a particular
split, since these two approaches are more sensitive to node purity
than is the classification error rate.</p>
<p>If our targets are the outcome of a classification process that takes
for example <span class="math notranslate nohighlight">\(k=1,2,\dots,K\)</span> values, the only thing we need to think of
is to set up the splitting criteria for each node.</p>
<p>We define a PDF <span class="math notranslate nohighlight">\(p_{mk}\)</span> that represents the number of observations of
a class <span class="math notranslate nohighlight">\(k\)</span> in a region <span class="math notranslate nohighlight">\(R_m\)</span> with <span class="math notranslate nohighlight">\(N_m\)</span> observations. We represent
this likelihood function in terms of the proportion <span class="math notranslate nohighlight">\(I(y_i=k)\)</span> of
observations of this class in the region <span class="math notranslate nohighlight">\(R_m\)</span> as</p>
<div class="math notranslate nohighlight">
\[
p_{mk} = \frac{1}{N_m}\sum_{x_i\in R_m}I(y_i=k).
\]</div>
<p>We let <span class="math notranslate nohighlight">\(p_{mk}\)</span> represent the majority class of observations in region
<span class="math notranslate nohighlight">\(m\)</span>. The three most common ways of splitting a node are given by</p>
<ul class="simple">
<li><p>Misclassification error</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
p_{mk} = \frac{1}{N_m}\sum_{x_i\in R_m}I(y_i\ne k) = 1-p_{mk}.
\]</div>
<ul class="simple">
<li><p>Gini index <span class="math notranslate nohighlight">\(g\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[
g = \sum_{k=1}^K p_{mk}(1-p_{mk}).
\]</div>
<ul class="simple">
<li><p>Information entropy or just entropy <span class="math notranslate nohighlight">\(s\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[
s = -\sum_{k=1}^K p_{mk}\log{p_{mk}}.
\]</div>
<section id="visualizing-the-tree-classification">
<h3><span class="section-number">9.4.1. </span>Visualizing the Tree, Classification<a class="headerlink" href="#visualizing-the-tree-classification" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import os
from sklearn.datasets import load_breast_cancer
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.tree import export_graphviz

from IPython.display import Image 
from pydot import graph_from_dot_data
import pandas as pd
import numpy as np


cancer = load_breast_cancer()
X = pd.DataFrame(cancer.data, columns=cancer.feature_names)
print(X)
y = pd.Categorical.from_codes(cancer.target, cancer.target_names)
y = pd.get_dummies(y)
print(y)
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1)
tree_clf = DecisionTreeClassifier(max_depth=5)
tree_clf.fit(X_train, y_train)

export_graphviz(
    tree_clf,
    out_file=&quot;DataFiles/cancer.dot&quot;,
    feature_names=cancer.feature_names,
    class_names=cancer.target_names,
    rounded=True,
    filled=True
)
cmd = &#39;dot -Tpng DataFiles/cancer.dot -o DataFiles/cancer.png&#39;
os.system(cmd)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Common imports
import numpy as np
from sklearn.model_selection import  train_test_split 
from sklearn.tree import DecisionTreeClassifier
from sklearn.datasets import make_moons
from sklearn.tree import export_graphviz
from pydot import graph_from_dot_data
import pandas as pd
import os

np.random.seed(42)
X, y = make_moons(n_samples=100, noise=0.25, random_state=53)
X_train, X_test, y_train, y_test = train_test_split(X,y,random_state=0)
tree_clf = DecisionTreeClassifier(max_depth=5)
tree_clf.fit(X_train, y_train)

export_graphviz(
    tree_clf,
    out_file=&quot;DataFiles/moons.dot&quot;,
    rounded=True,
    filled=True
)
cmd = &#39;dot -Tpng DataFiles/moons.dot -o DataFiles/moons.png&#39;
os.system(cmd)
</pre></div>
</div>
</div>
</div>
</section>
<section id="other-ways-of-visualizing-the-trees">
<h3><span class="section-number">9.4.2. </span>Other ways of visualizing the trees<a class="headerlink" href="#other-ways-of-visualizing-the-trees" title="Link to this heading">#</a></h3>
<p><strong>Scikit-Learn</strong> has also another way to visualize the trees which is very useful, here with the Iris data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from sklearn.datasets import load_iris
from sklearn import tree
X, y = load_iris(return_X_y=True)
tree_clf = tree.DecisionTreeClassifier()
tree_clf = tree_clf.fit(X, y)
# and then plot the tree
tree.plot_tree(tree_clf)
</pre></div>
</div>
</div>
</div>
<p>Alternatively, the tree can also be exported in textual format with the function exporttext.
This method doesn’t require the installation of external libraries and is more compact:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import export_text
iris = load_iris()
decision_tree = DecisionTreeClassifier(random_state=0, max_depth=2)
decision_tree = decision_tree.fit(iris.data, iris.target)
r = export_text(decision_tree, feature_names=iris[&#39;feature_names&#39;])
print(r)
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="algorithms-for-setting-up-decision-trees">
<h2><span class="section-number">9.5. </span>Algorithms for Setting up Decision Trees<a class="headerlink" href="#algorithms-for-setting-up-decision-trees" title="Link to this heading">#</a></h2>
<p>Two algorithms stand out in the set up of decision trees:</p>
<ol class="arabic simple">
<li><p>The CART (Classification And Regression Tree) algorithm for both classification and regression</p></li>
<li><p>The ID3 algorithm based on the computation of the information gain for classification</p></li>
</ol>
<p>We discuss both algorithms with applications here. The popular library
<strong>Scikit-Learn</strong> uses the CART algorithm. For classification problems
you can use either the <strong>gini</strong> index or the <strong>entropy</strong> to split a tree
in two branches.</p>
<section id="the-cart-algorithm-for-classification">
<h3><span class="section-number">9.5.1. </span>The CART algorithm for Classification<a class="headerlink" href="#the-cart-algorithm-for-classification" title="Link to this heading">#</a></h3>
<p>For classification, the CART algorithm splits the data set in two subsets using a single feature <span class="math notranslate nohighlight">\(k\)</span> and a threshold <span class="math notranslate nohighlight">\(t_k\)</span>.
This could be for example a threshold set by a number below a certain circumference of a malign tumor.</p>
<p>How do we find these two quantities?
We search for the pair <span class="math notranslate nohighlight">\((k,t_k)\)</span> that produces the purest subset using for example the <strong>gini</strong> factor <span class="math notranslate nohighlight">\(G\)</span>.
The cost function it tries to minimize is then</p>
<div class="math notranslate nohighlight">
\[
C(k,t_k) = \frac{m_{\mathrm{left}}}{m}G_{\mathrm{left}}+ \frac{m_{\mathrm{right}}}{m}G_{\mathrm{right}},
\]</div>
<p>where <span class="math notranslate nohighlight">\(G_{\mathrm{left/right}}\)</span> measures the impurity of the left/right subset  and <span class="math notranslate nohighlight">\(m_{\mathrm{left/right}}\)</span>
is the number of instances in the left/right subset</p>
<p>Once it has successfully split the training set in two, it splits the subsets using the same logic, then the subsubsets
and so on, recursively. It stops recursing once it reaches the maximum depth (defined by the
<span class="math notranslate nohighlight">\(max\_depth\)</span> hyperparameter), or if it cannot find a split that will reduce impurity. A few other
hyperparameters control additional stopping conditions such as the <span class="math notranslate nohighlight">\(min\_samples\_split\)</span>,
<span class="math notranslate nohighlight">\(min\_samples\_leaf\)</span>, <span class="math notranslate nohighlight">\(min\_weight\_fraction\_leaf\)</span>, and <span class="math notranslate nohighlight">\(max\_leaf\_nodes\)</span>.</p>
</section>
<section id="the-cart-algorithm-for-regression">
<h3><span class="section-number">9.5.2. </span>The CART algorithm for Regression<a class="headerlink" href="#the-cart-algorithm-for-regression" title="Link to this heading">#</a></h3>
<p>The CART algorithm for regression works is similar to the one for classification except that instead of trying to split the
training set in a way that minimizes say the <strong>gini</strong> or <strong>entropy</strong> impurity, it now tries to split the training set in a way that minimizes our well-known mean-squared error (MSE). The cost function is now</p>
<div class="math notranslate nohighlight">
\[
C(k,t_k) = \frac{m_{\mathrm{left}}}{m}\mathrm{MSE}_{\mathrm{left}}+ \frac{m_{\mathrm{right}}}{m}\mathrm{MSE}_{\mathrm{right}}.
\]</div>
<p>Here the MSE for a specific node is defined as</p>
<div class="math notranslate nohighlight">
\[
\mathrm{MSE}_{\mathrm{node}}=\frac{1}{m_\mathrm{node}}\sum_{i\in \mathrm{node}}(\overline{y}_{\mathrm{node}}-y_i)^2,
\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[
\overline{y}_{\mathrm{node}}=\frac{1}{m_\mathrm{node}}\sum_{i\in \mathrm{node}}y_i,
\]</div>
<p>the mean value of all observations in a specific node.</p>
<p>Without any regularization, the regression task for decision trees,
just like for classification tasks, is  prone to overfitting.</p>
</section>
<section id="computing-the-gini-index">
<h3><span class="section-number">9.5.3. </span>Computing the Gini index<a class="headerlink" href="#computing-the-gini-index" title="Link to this heading">#</a></h3>
<p>The example we will look at is a classical one in many Machine
Learning applications. Based on various meteorological features, we
have several so-called attributes which decide whether we at the end
will do some outdoor activity like skiing, going for a bike ride etc
etc.  The table here contains the feautures <strong>outlook</strong>, <strong>temperature</strong>,
<strong>humidity</strong> and <strong>wind</strong>.  The target or output is whether we ride
(True=1) or whether we do something else that day (False=0). The
attributes for each feature are then sunny, overcast and rain for the
outlook, hot, cold and mild for temperature, high and normal for
humidity and weak and strong for wind.</p>
<p>The table here summarizes the various attributes and</p>
<table border="1">
<thead>
<tr><th align="center">Day</th> <th align="center">Outlook </th> <th align="center">Temperature</th> <th align="center">Humidity</th> <th align="center"> Wind </th> <th align="center">Ride</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1      </td> <td align="center">   Sunny       </td> <td align="center">   Hot            </td> <td align="center">   High        </td> <td align="center">   Weak      </td> <td align="center">   0       </td> </tr>
<tr><td align="center">   2      </td> <td align="center">   Sunny       </td> <td align="center">   Hot            </td> <td align="center">   High        </td> <td align="center">   Strong    </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   3      </td> <td align="center">   Overcast    </td> <td align="center">   Hot            </td> <td align="center">   High        </td> <td align="center">   Weak      </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   4      </td> <td align="center">   Rain        </td> <td align="center">   Mild           </td> <td align="center">   High        </td> <td align="center">   Weak      </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   5      </td> <td align="center">   Rain        </td> <td align="center">   Cool           </td> <td align="center">   Normal      </td> <td align="center">   Weak      </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   6      </td> <td align="center">   Rain        </td> <td align="center">   Cool           </td> <td align="center">   Normal      </td> <td align="center">   Strong    </td> <td align="center">   0       </td> </tr>
<tr><td align="center">   7      </td> <td align="center">   Overcast    </td> <td align="center">   Cool           </td> <td align="center">   Normal      </td> <td align="center">   Strong    </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   8      </td> <td align="center">   Sunny       </td> <td align="center">   Mild           </td> <td align="center">   High        </td> <td align="center">   Weak      </td> <td align="center">   0       </td> </tr>
<tr><td align="center">   9      </td> <td align="center">   Sunny       </td> <td align="center">   Cool           </td> <td align="center">   Normal      </td> <td align="center">   Weak      </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   10     </td> <td align="center">   Rain        </td> <td align="center">   Mild           </td> <td align="center">   Normal      </td> <td align="center">   Weak      </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   11     </td> <td align="center">   Sunny       </td> <td align="center">   Mild           </td> <td align="center">   Normal      </td> <td align="center">   Strong    </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   12     </td> <td align="center">   Overcast    </td> <td align="center">   Mild           </td> <td align="center">   High        </td> <td align="center">   Strong    </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   13     </td> <td align="center">   Overcast    </td> <td align="center">   Hot            </td> <td align="center">   Normal      </td> <td align="center">   Weak      </td> <td align="center">   1       </td> </tr>
<tr><td align="center">   14     </td> <td align="center">   Rain        </td> <td align="center">   Mild           </td> <td align="center">   High        </td> <td align="center">   Strong    </td> <td align="center">   0       </td> </tr>
</tbody>
</table>
</section>
<section id="simple-python-code-to-read-in-data-and-perform-classification">
<h3><span class="section-number">9.5.4. </span>Simple Python Code to read in Data and perform Classification<a class="headerlink" href="#simple-python-code-to-read-in-data-and-perform-classification" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Common imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.tree import export_graphviz
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from IPython.display import Image 
from pydot import graph_from_dot_data
import os

# Where to save the figures and data files
PROJECT_ROOT_DIR = &quot;Results&quot;
FIGURE_ID = &quot;Results/FigureFiles&quot;
DATA_ID = &quot;DataFiles/&quot;

if not os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

if not os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

if not os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

def image_path(fig_id):
    return os.path.join(FIGURE_ID, fig_id)

def data_path(dat_id):
    return os.path.join(DATA_ID, dat_id)

def save_fig(fig_id):
    plt.savefig(image_path(fig_id) + &quot;.png&quot;, format=&#39;png&#39;)

infile = open(data_path(&quot;rideclass.csv&quot;),&#39;r&#39;)

# Read the experimental data with Pandas
from IPython.display import display
ridedata = pd.read_csv(infile,names = (&#39;Outlook&#39;,&#39;Temperature&#39;,&#39;Humidity&#39;,&#39;Wind&#39;,&#39;Ride&#39;))
ridedata = pd.DataFrame(ridedata)

# Features and targets
X = ridedata.loc[:, ridedata.columns != &#39;Ride&#39;].values
y = ridedata.loc[:, ridedata.columns == &#39;Ride&#39;].values

# Create the encoder.
encoder = OneHotEncoder(handle_unknown=&quot;ignore&quot;)
# Assume for simplicity all features are categorical.
encoder.fit(X)    
# Apply the encoder.
X = encoder.transform(X)
print(X)
# Then do a Classification tree
tree_clf = DecisionTreeClassifier(max_depth=2)
tree_clf.fit(X, y)
print(&quot;Train set accuracy with Decision Tree: {:.2f}&quot;.format(tree_clf.score(X,y)))
#transfer to a decision tree graph
export_graphviz(
    tree_clf,
    out_file=&quot;DataFiles/ride.dot&quot;,
    rounded=True,
    filled=True
)
cmd = &#39;dot -Tpng DataFiles/cancer.dot -o DataFiles/cancer.png&#39;
os.system(cmd)
</pre></div>
</div>
</div>
</div>
<p>The above functions (gini, entropy and misclassification error) are
important components of the so-called CART algorithm. We will discuss
this algorithm below after we have discussed the information gain
algorithm ID3.</p>
<p>In the example here we have converted all our attributes into numerical values <span class="math notranslate nohighlight">\(0,1,2\)</span> etc.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Split a dataset based on an attribute and an attribute value
def test_split(index, value, dataset):
	left, right = list(), list()
	for row in dataset:
		if row[index] &lt; value:
			left.append(row)
		else:
			right.append(row)
	return left, right
 
# Calculate the Gini index for a split dataset
def gini_index(groups, classes):
	# count all samples at split point
	n_instances = float(sum([len(group) for group in groups]))
	# sum weighted Gini index for each group
	gini = 0.0
	for group in groups:
		size = float(len(group))
		# avoid divide by zero
		if size == 0:
			continue
		score = 0.0
		# score the group based on the score for each class
		for class_val in classes:
			p = [row[-1] for row in group].count(class_val) / size
			score += p * p
		# weight the group score by its relative size
		gini += (1.0 - score) * (size / n_instances)
	return gini

# Select the best split point for a dataset
def get_split(dataset):
	class_values = list(set(row[-1] for row in dataset))
	b_index, b_value, b_score, b_groups = 999, 999, 999, None
	for index in range(len(dataset[0])-1):
		for row in dataset:
			groups = test_split(index, row[index], dataset)
			gini = gini_index(groups, class_values)
			print(&#39;X%d &lt; %.3f Gini=%.3f&#39; % ((index+1), row[index], gini))
			if gini &lt; b_score:
				b_index, b_value, b_score, b_groups = index, row[index], gini, groups
	return {&#39;index&#39;:b_index, &#39;value&#39;:b_value, &#39;groups&#39;:b_groups}
 
dataset = [[0,0,0,0,0],
            [0,0,0,1,1],
            [1,0,0,0,1],
            [2,1,0,0,1],
            [2,2,1,0,1],
            [2,2,1,1,0],
            [1,2,1,1,1],
            [0,1,0,0,0],
            [0,2,1,0,1],
            [2,1,1,0,1],
            [0,1,1,1,1],
            [1,1,0,1,1],
            [1,0,1,0,1],
            [2,1,0,1,0]]

split = get_split(dataset)
print(&#39;Split: [X%d &lt; %.3f]&#39; % ((split[&#39;index&#39;]+1), split[&#39;value&#39;]))
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="entropy-and-the-id3-algorithm">
<h2><span class="section-number">9.6. </span>Entropy and the ID3 algorithm<a class="headerlink" href="#entropy-and-the-id3-algorithm" title="Link to this heading">#</a></h2>
<p>The ID3 algorithm  learns decision trees by constructing
them in a top down way, beginning with the question <strong>which attribute should be tested at the root of the tree</strong>?</p>
<ol class="arabic simple">
<li><p>Each instance attribute is evaluated using a statistical test to determine how well it alone classifies the training examples.</p></li>
<li><p>The best attribute is selected and used as the test at the root node of the tree.</p></li>
<li><p>A descendant of the root node is then created for each possible value of this attribute.</p></li>
<li><p>Training examples are sorted to the appropriate descendant node.</p></li>
<li><p>The entire process is then repeated using the training examples associated with each descendant node to select the best attribute to test at that point in the tree.</p></li>
<li><p>This forms a greedy search for an acceptable decision tree, in which the algorithm never backtracks to reconsider earlier choices.</p></li>
</ol>
<p>The ID3 algorithm selects which attribute to test at each node in the
tree.</p>
<p>We would like to select the attribute that is most useful for classifying
examples.</p>
<p>What is a good quantitative measure of the worth of an attribute?</p>
<p>Information gain measures how well a given attribute separates the
training examples according to their target classification.</p>
<p>The ID3 algorithm uses this information gain measure to select among the candidate
attributes at each step while growing the tree.</p>
<section id="cancer-data-again-now-with-decision-trees-and-other-methods">
<h3><span class="section-number">9.6.1. </span>Cancer Data again now with Decision Trees and other Methods<a class="headerlink" href="#cancer-data-again-now-with-decision-trees-and-other-methods" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import  train_test_split 
from sklearn.datasets import load_breast_cancer
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier

# Load the data
cancer = load_breast_cancer()

X_train, X_test, y_train, y_test = train_test_split(cancer.data,cancer.target,random_state=0)
print(X_train.shape)
print(X_test.shape)
# Logistic Regression
logreg = LogisticRegression(solver=&#39;lbfgs&#39;)
logreg.fit(X_train, y_train)
print(&quot;Test set accuracy with Logistic Regression: {:.2f}&quot;.format(logreg.score(X_test,y_test)))
# Support vector machine
svm = SVC(gamma=&#39;auto&#39;, C=100)
svm.fit(X_train, y_train)
print(&quot;Test set accuracy with SVM: {:.2f}&quot;.format(svm.score(X_test,y_test)))
# Decision Trees
deep_tree_clf = DecisionTreeClassifier(max_depth=None)
deep_tree_clf.fit(X_train, y_train)
print(&quot;Test set accuracy with Decision Trees: {:.2f}&quot;.format(deep_tree_clf.score(X_test,y_test)))
#now scale the data
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaler.fit(X_train)
X_train_scaled = scaler.transform(X_train)
X_test_scaled = scaler.transform(X_test)
# Logistic Regression
logreg.fit(X_train_scaled, y_train)
print(&quot;Test set accuracy Logistic Regression with scaled data: {:.2f}&quot;.format(logreg.score(X_test_scaled,y_test)))
# Support Vector Machine
svm.fit(X_train_scaled, y_train)
print(&quot;Test set accuracy SVM with scaled data: {:.2f}&quot;.format(logreg.score(X_test_scaled,y_test)))
# Decision Trees
deep_tree_clf.fit(X_train_scaled, y_train)
print(&quot;Test set accuracy with Decision Trees and scaled data: {:.2f}&quot;.format(deep_tree_clf.score(X_test_scaled,y_test)))
</pre></div>
</div>
</div>
</div>
</section>
<section id="another-example-the-moons-again">
<h3><span class="section-number">9.6.2. </span>Another example, the moons again<a class="headerlink" href="#another-example-the-moons-again" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from __future__ import division, print_function, unicode_literals

# Common imports
import numpy as np
import os

# to make this notebook&#39;s output stable across runs
np.random.seed(42)

# To plot pretty figures
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
plt.rcParams[&#39;axes.labelsize&#39;] = 14
plt.rcParams[&#39;xtick.labelsize&#39;] = 12
plt.rcParams[&#39;ytick.labelsize&#39;] = 12


from sklearn.svm import SVC
from sklearn import datasets
from sklearn.tree import DecisionTreeClassifier
from sklearn.datasets import make_moons
from sklearn.tree import export_graphviz

Xm, ym = make_moons(n_samples=100, noise=0.25, random_state=53)

deep_tree_clf1 = DecisionTreeClassifier(random_state=42)
deep_tree_clf2 = DecisionTreeClassifier(min_samples_leaf=4, random_state=42)
deep_tree_clf1.fit(Xm, ym)
deep_tree_clf2.fit(Xm, ym)


def plot_decision_boundary(clf, X, y, axes=[0, 7.5, 0, 3], iris=True, legend=False, plot_training=True):
    x1s = np.linspace(axes[0], axes[1], 100)
    x2s = np.linspace(axes[2], axes[3], 100)
    x1, x2 = np.meshgrid(x1s, x2s)
    X_new = np.c_[x1.ravel(), x2.ravel()]
    y_pred = clf.predict(X_new).reshape(x1.shape)
    custom_cmap = ListedColormap([&#39;#fafab0&#39;,&#39;#9898ff&#39;,&#39;#a0faa0&#39;])
    plt.contourf(x1, x2, y_pred, alpha=0.3, cmap=custom_cmap)
    if not iris:
        custom_cmap2 = ListedColormap([&#39;#7d7d58&#39;,&#39;#4c4c7f&#39;,&#39;#507d50&#39;])
        plt.contour(x1, x2, y_pred, cmap=custom_cmap2, alpha=0.8)
    if plot_training:
        plt.plot(X[:, 0][y==0], X[:, 1][y==0], &quot;yo&quot;, label=&quot;Iris-Setosa&quot;)
        plt.plot(X[:, 0][y==1], X[:, 1][y==1], &quot;bs&quot;, label=&quot;Iris-Versicolor&quot;)
        plt.plot(X[:, 0][y==2], X[:, 1][y==2], &quot;g^&quot;, label=&quot;Iris-Virginica&quot;)
        plt.axis(axes)
    if iris:
        plt.xlabel(&quot;Petal length&quot;, fontsize=14)
        plt.ylabel(&quot;Petal width&quot;, fontsize=14)
    else:
        plt.xlabel(r&quot;$x_1$&quot;, fontsize=18)
        plt.ylabel(r&quot;$x_2$&quot;, fontsize=18, rotation=0)
    if legend:
        plt.legend(loc=&quot;lower right&quot;, fontsize=14)
plt.figure(figsize=(11, 4))
plt.subplot(121)
plot_decision_boundary(deep_tree_clf1, Xm, ym, axes=[-1.5, 2.5, -1, 1.5], iris=False)
plt.title(&quot;No restrictions&quot;, fontsize=16)
plt.subplot(122)
plot_decision_boundary(deep_tree_clf2, Xm, ym, axes=[-1.5, 2.5, -1, 1.5], iris=False)
plt.title(&quot;min_samples_leaf = {}&quot;.format(deep_tree_clf2.min_samples_leaf), fontsize=14)
plt.show()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>np.random.seed(6)
Xs = np.random.rand(100, 2) - 0.5
ys = (Xs[:, 0] &gt; 0).astype(np.float32) * 2

angle = np.pi/4
rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])
Xsr = Xs.dot(rotation_matrix)

tree_clf_s = DecisionTreeClassifier(random_state=42)
tree_clf_s.fit(Xs, ys)
tree_clf_sr = DecisionTreeClassifier(random_state=42)
tree_clf_sr.fit(Xsr, ys)

plt.figure(figsize=(11, 4))
plt.subplot(121)
plot_decision_boundary(tree_clf_s, Xs, ys, axes=[-0.7, 0.7, -0.7, 0.7], iris=False)
plt.subplot(122)
plot_decision_boundary(tree_clf_sr, Xsr, ys, axes=[-0.7, 0.7, -0.7, 0.7], iris=False)

plt.show()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Quadratic training set + noise
np.random.seed(42)
m = 200
X = np.random.rand(m, 1)
y = 4 * (X - 0.5) ** 2
y = y + np.random.randn(m, 1) / 10
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from sklearn.tree import DecisionTreeRegressor

tree_reg = DecisionTreeRegressor(max_depth=2, random_state=42)
tree_reg.fit(X, y)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from sklearn.tree import DecisionTreeRegressor

tree_reg1 = DecisionTreeRegressor(random_state=42, max_depth=2)
tree_reg2 = DecisionTreeRegressor(random_state=42, max_depth=3)
tree_reg1.fit(X, y)
tree_reg2.fit(X, y)

def plot_regression_predictions(tree_reg, X, y, axes=[0, 1, -0.2, 1], ylabel=&quot;$y$&quot;):
    x1 = np.linspace(axes[0], axes[1], 500).reshape(-1, 1)
    y_pred = tree_reg.predict(x1)
    plt.axis(axes)
    plt.xlabel(&quot;$x_1$&quot;, fontsize=18)
    if ylabel:
        plt.ylabel(ylabel, fontsize=18, rotation=0)
    plt.plot(X, y, &quot;b.&quot;)
    plt.plot(x1, y_pred, &quot;r.-&quot;, linewidth=2, label=r&quot;$\hat{y}$&quot;)

plt.figure(figsize=(11, 4))
plt.subplot(121)
plot_regression_predictions(tree_reg1, X, y)
for split, style in ((0.1973, &quot;k-&quot;), (0.0917, &quot;k--&quot;), (0.7718, &quot;k--&quot;)):
    plt.plot([split, split], [-0.2, 1], style, linewidth=2)
plt.text(0.21, 0.65, &quot;Depth=0&quot;, fontsize=15)
plt.text(0.01, 0.2, &quot;Depth=1&quot;, fontsize=13)
plt.text(0.65, 0.8, &quot;Depth=1&quot;, fontsize=13)
plt.legend(loc=&quot;upper center&quot;, fontsize=18)
plt.title(&quot;max_depth=2&quot;, fontsize=14)

plt.subplot(122)
plot_regression_predictions(tree_reg2, X, y, ylabel=None)
for split, style in ((0.1973, &quot;k-&quot;), (0.0917, &quot;k--&quot;), (0.7718, &quot;k--&quot;)):
    plt.plot([split, split], [-0.2, 1], style, linewidth=2)
for split in (0.0458, 0.1298, 0.2873, 0.9040):
    plt.plot([split, split], [-0.2, 1], &quot;k:&quot;, linewidth=1)
plt.text(0.3, 0.5, &quot;Depth=2&quot;, fontsize=13)
plt.title(&quot;max_depth=3&quot;, fontsize=14)

plt.show()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tree_reg1 = DecisionTreeRegressor(random_state=42)
tree_reg2 = DecisionTreeRegressor(random_state=42, min_samples_leaf=10)
tree_reg1.fit(X, y)
tree_reg2.fit(X, y)

x1 = np.linspace(0, 1, 500).reshape(-1, 1)
y_pred1 = tree_reg1.predict(x1)
y_pred2 = tree_reg2.predict(x1)

plt.figure(figsize=(11, 4))

plt.subplot(121)
plt.plot(X, y, &quot;b.&quot;)
plt.plot(x1, y_pred1, &quot;r.-&quot;, linewidth=2, label=r&quot;$\hat{y}$&quot;)
plt.axis([0, 1, -0.2, 1.1])
plt.xlabel(&quot;$x_1$&quot;, fontsize=18)
plt.ylabel(&quot;$y$&quot;, fontsize=18, rotation=0)
plt.legend(loc=&quot;upper center&quot;, fontsize=18)
plt.title(&quot;No restrictions&quot;, fontsize=14)

plt.subplot(122)
plt.plot(X, y, &quot;b.&quot;)
plt.plot(x1, y_pred2, &quot;r.-&quot;, linewidth=2, label=r&quot;$\hat{y}$&quot;)
plt.axis([0, 1, -0.2, 1.1])
plt.xlabel(&quot;$x_1$&quot;, fontsize=18)
plt.title(&quot;min_samples_leaf={}&quot;.format(tree_reg2.min_samples_leaf), fontsize=14)

plt.show()
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="pros-and-cons-of-trees-pros">
<h2><span class="section-number">9.7. </span>Pros and cons of trees, pros<a class="headerlink" href="#pros-and-cons-of-trees-pros" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>White box, easy to interpret model. Some people believe that decision trees more closely mirror human decision-making than do the regression and classification approaches discussed earlier (think of support vector machines)</p></li>
<li><p>Trees are very easy to explain to people. In fact, they are even easier to explain than linear regression!</p></li>
<li><p>No feature normalization needed</p></li>
<li><p>Tree models can handle both continuous and categorical data (Classification and Regression Trees)</p></li>
<li><p>Can model nonlinear relationships</p></li>
<li><p>Can model interactions between the different descriptive features</p></li>
<li><p>Trees can be displayed graphically, and are easily interpreted even by a non-expert (especially if they are small)</p></li>
</ul>
<section id="disadvantages">
<h3><span class="section-number">9.7.1. </span>Disadvantages<a class="headerlink" href="#disadvantages" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Unfortunately, trees generally do not have the same level of predictive accuracy as some of the other regression and classification approaches</p></li>
<li><p>If continuous features are used the tree may become quite large and hence less interpretable</p></li>
<li><p>Decision trees are prone to overfit the training data and hence do not well generalize the data if no stopping criteria or improvements like pruning, boosting or bagging are implemented</p></li>
<li><p>Small changes in the data may lead to a completely different tree. This issue can be addressed by using ensemble methods like bagging, boosting or random forests</p></li>
<li><p>Unbalanced datasets where some target feature values occur much more frequently than others may lead to biased trees since the frequently occurring feature values are preferred over the less frequently occurring ones.</p></li>
<li><p>If the number of features is relatively large (high dimensional) and the number of instances is relatively low, the tree might overfit the data</p></li>
<li><p>Features with many levels may be preferred over features with less levels since for them it is <em>more easy</em> to split the dataset such that the sub datasets only contain pure target feature values. This issue can be addressed by preferring for instance the information gain ratio as splitting criteria over information gain</p></li>
</ul>
<p>However, by aggregating many decision trees, using methods like
bagging, random forests, and boosting, the predictive performance of
trees can be substantially improved.</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="chapter5.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Support Vector Machines, overarching aims</p>
      </div>
    </a>
    <a class="right-next"
       href="chapter7.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Ensemble Methods: From a Single Tree to Many Trees and Extreme Boosting, Meet the Jungle of Methods</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basics-of-a-tree">9.1. Basics of a tree</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#general-features">9.2. General Features</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#building-a-tree-regression">9.3. Building a tree, regression</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-a-tree">9.3.1. Making a tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schematic-regression-procedure">9.3.2. Schematic Regression Procedure</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-classification-tree">9.4. A Classification Tree</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizing-the-tree-classification">9.4.1. Visualizing the Tree, Classification</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#other-ways-of-visualizing-the-trees">9.4.2. Other ways of visualizing the trees</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms-for-setting-up-decision-trees">9.5. Algorithms for Setting up Decision Trees</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-cart-algorithm-for-classification">9.5.1. The CART algorithm for Classification</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-cart-algorithm-for-regression">9.5.2. The CART algorithm for Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-the-gini-index">9.5.3. Computing the Gini index</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simple-python-code-to-read-in-data-and-perform-classification">9.5.4. Simple Python Code to read in Data and perform Classification</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-and-the-id3-algorithm">9.6. Entropy and the ID3 algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cancer-data-again-now-with-decision-trees-and-other-methods">9.6.1. Cancer Data again now with Decision Trees and other Methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#another-example-the-moons-again">9.6.2. Another example, the moons again</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pros-and-cons-of-trees-pros">9.7. Pros and cons of trees, pros</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#disadvantages">9.7.1. Disadvantages</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Morten Hjorth-Jensen
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>